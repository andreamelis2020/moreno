! function(j, se, le) { "use strict";

    function e(e, t) { if (t.has("$swipe")) { e.warn("You are using the ngTouch module. \nAngularJS Material already has mobile click, tap, and swipe support... \nngTouch is not supported with AngularJS Material!") } }

    function t(e, t) { e.decorator("$$rAF", ["$delegate", n]), e.decorator("$q", ["$delegate", i]), t.theme("default").primaryPalette("indigo").accentPalette("pink").warnPalette("deep-orange").backgroundPalette("grey") }

    function n(r) { return r.throttle = function(e) { var t, n, i, o; return function() { t = arguments, o = this, i = e, n || (n = !0, r(function() { i.Apply(o, Array.prototype.slice.call(t)), n = !1 })) } }, r }

    function i(e) { return e.resolve || (e.resolve = e.when), e }

    function o(r) { return { restrict: "A", link: { pre: function(e, t, n) { var i = n.mdAutoFocus || n.mdAutofocus || n.mdSidenavFocus;
                    o(r(i)(e)), i && e.$watch(i, o);

                    function o(e) { se.isUndefined(e) && (e = !0), t.toggleClass("md-autofocus", !!e) } } } } }

    function r(e, s) {
        function l() { return !0 }
        e && !se.isArray(e) && (e = Array.prototype.slice.call(e)), s = !!s; var c = e || []; return { items: function() { return [].concat(c) }, count: function() { return c.length }, inRange: d, contains: t, indexOf: u, itemAt: function(e) { return d(e) ? c[e] : null }, findBy: function(t, n) { return c.filter(function(e) { return e[t] === n }) }, add: function(e, t) { if (!e) return -1;
                se.isNumber(t) || (t = c.length); return c.splice(t, 0, e), u(e) }, remove: function(e) { t(e) && c.splice(u(e), 1) }, first: m, last: p, next: se.bind(null, n, !1), previous: se.bind(null, n, !0), hasPrevious: function(e) { return !!e && d(u(e) - 1) }, hasNext: function(e) { return !!e && d(u(e) + 1) } };

        function d(e) { return c.length && -1 < e && e < c.length }

        function u(e) { return c.indexOf(e) }

        function t(e) { return e && -1 < u(e) }

        function m() { return c.length ? c[0] : null }

        function p() { return c.length ? c[c.length - 1] : null }

        function n(e, t, n, i) { n = n || l; for (var o = u(t);;) { if (!d(o)) return null; var r = o + (e ? -1 : 1),
                    a = null; if (d(r) ? a = c[r] : s && (r = u(a = e ? p() : m())), null === a || r === i) return null; if (n(a)) return a;
                se.isUndefined(i) && (i = r), o = r } } }

    function a(a, t, o) { var r = {},
            s = {},
            l = {},
            n = {}; return e.getResponsiveAttribute = function(e, t) { for (var n = 0; n < a.MEDIA_PRIORITY.length; n++) { var i = a.MEDIA_PRIORITY[n]; if (s[r[i]].matches) { var o = d(e, t + "-" + i); if (e[o]) return e[o] } } return e[d(e, t)] }, e.getQuery = function(e) { return s[e] }, e.watchResponsiveAttributes = function(e, i, o) { var r = []; return e.forEach(function(e) { var t = d(i, e); for (var n in se.isDefined(i[t]) && r.push(i.$observe(t, se.bind(void 0, o, null))), a.MEDIA) t = d(i, e + "-" + n), se.isDefined(i[t]) && r.push(i.$observe(t, se.bind(void 0, o, n))) }),
                function() { r.forEach(function(e) { e() }) } }, e;

        function e(e) { var t, n = r[e];
            se.isUndefined(n) && (n = r[e] = (t = e, a.MEDIA[t] || ("(" !== t.charAt(0) ? "(" + t + ")" : t))); var i = l[n]; return se.isUndefined(i) && (i = function(e) { var t = s[e];
                t = t || (s[e] = o.matchMedia(e)); return t.addListener(c), l[t.media] = !!t.matches }(n)), i }

        function c(e) { t.$evalAsync(function() { l[e.media] = !!e.matches }) }

        function d(e, t) { return n[t] || (n[t] = e.$normalize(t)) } }

    function s(e, t) { var i = ["data", "x"]; return e ? t ? n(e) : o(e) : { buildList: o, buildSelector: n, hasAttribute: function(e, t) { if (!(e = r(e))) return !1; for (var n = o(t), i = 0; i < n.length; i++)
                    if (e.hasAttribute(n[i])) return !0;
                return !1 }, removeAttribute: function(t, e) { if (!(t = r(t))) return;
                o(e).forEach(function(e) { t.removeAttribute(e) }) } };

        function o(n) { return (n = se.isArray(n) ? n : [n]).forEach(function(t) { i.forEach(function(e) { n.push(e + "-" + t) }) }), n }

        function n(e) { return o(e = se.isArray(e) ? e : [e]).map(function(e) { return "[" + e + "]" }).join(",") }

        function r(e) { if ((e = e[0] || e).nodeType) return e } }

    function l(i, o, l, r) { var a = this.showWarnings; return { expect: s, expectAsync: c, expectWithText: function(e, t) { var n = d(e) || ""; - 1 < n.indexOf(r.startSymbol()) ? c(e, t, function() { return d(e) }) : s(e, t, n) }, expectWithoutText: function(e, t) { var n = d(e); - 1 < n.indexOf(r.startSymbol()) || n || s(e, t, n) }, getText: d, hasAriaLabel: u, parentHasAriaLabel: function e(t, n) { n = n || 1; var i = se.element(t)[0] || t; if (!i.parentNode) return !1; if (o(i.parentNode)) return !0;
                n--; if (n) return e(i.parentNode, n); return !1;

                function o(e) { if (!u(e)) return !1; if (e.hasAttribute("role")) switch (e.getAttribute("role").toLowerCase()) {
                        case "command":
                        case "definition":
                        case "directory":
                        case "grid":
                        case "list":
                        case "listitem":
                        case "log":
                        case "marquee":
                        case "menu":
                        case "menubar":
                        case "note":
                        case "presentation":
                        case "separator":
                        case "scrollbar":
                        case "status":
                        case "tablist":
                            return !1 }
                    switch (e.tagName.toLowerCase()) {
                        case "abbr":
                        case "acronym":
                        case "address":
                        case "applet":
                        case "audio":
                        case "b":
                        case "bdi":
                        case "bdo":
                        case "big":
                        case "blockquote":
                        case "br":
                        case "canvas":
                        case "caption":
                        case "center":
                        case "cite":
                        case "code":
                        case "col":
                        case "data":
                        case "dd":
                        case "del":
                        case "dfn":
                        case "dir":
                        case "div":
                        case "dl":
                        case "em":
                        case "embed":
                        case "fieldset":
                        case "figcaption":
                        case "font":
                        case "h1":
                        case "h2":
                        case "h3":
                        case "h4":
                        case "h5":
                        case "h6":
                        case "hgroup":
                        case "html":
                        case "i":
                        case "ins":
                        case "isindex":
                        case "kbd":
                        case "keygen":
                        case "label":
                        case "legend":
                        case "li":
                        case "map":
                        case "mark":
                        case "menu":
                        case "object":
                        case "ol":
                        case "output":
                        case "pre":
                        case "presentation":
                        case "q":
                        case "rt":
                        case "ruby":
                        case "samp":
                        case "small":
                        case "source":
                        case "span":
                        case "status":
                        case "strike":
                        case "strong":
                        case "sub":
                        case "sup":
                        case "svg":
                        case "tbody":
                        case "td":
                        case "th":
                        case "thead":
                        case "time":
                        case "tr":
                        case "track":
                        case "tt":
                        case "ul":
                        case "var":
                            return !1 } return !0 } } };

        function s(e, t, n) { var i = se.element(e)[0] || e;!i || i.hasAttribute(t) && 0 !== i.getAttribute(t).length || function(e, t) { var n = e.hasChildNodes(),
                    i = !1; if (n)
                    for (var o = e.childNodes, r = 0; r < o.length; r++) { var a = o[r];
                        1 === a.nodeType && a.hasAttribute(t) && "none" !== ((s = a).currentStyle ? s.currentStyle : l.getComputedStyle(s)).display && (i = !0) }
                var s; return i }(i, t) || ((n = se.isString(n) ? n.trim() : "").length ? e.attr(t, n) : a && o.warn('ARIA: Attribute "', t, '", required for accessibility, is missing on node:', i)) }

        function c(e, t, n) { i(function() { s(e, t, n()) }) }

        function d(t) { t = t[0] || t; for (var e, n = document.createTreeWalker(t, NodeFilter.SHOW_TEXT, null, !1), i = ""; e = n.nextNode();) o(e) || (i += e.textContent); return i.trim() || "";

            function o(e) { for (; e.parentNode && (e = e.parentNode) !== t;)
                    if (e.getAttribute && "true" === e.getAttribute("aria-hidden")) return !0 } }

        function u(e) { var t = se.element(e)[0] || e; return !!t.hasAttribute && (t.hasAttribute("aria-label") || t.hasAttribute("aria-labelledby") || t.hasAttribute("aria-describedby")) } }

    function c(e) { var t = !1;

        function r() { return !t || ("function" == typeof e.preAssignBindingsEnabled ? e.preAssignBindingsEnabled() : 1 === se.version.major && se.version.minor < 6) }

        function a(e, t, n, i, o) { this.$q = e, this.$templateRequest = t, this.$injector = n, this.$compile = i, this.$controller = o }
        this.respectPreAssignBindingsEnabled = function(e) { return se.isDefined(e) ? (t = e, this) : t }, this.$get = ["$q", "$templateRequest", "$injector", "$compile", "$controller", function(e, t, n, i, o) { return new a(e, t, n, i, o) }], a.prototype.compile = function(e) { return e.contentElement ? this._prepareContentElement(e) : this._compileTemplate(e) }, a.prototype._prepareContentElement = function(e) { var t = this._fetchContentElement(e); return this.$q.resolve({ element: t.element, cleanup: t.restore, locals: {}, link: function() { return t.element } }) }, a.prototype._compileTemplate = function(i) { var o = this,
                e = i.templateUrl,
                t = i.template || "",
                n = se.extend({}, i.resolve),
                r = se.extend({}, i.locals),
                a = i.transformTemplate || se.identity; return se.forEach(n, function(e, t) { se.isString(e) ? n[t] = o.$injector.get(e) : n[t] = o.$injector.invoke(e) }), se.extend(n, r), n.$$ngTemplate = e ? this.$templateRequest(e) : this.$q.when(t), this.$q.all(n).then(function(e) { var t = a(e.$$ngTemplate, i),
                    n = i.element || se.element("<div>").html(t.trim()).contents(); return o._compileElement(e, n, i) }) }, a.prototype._compileElement = function(i, o, r) { var a = this,
                s = this.$compile(o),
                l = { element: o, cleanup: o.remove.bind(o), locals: i, link: function(e) { if (i.$scope = e, r.controller) { var t = se.extend({}, i, { $element: o }),
                                n = a._createController(r, t, i);
                            o.data("$ngControllerController", n), o.children().data("$ngControllerController", n), l.controller = n } return s(e) } }; return l }, a.prototype._createController = function(e, t, n) { var i = this.$controller(e.controller, t, !0, e.controllerAs);
            r() && e.bindToController && se.extend(i.instance, n); var o = i(); return !r() && e.bindToController && se.extend(i.instance, n), se.isFunction(o.$onInit) && o.$onInit(), o }, a.prototype._fetchContentElement = function(e) { var t = e.contentElement,
                n = null; return n = se.isString(t) ? i(t = document.querySelector(t)) : (t = t[0] || t, document.contains(t) ? i(t) : function() { t.parentNode && t.parentNode.removeChild(t) }), { element: se.element(t), restore: n };

            function i(e) { var t = e.parentNode,
                    n = e.nextElementSibling; return function() { n ? t.insertBefore(e, n) : t.appendChild(e) } } } }

    function d(e, t) { this.$timeout = e, this.$mdUtil = t, this.bodyElement = se.element(document.body), this.isBuffering = !1, this.bufferTimeout = null, this.lastInteractionType = null, this.lastInteractionTime = null, this.inputEventMap = { keydown: "keyboard", mousedown: "mouse", mouseenter: "mouse", touchstart: "touch", pointerdown: "pointer", MSPointerDown: "pointer" }, this.iePointerMap = { 2: "touch", 3: "touch", 4: "mouse" }, this.initializeEvents() }

    function u(e) { return e.replace(A, "").replace(S, function(e, t, n, i) { return i ? n.toUpperCase() : n }) }

    function m() { var e = !!document.querySelector("[md-layouts-disabled]");
        R.enabled = !e }

    function p() { return R.enabled = !1, { restrict: "A", priority: "900" } }

    function h(i) { return ["$mdUtil", "$interpolate", "$log", function(e, t, n) { return x = e, w = t, T = n, { restrict: "A", compile: function(e, t) { var n; return R.enabled && (v(i, C(i, t, ""), b(e, i, t)), o(null, e), n = o), n || se.noop } } }];

        function o(e, t) { t.addClass(i) } }

    function f(t) { var n = t.split("-"); return ["$log", function(e) { return e.warn(t + "has been deprecated. Please use a `" + n[0] + "-gt-<xxx>` variant."), se.noop }] }

    function g(e, t, n, i) { var o, r = n[0].nodeName.toLowerCase(); switch (e.replace(D, "")) {
            case "flex":
                "md-button" != r && "fieldset" != r || (o = "<" + r + " " + e + "></" + r + ">", i.warn(x.supplant("Markup '{0}' may not work as expected in IE Browsers. Consult '{1}' for details.", [o, "https://github.com/philipwalton/flexbugs#9-some-html-elements-cant-be-flex-containers"]))) } }

    function v(e, t, n) { if (!$(t)) { switch (e.replace(D, "")) {
                case "layout":
                    y(t, O) || (t = O[0]); break;
                case "flex":
                    y(t, _) || isNaN(t) && (t = ""); break;
                case "flex-offset":
                case "flex-order":
                    t && !isNaN(+t) || (t = "0"); break;
                case "layout-align":
                    var i = function(e) { var t, n = { main: "start", cross: "stretch" };
                        0 !== (e = e || "").indexOf("-") && 0 !== e.indexOf(" ") || (e = "none" + e);
                        (t = e.toLowerCase().trim().replace(I, "-").split("-")).length && "space" === t[0] && (t = [t[0] + "-" + t[1], t[2]]);
                        0 < t.length && (n.main = t[0] || n.main);
                        1 < t.length && (n.cross = t[1] || n.cross);
                        P.indexOf(n.main) < 0 && (n.main = "start");
                        L.indexOf(n.cross) < 0 && (n.cross = "stretch"); return n }(t);
                    t = x.supplant("{main}-{cross}", i); break;
                case "layout-padding":
                case "layout-margin":
                case "layout-fill":
                case "layout-wrap":
                case "layout-nowrap":
                case "layout-nowrap":
                    t = "" }
            null != t && (n || se.noop)(t) } return t ? t.trim() : "" }

    function b(e, t, n) { return function(e) { $(e) || (n[n.$normalize(t)] = e) } }

    function $(e) { return -1 < (e || "").indexOf(w.startSymbol()) }

    function C(e, t, n) { var i = t.$normalize(e); return t[i] ? t[i].trim().replace(I, "-") : n || null }

    function y(t, e, n) { t = n && t ? t.replace(I, n) : t; var i = !1; return t && e.forEach(function(e) { e = n ? e.replace(I, n) : e, i = i || e === t }), i } var x, w, T, E, A, S, k, M, D, I, _, O, P, L, R, N, F, B, U, q, H;

    function z(e) { this._$timeout = e, this._liveElement = this._createLiveElement(), this._announceTimeout = 100 }

    function W(n, i) { var o, r = [],
            a = {}; return o = { notFoundError: function(e, t) { n.error((t || "") + "No instance found for handle", e) }, getInstances: function() { return r }, get: function(e) { if (!s(e)) return null; var t, n, i; for (t = 0, n = r.length; t < n; t++)
                    if ((i = r[t]).$$mdHandle === e) return i;
                return null }, register: function(t, e) { return e ? (t.$$mdHandle = e, r.push(t), (n = a[e]) && (n.forEach(function(e) { e.resolve(t) }), delete a[e]), function() { var e = r.indexOf(t); - 1 !== e && r.splice(e, 1) }) : se.noop; var n }, when: function(e) { if (s(e)) { var t = i.defer(),
                        n = o.get(e); return n ? t.resolve(n) : (a[e] === le && (a[e] = []), a[e].push(t)), t.promise } return i.reject("Invalid `md-component-id` value.") } };

        function s(e) { return e && "" !== e } }

    function V(o) { return { attach: function(e, t, n) { var i; return n = se.extend((i = t).hasClass("md-icon-button") ? { isMenuItem: i.hasClass("md-menu-item"), fitRipple: !0, center: !0 } : { isMenuItem: i.hasClass("md-menu-item"), dimBackground: !0 }, n), o.attach(e, t, n) } } }

    function Y(i) { return { attach: function(e, t, n) { return i.attach(e, t, se.extend({ center: !0, dimBackground: !1, fitRipple: !0 }, n)) } } }

    function K(i) { return { attach: function(e, t, n) { return i.attach(e, t, se.extend({ center: !1, dimBackground: !0, outline: !1, rippleSize: "full" }, n)) } } }

    function G(i) { return { attach: function(e, t, n) { return i.attach(e, t, se.extend({ center: !1, dimBackground: !0, outline: !1, rippleSize: "full" }, n)) } } }

    function X(e) { return e.replace(/-[a-z]/g, function(e) { return e.charAt(1).toUpperCase() }) }

    function Q(n) { return { restrict: "E", link: function(e, t) { t.addClass("_md"), e.$on("$destroy", function() { n.destroy() }) } } }

    function Z(e) { t.$inject = ["$animate", "$mdConstant", "$mdUtil", "$mdTheming", "$mdBottomSheet", "$rootElement", "$mdGesture", "$log"]; var f = .5,
            g = 80; return e("$mdBottomSheet").setDefaults({ methods: ["disableParentScroll", "escapeToClose", "clickOutsideToClose"], options: t });

        function t(r, a, s, l, c, d, u, m) { var p; return { themable: !0, onShow: function(e, t, n, i) { if ((t = s.extractElementByName(t, "md-bottom-sheet")).attr("tabindex", "-1"), t.hasClass("data-ng-cloak")) { m.warn("$mdBottomSheet: using `<md-bottom-sheet data-ng-cloak >` will affect the bottom-sheet opening animations.", t[0]) }
                    n.disableBackdrop || ((p = s.createBackdrop(e, "md-bottom-sheet-backdrop md-opaque"))[0].tabIndex = -1, n.clickOutsideToClose && p.on("click", function() { s.nextTick(c.cancel, !0) }), l.inherit(p, n.parent), r.enter(p, n.parent, null)); var o = new h(t, n.parent);
                    n.bottomSheet = o, l.inherit(o.element, n.parent), n.disableParentScroll && (n.restoreScroll = s.disableScrollAround(o.element, n.parent)); return r.enter(o.element, n.parent, p).then(function() { var e = s.findFocusTarget(t) || se.element(t[0].querySelector("button") || t[0].querySelector("a") || t[0].querySelector(s.prefixer("data-ng-click", !0))) || p;
                        n.escapeToClose && (n.rootElementKeyupCallback = function(e) { e.keyCode === a.KEY_CODE.ESCAPE && s.nextTick(c.cancel, !0) }, d.on("keyup", n.rootElementKeyupCallback), e && e.focus()) }) }, onRemove: function(e, t, n) { var i = n.bottomSheet;
                    n.disableBackdrop || r.leave(p); return r.leave(i.element).then(function() { n.disableParentScroll && (n.restoreScroll(), delete n.restoreScroll), i.cleanup() }) }, disableBackdrop: !1, escapeToClose: !0, clickOutsideToClose: !0, disableParentScroll: !0 };

            function h(i, e) { var t = u.register(e, "drag", { horizontal: !1 }); return e.on("$md.dragstart", n).on("$md.drag", o).on("$md.dragend", r), { element: i, cleanup: function() { t(), e.off("$md.dragstart", n), e.off("$md.drag", o), e.off("$md.dragend", r) } };

                function n(e) { i.css(a.CSS.TRANSITION_DURATION, "0ms") }

                function o(e) { var t = e.pointer.distanceY;
                    t < 5 && (t = Math.max(-g, t / 2)), i.css(a.CSS.TRANSFORM, "translate3d(0," + (g + t) + "px,0)") }

                function r(e) { if (0 < e.pointer.distanceY && (20 < e.pointer.distanceY || Math.abs(e.pointer.velocityY) > f)) { var t = i.prop("offsetHeight") - e.pointer.distanceY,
                            n = Math.min(t / e.pointer.velocityY * .75, 500);
                        i.css(a.CSS.TRANSITION_DURATION, n + "ms"), s.nextTick(c.cancel, !0) } else i.css(a.CSS.TRANSITION_DURATION, ""), i.css(a.CSS.TRANSFORM, "") } } } }

    function J(n) { return { restrict: "E", link: function(e, t) { n(t) } } }

    function ee(i, o, r, a) { return { restrict: "EA", replace: !0, transclude: !0, template: function(e, t) {
                { return s(t) ? '<a class="md-button" data-ng-transclude></a>' : '<button class="md-button" type="' + (void 0 === t.type ? "button" : t.type) + '" data-ng-transclude></button>' } }, link: function(e, t, n) { o(t), i.attach(e, t), r.expectWithoutText(t, "aria-label"), s(n) && se.isDefined(n.ngDisabled) && e.$watch(n.ngDisabled, function(e) { t.attr("tabindex", e ? -1 : 0) });
                t.on("click", function(e) {!0 === n.disabled && (e.preventDefault(), e.stopImmediatePropagation()) }), t.hasClass("md-no-focus") || (t.on("focus", function() { a.isUserInvoked() && "keyboard" !== a.getLastInteractionType() || t.addClass("md-focused") }), t.on("blur", function() { t.removeClass("md-focused") })) } };

        function s(e) { return se.isDefined(e.href) || se.isDefined(e.ngHref) || se.isDefined(e.ngLink) || se.isDefined(e.uiSref) } }

    function te(i) { return { restrict: "E", link: function(e, t, n) { t.addClass("_md"), i(t) } } }

    function ne(u, m, p, h, f, g) { return u = u[0], { restrict: "E", transclude: !0, require: ["^?mdInputContainer", "?ngModel", "?^form"], priority: p.BEFORE_NG_ARIA, template: '<div class="md-container" data-md-ink-ripple data-md-ink-ripple-checkbox><div class="md-icon"></div></div><div data-ng-transclude class="md-label"></div>', compile: function(e, t) { return t.$set("tabindex", t.tabindex || "0"), t.$set("type", "checkbox"), t.$set("role", t.type), { pre: function(e, t) { t.on("click", function(e) { this.hasAttribute("disabled") && e.stopImmediatePropagation() }) }, post: function(i, o, r, e) { var t, n = e[0],
                            a = e[1] || f.fakeNgModel(),
                            s = e[2]; if (n) { var l = n.isErrorGetter || function() { return a.$invalid && (a.$touched || s && s.$submitted) };
                            n.input = o, i.$watch(l, n.setInvalid) }
                        h(o), o.children().on("focus", function() { o.focus() }), f.parseAttributeBoolean(r.mdIndeterminate) && (d(), i.$watch(r.mdIndeterminate, d));
                        r.ngChecked && i.$watch(i.$eval.bind(i, r.ngChecked), function(e) { a.$setViewValue(e), a.$render() });

                        function c(t) { o[0].hasAttribute("disabled") || i.skipToggle || i.$Apply(function() { var e = r.ngChecked && r.ngClick ? r.checked : !a.$viewValue;
                                a.$setViewValue(e, t && t.type), a.$render() }) }

                        function d(e) {
                            (t = !1 !== e) && o.attr("aria-checked", "mixed"), o.toggleClass("md-indeterminate", t) }(function(e, t, n) { r[e] && i.$watch(r[e], function(e) { n[e] && o.attr(t, n[e]) }) })("ngDisabled", "tabindex", { true: "-1", false: r.tabindex }), m.expectWithText(o, "aria-label"), u.link.pre(i, { on: se.noop, 0: {} }, r, [a]), o.on("click", c).on("keypress", function(e) { var t = e.which || e.keyCode;
                            t !== p.KEY_CODE.SPACE && t !== p.KEY_CODE.ENTER || (e.preventDefault(), o.addClass("md-focused"), c(e)) }).on("focus", function() { "keyboard" === g.getLastInteractionType() && o.addClass("md-focused") }).on("blur", function() { o.removeClass("md-focused") }), a.$render = function() { o.toggleClass("md-checked", !!a.$viewValue && !t) } } } } } }

    function ie(i) { return { restrict: "E", controller: ["$scope", "$element", function(e, t) { this.$scope = e, this.$element = t }], link: function(e, t) { var n;
                t.addClass("_md"), i(t), e.$broadcast("$mdContentLoaded", t), n = t[0], se.element(n).on("$md.pressdown", function(e) { "t" === e.pointer.type && (e.$materialScrollFixed || (e.$materialScrollFixed = !0, 0 === n.scrollTop ? n.scrollTop = 1 : n.scrollHeight === n.scrollTop + n.offsetHeight && --n.scrollTop)) }) } } }

    function oe(e, t, r) { return { restrict: "E", link: function(i, o) { o.addClass("_md"), t(o), e(function() { var e, t = o[0].querySelector("md-dialog-content");

                    function n() { o.toggleClass("md-content-overflow", t.scrollHeight > t.clientHeight) }
                    t && (e = t.getElementsByTagName("img"), n(), se.element(e).on("load", n)), i.$on("$destroy", function() { r.destroy(o) }) }) } } }

    function re(e) { var v, b; return n.$inject = ["$mdDialog", "$mdConstant"], i.$inject = ["$mdDialog", "$mdAria", "$mdUtil", "$mdConstant", "$animate", "$document", "$window", "$rootElement", "$log", "$injector", "$mdTheming", "$interpolate", "$mdInteraction"], e("$mdDialog").setDefaults({ methods: ["disableParentScroll", "hasBackdrop", "clickOutsideToClose", "escapeToClose", "targetEvent", "closeTo", "openFrom", "parent", "fullscreen", "multiple"], options: i }).addPreset("alert", { methods: ["title", "htmlContent", "textContent", "content", "ariaLabel", "ok", "theme", "css"], options: t }).addPreset("confirm", { methods: ["title", "htmlContent", "textContent", "content", "ariaLabel", "ok", "cancel", "theme", "css"], options: t }).addPreset("prompt", { methods: ["title", "htmlContent", "textContent", "initialValue", "content", "placeholder", "ariaLabel", "ok", "cancel", "theme", "css", "required"], options: t });

        function t() { return { template: ['<md-dialog md-theme="{{ dialog.theme || dialog.defaultTheme }}" aria-label="{{ dialog.ariaLabel }}" data-ng-class="dialog.css">', '  <md-dialog-content class="md-dialog-content" role="document" tabIndex="-1">', '    <h2 class="md-title">{{ dialog.title }}</h2>', '    <div data-ng-if="::dialog.mdHtmlContent" class="md-dialog-content-body" ', '        data-ng-bind-html="::dialog.mdHtmlContent"></div>', '    <div data-ng-if="::!dialog.mdHtmlContent" class="md-dialog-content-body">', "      <p>{{::dialog.mdTextContent}}</p>", "    </div>", '    <md-input-container md-no-float data-ng-if="::dialog.$type == \'prompt\'" class="md-prompt-input-container">', '      <input data-ng-keypress="dialog.keypress($event)" md-autofocus data-ng-model="dialog.result"              placeholder="{{::dialog.placeholder}}" data-ng-required="dialog.required">', "    </md-input-container>", "  </md-dialog-content>", "  <md-dialog-actions>", '    <md-button data-ng-if="dialog.$type === \'confirm\' || dialog.$type === \'prompt\'"               data-ng-click="dialog.abort()" class="md-primary md-cancel-button">', "      {{ dialog.cancel }}", "    </md-button>", '    <md-button data-ng-click="dialog.hide()" class="md-primary md-confirm-button" md-autofocus="dialog.$type===\'alert\'"               data-ng-disabled="dialog.required && !dialog.result">', "      {{ dialog.ok }}", "    </md-button>", "  </md-dialog-actions>", "</md-dialog>"].join("").replace(/\s\s+/g, ""), controller: n, controllerAs: "dialog", bindToController: !0 } }

        function n(t, n) { this.$onInit = function() { var e = "prompt" == this.$type;
                e && this.initialValue && (this.result = this.initialValue), this.hide = function() { t.hide(!e || this.result) }, this.abort = function() { t.cancel() }, this.keypress = function(e) { e.keyCode === n.KEY_CODE.ENTER && t.hide(this.result) } } }

        function i(m, s, p, h, i, l, f, o, c, a, t, r, d) { return { hasBackdrop: !0, isolateScope: !0, onCompiling: function(e) { e.defaultTheme = t.defaultTheme(),
                        function(t) { var e;
                            t.targetEvent && t.targetEvent.target && (e = se.element(t.targetEvent.target)); var n = e && e.controller("mdTheme"); if (!n) return;
                            t.themeWatch = n.$shouldWatch; var i = t.theme || n.$mdTheme;
                            i && (t.scope.theme = i); var o = n.registerChanges(function(e) { t.scope.theme = e, t.themeWatch || o() }) }(e) }, onShow: function(e, n, r, t) { se.element(l[0].body).addClass("md-dialog-is-showing"); var a = n.find("md-dialog"); if (a.hasClass("data-ng-cloak")) { c.warn("$mdDialog: using `<md-dialog data-ng-cloak>` will affect the dialog opening animations.", n[0]) } return function(e) { e.origin = se.extend({ element: null, bounds: null, focus: se.noop }, e.origin || {}), e.parent = n(e.parent, o), e.closeTo = t(n(e.closeTo)), e.openFrom = t(n(e.openFrom)), e.targetEvent && (e.origin = t(e.targetEvent.target, e.origin), e.originInteraction = d.getLastInteractionType());

                            function t(e, t) { var n = se.element(e || {}); if (n && n.length) { var i = se.isFunction(n[0].getBoundingClientRect); return se.extend(t || {}, { element: i ? n : le, bounds: i ? n[0].getBoundingClientRect() : se.extend({}, { top: 0, left: 0, height: 0, width: 0 }, n[0]), focus: se.bind(n, n.focus) }) } }

                            function n(e, t) { return se.isString(e) && (e = l[0].querySelector(e)), se.element(e || t) } }(r),
                        function(e, t) { var n = "alert" === t.$type ? "alertdialog" : "dialog",
                                i = e.find("md-dialog-content"),
                                o = e.attr("id"),
                                r = "dialogContent_" + (o || p.nextUid());
                            e.attr({ role: n, tabIndex: "-1" }), 0 === i.length && (i = e, o && (r = o));
                            i.attr("id", r), e.attr("aria-describedby", r), t.ariaLabel ? s.expect(e, "aria-label", t.ariaLabel) : s.expectAsync(e, "aria-label", function() { if (t.title) return t.title; var e = i.text().split(/\s+/); return 3 < e.length && (e = e.slice(0, 3).concat("...")), e.join(" ") });
                            (v = document.createElement("div")).classList.add("md-dialog-focus-trap"), v.tabIndex = 0, b = v.cloneNode(!1);

                            function a() { e.focus() }
                            v.addEventListener("focus", a), b.addEventListener("focus", a), e[0].parentNode.insertBefore(v, e[0]), e.after(b) }(a, r),
                        function(e, t, n) { n.disableParentScroll && (n.restoreScroll = p.disableScrollAround(t, n.parent));
                            n.hasBackdrop && (n.backdrop = p.createBackdrop(e, "md-dialog-backdrop md-opaque"), i.enter(n.backdrop, n.parent));
                            n.hideBackdrop = function(e) { n.backdrop && (e ? n.backdrop.remove() : i.leave(n.backdrop)), n.disableParentScroll && (n.restoreScroll && n.restoreScroll(), delete n.restoreScroll), n.hideBackdrop = null } }(e, n, r),
                        function(e, t) {
                            function n() { var e = "alert" == t.$type ? m.hide : m.cancel;
                                p.nextTick(e, !0) } var i = se.element(f),
                                o = p.debounce(function() { g(e, t) }, 60),
                                r = []; if (t.escapeToClose) { var a = t.parent,
                                    s = function(e) { e.keyCode === h.KEY_CODE.ESCAPE && (e.stopPropagation(), e.preventDefault(), n()) };
                                e.on("keydown", s), a.on("keydown", s), r.push(function() { e.off("keydown", s), a.off("keydown", s) }) } if (i.on("resize", o), r.push(function() { i.off("resize", o) }), t.clickOutsideToClose) { var l, c = e,
                                    d = function(e) { l = e.target },
                                    u = function(e) { l === c[0] && e.target === c[0] && (e.stopPropagation(), e.preventDefault(), n()) };
                                c.on("mousedown", d), c.on("mouseup", u), r.push(function() { c.off("mousedown", d), c.off("mouseup", u) }) }
                            t.deactivateListeners = function() { r.forEach(function(e) { e() }), t.deactivateListeners = null } }(n, r),
                        function(e, t) { t.parent.append(e), t.reverseContainerStretch = g(e, t); var n = e.find("md-dialog"),
                                i = p.dom.animator,
                                o = i.calculateZoomToOrigin,
                                r = { transitionInClass: "md-transition-in", transitionOutClass: "md-transition-out" },
                                a = i.toTransformCss(o(n, t.openFrom || t.origin)),
                                s = i.toTransformCss(""); return n.toggleClass("md-dialog-fullscreen", !!t.fullscreen), i.translate3d(n, a, s, r).then(function(e) { return t.reverseAnimate = function() { return delete t.reverseAnimate, t.closeTo ? (r = { transitionInClass: "md-transition-out", transitionOutClass: "md-transition-in" }, a = s, s = i.toTransformCss(o(n, t.closeTo)), i.translate3d(n, a, s, r)) : e(s = i.toTransformCss(o(n, t.origin))) }, t.clearAnimate = function() { return delete t.clearAnimate, n.removeClass([r.transitionOutClass, r.transitionInClass].join(" ")), i.translate3d(n, s, i.toTransformCss(""), {}) }, !0 }) }(n, r).then(function() {
                            function i(e) { for (; e.parentNode;) { if (e === document.body) return; for (var t = e.parentNode.children, n = 0; n < t.length; n++) e === t[n] || u(t[n], ["SCRIPT", "STYLE"]) || t[n].hasAttribute("aria-live") || t[n].setAttribute("aria-hidden", o);
                                    i(e = e.parentNode) } } var e, t, o;
                            t = r, o = !0, i((e = n)[0]), t.unlockScreenReader = function() { o = !1, i(e[0]), t.unlockScreenReader = null }, n[0].querySelector(".md-actions") && c.warn("Using a class of md-actions is deprecated, please use <md-dialog-actions>."),
                                function() { if (r.focusOnOpen) {
                                        (p.findFocusTarget(n) || n[0].querySelector(".dialog-close, md-dialog-actions button:last-child") || a).focus() } }() }) }, onShowing: function(e, t, n, i) { if (i) { var o = i.htmlContent || n.htmlContent || "",
                            r = i.textContent || n.textContent || i.content || n.content || ""; if (o && !a.has("$sanitize")) throw Error("The ngSanitize module must be loaded in order to use htmlContent."); if (o && r) throw Error("md-dialog cannot have both `htmlContent` and `textContent`");
                        i.mdHtmlContent = o, i.mdTextContent = r } }, onRemove: function(e, t, n) { n.deactivateListeners(), n.unlockScreenReader(), n.hideBackdrop(n.$destroy), v && v.parentNode && v.parentNode.removeChild(v);
                    b && b.parentNode && b.parentNode.removeChild(b); return n.$destroy ? i() : function(e) { return e.reverseAnimate().then(function() { e.contentElement && e.clearAnimate() }) }(n).then(i);

                    function i() { se.element(l[0].body).removeClass("md-dialog-is-showing"), n.contentElement && n.reverseContainerStretch(), n.cleanupElement(), n.$destroy || "keyboard" !== n.originInteraction || n.origin.focus() } }, clickOutsideToClose: !1, escapeToClose: !0, targetEvent: null, closeTo: null, openFrom: null, focusOnOpen: !0, disableParentScroll: !0, autoWrap: !0, fullscreen: !1, transformTemplate: function(e, t) { var n, i = r.startSymbol(),
                        o = r.endSymbol(); return '<div class="md-dialog-container" tabindex="-1" md-theme="' + (i + (t.themeWatch ? "" : "::") + "theme" + o) + '">' + (n = e, t.autoWrap && !/<\/md-dialog>/g.test(n) ? "<md-dialog>" + (n || "") + "</md-dialog>" : n || "") + "</div>" } };

            function g(e, t) { var n = "fixed" == f.getComputedStyle(l[0].body).position,
                    i = t.backdrop ? f.getComputedStyle(t.backdrop[0]) : null,
                    o = i ? Math.min(l[0].body.clientHeight, Math.ceil(Math.abs(parseInt(i.height, 10)))) : 0,
                    r = { top: e.css("top"), height: e.css("height") },
                    a = Math.abs(t.parent[0].getBoundingClientRect().top); return e.css({ top: (n ? a : 0) + "px", height: o ? o + "px" : "100%" }),
                    function() { e.css(r) } }

            function u(e, t) { if (-1 !== t.indexOf(e.nodeName)) return !0 } } }

    function ae(e) { return { restrict: "E", link: e } }

    function ce(i) { return { restrict: "E", require: ["^?mdFabSpeedDial", "^?mdFabToolbar"], compile: function(e, t) { var n = e.children();
                i.prefixer().hasAttribute(n, "data-ng-repeat") ? n.addClass("md-fab-action-item") : n.wrap('<div class="md-fab-action-item">') } } }

    function de(t, r, a, s, l, n) { var i, c = this,
            e = 0;

        function d(e) { "click" == e.type && function(e) {! function(e) { return s.getClosest(e, "md-fab-trigger") }(e.target) || c.toggle();! function(e) { return s.getClosest(e, "md-fab-actions") }(e.target) || c.close() }(e), "focusout" != e.type || i || (i = n(function() { c.close() }, 100, !1)), "focusin" == e.type && i && (n.cancel(i), i = null) }

        function u() { c.currentActionIndex = -1 }

        function m() { 0 < r[0].scrollHeight ? a.addClass(r, "_md-animations-ready").then(function() { r.removeClass("md-animations-waiting") }) : e < 10 && (n(m, 100), e += 1) }

        function p() { r.off("keydown", f), se.element(document).off("click touchend", h) }

        function h(e) { if (e.target) { var t = s.getClosest(e.target, "md-fab-trigger"),
                    n = s.getClosest(e.target, "md-fab-actions");
                t || n || c.close() } }

        function f(e) { switch (e.which) {
                case l.KEY_CODE.ESCAPE:
                    return c.close(), e.preventDefault(), !1;
                case l.KEY_CODE.LEFT_ARROW:
                    return o = e, "left" === c.direction ? v(o) : g(o), !1;
                case l.KEY_CODE.UP_ARROW:
                    return i = e, "down" === c.direction ? g(i) : v(i), !1;
                case l.KEY_CODE.RIGHT_ARROW:
                    return n = e, "left" === c.direction ? g(n) : v(n), !1;
                case l.KEY_CODE.DOWN_ARROW:
                    return t = e, "up" === c.direction ? g(t) : v(t), !1 } var t, n, i, o }

        function g(e) { o(e, -1) }

        function v(e) { o(e, 1) }

        function o(e, t) { var n, i = (n = b()[0].querySelectorAll(".md-fab-action-item"), se.forEach(n, function(e) { se.element(se.element(e).children()[0]).attr("tabindex", -1) }), n);
            c.currentActionIndex = c.currentActionIndex + t, c.currentActionIndex = Math.min(i.length - 1, c.currentActionIndex), c.currentActionIndex = Math.max(0, c.currentActionIndex); var o = se.element(i[c.currentActionIndex]).children()[0];
            se.element(o).attr("tabindex", 0), o.focus(), e.preventDefault(), e.stopImmediatePropagation() }

        function b() { return r.find("md-fab-actions") }
        c.open = function() { t.$evalAsync("vm.isOpen = true") }, c.close = function() { t.$evalAsync("vm.isOpen = false"), r.find("md-fab-trigger")[0].focus() }, c.toggle = function() { t.$evalAsync("vm.isOpen = !vm.isOpen") }, c.$onInit = function() { var e, i, o;
            c.direction = c.direction || "down", c.isOpen = c.isOpen || !1, u(), r.addClass("md-animations-waiting"), e = ["click", "focusin", "focusout"], se.forEach(e, function(e) { r.on(e, d) }), t.$on("$destroy", function() { se.forEach(e, function(e) { r.off(e, d) }), p() }), t.$watch("vm.direction", function(e, t) { a.removeClass(r, "md-" + t), a.addClass(r, "md-" + e), u() }), t.$watch("vm.isOpen", function(e) { u(), i && o || (i = r.find("md-fab-trigger"), o = b()), e ? (r.on("keydown", f), s.nextTick(function() { se.element(document).on("click touchend", h) })) : p(); var t = e ? "md-is-open" : "",
                    n = e ? "" : "md-is-open";
                i.attr("aria-haspopup", !0), i.attr("aria-expanded", e), o.attr("aria-hidden", !e), a.setClass(r, t, n) }), m() }, 1 === se.version.major && se.version.minor <= 4 && this.$onInit() }

    function ue() {
        function i(e, t) { if (t) { var n = e[0],
                    i = e.controller("mdFabToolbar"),
                    o = n.querySelector(".md-fab-toolbar-background"),
                    r = n.querySelector("md-fab-trigger button"),
                    a = n.querySelector("md-toolbar"),
                    s = n.querySelector("md-fab-trigger button md-icon"),
                    l = e.find("md-fab-actions").children(); if (r && o) { var c = j.getComputedStyle(r).getPropertyValue("background-color"),
                        d = n.offsetWidth,
                        u = (n.offsetHeight, d / r.offsetWidth * 2);
                    o.style.backgroundColor = c, o.style.borderRadius = d + "px", i.isOpen ? (a.style.pointerEvents = "inherit", o.style.width = r.offsetWidth + "px", o.style.height = r.offsetHeight + "px", o.style.transform = "scale(" + u + ")", o.style.transitionDelay = "0ms", s && (s.style.transitionDelay = ".3s"), se.forEach(l, function(e, t) { e.style.transitionDelay = 25 * (l.length - t) + "ms" })) : (a.style.pointerEvents = "none", o.style.transform = "scale(1)", o.style.top = "0", e.hasClass("md-right") && (o.style.left = "0", o.style.right = null), e.hasClass("md-left") && (o.style.right = "0", o.style.left = null), o.style.transitionDelay = "200ms", s && (s.style.transitionDelay = "0ms"), se.forEach(l, function(e, t) { e.style.transitionDelay = 200 + 25 * t + "ms" })) } } } return { addClass: function(e, t, n) { i(e, t), n() }, removeClass: function(e, t, n) { i(e, t), n() } } }

    function me(g, v, b, $) { return { restrict: "E", controller: pe, scope: { mdOnLayout: "&" }, link: function(n, r, a, t) { r.addClass("_md"), r.attr("role", "list"), t.layoutDelegate = function(e) { var i = [].filter.call(r.children(), function(e) { return "MD-GRID-TILE" == e.tagName && !e.$$mdDestroyed }),
                        o = { tileSpans: function(e) { return [].map.call(e, function(e) { var t = se.element(e).controller("mdGridTile"); return { row: parseInt($.getResponsiveAttribute(t.$attrs, "md-rowspan"), 10) || 1, col: parseInt($.getResponsiveAttribute(t.$attrs, "md-colspan"), 10) || 1 } }) }(i), colCount: function() { var e = parseInt($.getResponsiveAttribute(a, "md-cols"), 10); if (isNaN(e)) throw "md-grid-list: md-cols attribute was not found, or contained a non-numeric value"; return e }(), rowMode: u(), rowHeight: function() { var e = $.getResponsiveAttribute(a, "md-row-height"); if (!e) throw "md-grid-list: md-row-height attribute was not found"; switch (u()) {
                                    case "fixed":
                                        return f(e);
                                    case "ratio":
                                        var t = e.split(":"); return parseFloat(t[0]) / parseFloat(t[1]);
                                    case "fit":
                                        return 0 } }(), gutter: f($.getResponsiveAttribute(a, "md-gutter") || 1) }; if (!e && se.equals(o, s)) return; var t = b(o.colCount, o.tileSpans, i).map(function(e, n) { return { grid: { element: r, style: function(e, t, n, i, o) { var r = {}; switch (i) {
                                        case "fixed":
                                            r.height = h({ unit: o, span: t, gutter: n }), r.paddingBottom = ""; break;
                                        case "ratio":
                                            var a = m({ share: 1 / o * (1 / e * 100), gutterShare: 1 === e ? 0 : (e - 1) / e, gutter: n });
                                            r.height = "", r.paddingBottom = h({ unit: a, span: t, gutter: n }) } return r }(o.colCount, n, o.gutter, o.rowMode, o.rowHeight) }, tiles: e.map(function(e, t) { return { element: se.element(i[t]), style: function(e, t, n, i, o, r, a) { var s = 1 / n * 100,
                                            l = (n - 1) / n,
                                            c = m({ share: s, gutterShare: l, gutter: o }),
                                            d = "rtl" != document.dir && "rtl" != document.body.dir ? { left: p({ unit: c, offset: e.col, gutter: o }), width: h({ unit: c, span: t.col, gutter: o }), paddingTop: "", marginTop: "", top: "", height: "" } : { right: p({ unit: c, offset: e.col, gutter: o }), width: h({ unit: c, span: t.col, gutter: o }), paddingTop: "", marginTop: "", top: "", height: "" }; switch (r) {
                                            case "fixed":
                                                d.top = p({ unit: a, offset: e.row, gutter: o }), d.height = h({ unit: a, span: t.row, gutter: o }); break;
                                            case "ratio":
                                                var u = m({ share: s / a, gutterShare: l, gutter: o });
                                                d.paddingTop = h({ unit: u, span: t.row, gutter: o }), d.marginTop = p({ unit: u, offset: e.row, gutter: o }); break;
                                            case "fit":
                                                u = m({ share: 1 / i * 100, gutterShare: (i - 1) / i, gutter: o });
                                                d.top = p({ unit: u, offset: e.row, gutter: o }), d.height = h({ unit: u, span: t.row, gutter: o }) } return d }(e.position, e.spans, o.colCount, n, o.gutter, o.rowMode, o.rowHeight) } }) } }).reflow().performance();
                    n.mdOnLayout({ $event: { performance: t } }), s = o }; var s, i = se.bind(t, t.invalidateLayout),
                    o = function() { for (var e in v.MEDIA) $(e), $.getQuery(v.MEDIA[e]).addListener(i); return $.watchResponsiveAttributes(["md-cols", "md-row-height", "md-gutter"], a, l) }();

                function l(e) { null == e ? t.invalidateLayout() : $(e) && t.invalidateLayout() }
                n.$on("$destroy", function() { for (var e in t.layoutDelegate = se.noop, o(), v.MEDIA) $.getQuery(v.MEDIA[e]).removeListener(i) }); var c = g.startSymbol(),
                    d = g.endSymbol();

                function e(e) { return c + e + d } var m = g(e("share") + "% - (" + e("gutter") + " * " + e("gutterShare") + ")"),
                    p = g("calc((" + e("unit") + " + " + e("gutter") + ") * " + e("offset") + ")"),
                    h = g("calc((" + e("unit") + ") * " + e("span") + " + (" + e("span") + " - 1) * " + e("gutter") + ")");

                function u() { var e = $.getResponsiveAttribute(a, "md-row-height"); if (!e) throw "md-grid-list: md-row-height attribute was not found"; return "fit" == e ? "fit" : -1 !== e.indexOf(":") ? "ratio" : "fixed" }

                function f(e) { return /\D$/.test(e) ? e : e + "px" } } } }

    function pe(e) { this.layoutInvalidated = !1, this.tilesInvalidated = !1, this.$timeout_ = e.nextTick, this.layoutDelegate = se.noop }

    function he(s) { var l = t; return e.animateWith = function(e) { l = se.isFunction(e) ? e : t }, e;

        function e(t, n) { var i, u, o, e, r, a; return e = s.time(function() {
                function o() { c++, r(l = 0, s, -1) }

                function r(e, t, n) { for (var i = e; i < e + t; i++) d[i] = Math.max(d[i] + n, 0) }

                function a(e) { var t; for (t = e; t < d.length; t++)
                        if (0 !== d[t]) return t;
                    if (t === d.length) return t } var s, e, l, c, d;
                s = t, e = n, c = l = 0, d = function() { for (var e = [], t = 0; t < s; t++) e.push(0); return e }(), u = { positioning: e.map(function(e, t) { return { spans: e, position: function(e, t) { if (e.col > s) throw "md-grid-list: Tile at position " + t + " has a colspan (" + e.col + ") that exceeds the column count (" + s + ")"; for (var n = 0, i = 0; i - n < e.col;) s <= l ? o() : -1 !== (n = d.indexOf(0, l)) && -1 !== (i = a(n + 1)) ? l = i + 1 : (n = i = 0, o()); return r(n, e.col, e.row), l = n + e.col, { col: n, row: c } }(e, t) } }), rowCount: c + Math.max.Apply(Math, d) } }), i = { layoutInfo: function() { return u }, map: function(t) { return r = s.time(function() { var e = i.layoutInfo();
                        o = t(e.positioning, e.rowCount) }), i }, reflow: function(e) { return a = s.time(function() {
                        (e || l)(o.grid, o.tiles) }), i }, performance: function() { return { tileCount: n.length, layoutTime: e, mapTime: r, reflowTime: a, totalTime: e + r + a } } } }

        function t(e, t) { e.element.css(e.style), t.forEach(function(e) { e.element.css(e.style) }) } }

    function fe(r) { return { restrict: "E", require: "^mdGridList", template: "<figure data-ng-transclude></figure>", transclude: !0, scope: {}, controller: ["$attrs", function(e) { this.$attrs = e }], link: function(e, t, n, i) { t.attr("role", "listitem"); var o = r.watchResponsiveAttributes(["md-colspan", "md-rowspan"], n, se.bind(i, i.invalidateLayout));
                i.invalidateTiles(), e.$on("$destroy", function() { t[0].$$mdDestroyed = !0, o(), i.invalidateLayout() }), se.isDefined(e.$parent.$index) && e.$watch(function() { return e.$parent.$index }, function(e, t) { e !== t && i.invalidateTiles() }) } } }

    function ge() { return { template: "<figcaption data-ng-transclude></figcaption>", transclude: !0 } }

    function ve(t) { return { restrict: "E", compile: function(e) { return e[0].setAttribute("role", "list"), t } } }

    function be(m, p, h, f) { var g = ["md-checkbox", "md-switch", "md-menu"]; return { restrict: "E", controller: "MdListController", compile: function(r, i) { var e, o, t, n = r[0].querySelectorAll(".md-secondary"),
                    a = r; if (r[0].setAttribute("role", "listitem"), i.ngClick || i.ngDblclick || i.ngHref || i.href || i.uiSref || i.ngAttrUiSref) c("button");
                else if (!r.hasClass("md-no-proxy")) { for (var s, l = 0; s = g[l]; ++l)
                        if (o = r[0].querySelector(s)) { e = !0; break }
                    e ? c("div") : r.addClass("md-no-proxy") }

                function c(e) { if ("div" == e)(a = se.element('<div class="md-no-style md-list-item-inner">')).append(r.contents()), r.addClass("md-proxy-focus");
                    else { a = se.element('<div class="md-button md-no-style">   <div class="md-list-item-inner"></div></div>'); var t = se.element('<md-button class="md-no-style"></md-button>');
                        d(r[0], t[0]), t.attr("aria-label") || t.attr("aria-label", m.getText(r)), r.hasClass("md-no-focus") && t.addClass("md-no-focus"), a.prepend(t), a.children().eq(1).append(r.contents()), r.addClass("_md-button-wrap") }
                    r[0].setAttribute("tabindex", "-1"), r.append(a) }

                function d(t, n, e) { var i = h.prefixer(["data-ng-if", "data-ng-click", "data-ng-dblclick", "aria-label", "data-ng-disabled", "ui-sref", "href", "data-ng-href", "rel", "target", "data-ng-attr-ui-sref", "ui-sref-opts"]);
                    e && (i = i.concat(h.prefixer(e))), se.forEach(i, function(e) { t.hasAttribute(e) && (n.setAttribute(e, t.getAttribute(e)), t.removeAttribute(e)) }) }

                function u(e) { for (var t = e.attributes, n = 0; n < t.length; n++)
                        if ("ngClick" === i.$normalize(t[n].name)) return !0;
                    return !1 } return t = se.element('<div class="md-secondary-container">'), se.forEach(n, function(e) {! function(e, t) { if (e && ! function(e) { var t = e.nodeName.toUpperCase(); return "MD-BUTTON" == t || "BUTTON" == t }(e) && e.hasAttribute("data-ng-click")) { m.expect(e, "aria-label"); var n = se.element('<md-button class="md-secondary md-icon-button">');
                                d(e, n[0], ["data-ng-if", "data-ng-hide", "data-ng-show"]), e.setAttribute("tabindex", "-1"), n.append(e), e = n[0] }
                            e && (!u(e) || !i.ngClick && function(e) { return -1 != g.indexOf(e.nodeName.toLowerCase()) }(e)) && se.element(e).removeClass("md-secondary");
                            r.addClass("md-with-secondary"), t.append(e) }(e, t) }), a.append(t),
                    function() { for (var e, t, n = ["md-switch", "md-checkbox"], i = 0; t = n[i]; ++i)
                            if ((e = r.find(t)[0]) && !e.hasAttribute("aria-label")) { var o = r.find("p")[0]; if (!o) return;
                                e.setAttribute("aria-label", "Toggle " + o.textContent) } }(), e && "MD-MENU" === o.nodeName && function() { var e = se.element(o),
                            t = e.parent().hasClass("md-secondary-container") || o.parentNode.firstElementChild !== o,
                            n = "left";
                        t && (n = "right");
                        e.attr("md-position-mode") || e.attr("md-position-mode", n + " target"); var i = e.children().eq(0);
                        u(i[0]) || i.attr("data-ng-click", "$mdMenu.open($event)");
                        i.attr("aria-label") || i.attr("aria-label", "Open List Menu") }(),
                    function(e, o, t, n) { o.addClass("_md"); var i = [],
                            r = o[0].firstElementChild,
                            a = o.hasClass("_md-button-wrap") ? r.firstElementChild : r,
                            s = a && u(a),
                            l = o.hasClass("md-no-proxy");
                        r && r.children && !s && !l && se.forEach(g, function(e) { se.forEach(r.querySelectorAll(e + ":not(.md-secondary)"), function(e) { i.push(e) }) }), 1 != i.length && !s || (o.addClass("md-clickable"), s || n.attachRipple(e, se.element(o[0].querySelector(".md-no-style")))), i.length && se.forEach(i, function(t) { t = se.element(t), e.mouseActive = !1, t.on("mousedown", function() { e.mouseActive = !0, f(function() { e.mouseActive = !1 }, 100) }).on("focus", function() {!1 === e.mouseActive && o.addClass("md-focused"), t.on("blur", function e() { o.removeClass("md-focused"), t.off("blur", e) }) }) });

                        function c(e) { "INPUT" == e.target.nodeName || "TEXTAREA" == e.target.nodeName || e.target.isContentEditable || (e.which || e.keyCode) == p.KEY_CODE.SPACE && a && (a.click(), e.preventDefault(), e.stopPropagation()) }
                        s || i.length || a && a.addEventListener("keypress", c);
                        o.off("click"), o.off("keypress"), 1 == i.length && a && o.children().eq(0).on("click", function(t) {
                            (function(e) { var t = ["md-slider"]; if (!e.path) return -1 !== t.indexOf(e.target.tagName.toLowerCase()); for (var n = e.path.indexOf(o.children()[0]), i = 0; i < n; i++)
                                    if (-1 !== t.indexOf(e.path[i].tagName.toLowerCase())) return !0 })(t) || !h.getClosest(t.target, "BUTTON") && a.contains(t.target) && se.forEach(i, function(e) { t.target === e || e.contains(t.target) || ("MD-MENU" === e.nodeName && (e = e.children[0]), se.element(e).triggerHandler("click")) }) });
                        e.$on("$destroy", function() { a && a.removeEventListener("keypress", c) }) } } } }

    function $e(e, t, n) { this.attachRipple = function(e, t) { n.attach(e, t, {}) } }

    function Ce(o, r) { return { restrict: "E", transclude: !0, controller: ye, controllerAs: "ctrl", bindToController: !0, scope: { mdSelectedNavItem: "=?", mdNoInkBar: "=?", navBarAriaLabel: "@?" }, template: '<div class="md-nav-bar"><nav role="navigation"><ul class="_md-nav-bar-list" data-ng-transclude role="listbox"tabindex="0"data-ng-focus="ctrl.onFocus()"data-ng-keydown="ctrl.onKeydown($event)"aria-label="{{ctrl.navBarAriaLabel}}"></ul></nav><md-nav-ink-bar data-ng-hide="ctrl.mdNoInkBar"></md-nav-ink-bar></div>', link: function(e, t, n, i) { r(t), i.navBarAriaLabel || o.expectAsync(t, "aria-label", se.noop) } } }

    function ye(e, t, n, i) { this._$timeout = n, this._$scope = t, this._$mdConstant = i, this.mdSelectedNavItem, this.navBarAriaLabel, this._navBarEl = e[0], this._inkbar; var o = this,
            r = this._$scope.$watch(function() { return o._navBarEl.querySelectorAll("._md-nav-button").length }, function(e) { 0 < e && (o._initTabs(), r()) }) }

    function xe(a, t) { return { restrict: "E", require: ["mdNavItem", "^mdNavBar"], controller: we, bindToController: !0, controllerAs: "ctrl", replace: !0, transclude: !0, template: function(e, t) { var n, i, o = t.mdNavClick,
                    r = t.mdNavHref,
                    a = t.mdNavSref,
                    s = t.srefOpts; if (1 < (o ? 1 : 0) + (r ? 1 : 0) + (a ? 1 : 0)) throw Error("Must not specify more than one of the md-nav-click, md-nav-href, or md-nav-sref attributes per nav-item directive."); return o ? n = 'data-ng-click="ctrl.mdNavClick()"' : r ? n = 'data-ng-href="{{ctrl.mdNavHref}}"' : a && (n = 'ui-sref="{{ctrl.mdNavSref}}"'), n && (i = '<md-button class="_md-nav-button md-accent" data-ng-class="ctrl.getNgClassMap()" data-ng-blur="ctrl.setFocused(false)" tabindex="-1" ' + (s ? 'ui-sref-opts="{{ctrl.srefOpts}}" ' : "") + n + '><span data-ng-transclude class="_md-nav-button-text"></span></md-button>'), '<li class="md-nav-item" role="option" aria-selected="{{ctrl.isSelected()}}">' + (i || "") + "</li>" }, scope: { mdNavClick: "&?", mdNavHref: "@?", mdNavSref: "@?", srefOpts: "=?", name: "@" }, link: function(i, o, e, r) { t(function() { var e = r[0],
                        t = r[1],
                        n = se.element(o[0].querySelector("._md-nav-button"));
                    e.name || (e.name = se.element(o[0].querySelector("._md-nav-button-text")).text().trim()), n.on("click", function() { t.mdSelectedNavItem = e.name, i.$Apply() }), a.expectWithText(o, "aria-label") }) } } }

    function we(e) { this._$element = e, this.mdNavClick, this.mdNavHref, this.mdNavSref, this.srefOpts, this.name, this._selected = !1, this._focused = !1 }

    function Te(u, m, e) { var p = "determinate",
            h = "indeterminate",
            f = "buffer",
            g = "query",
            v = "_md-progress-linear-disabled"; return { restrict: "E", template: '<div class="md-container"><div class="md-dashed"></div><div class="md-bar md-bar1"></div><div class="md-bar md-bar2"></div></div>', compile: function(e, t, n) { return e.attr("aria-valuemin", 0), e.attr("aria-valuemax", 100), e.attr("role", "progressbar"), i } };

        function i(e, n, t) { var i;
            u(n); var o = t.hasOwnProperty("disabled"),
                r = m.dom.animator.toCss,
                a = se.element(n[0].querySelector(".md-bar1")),
                s = se.element(n[0].querySelector(".md-bar2")),
                l = se.element(n[0].querySelector(".md-container"));

            function c() { var e = (t.mdMode || "").trim(); if (e) switch (e) {
                    case p:
                    case h:
                    case f:
                    case g:
                        break;
                    default:
                        e = h }
                return e }

            function d(e, t) { if (!o && c()) { var n = m.supplant("translateX({0}%) scale({1},1)", [(t - 100) / 2, t / 100]),
                        i = r({ transform: n });
                    se.element(e).css(i) } }
            n.attr("md-mode", c()).toggleClass(v, o),
                function() { if (se.isUndefined(t.mdMode)) { var e = se.isDefined(t.value) ? p : h;
                        n.attr("md-mode", e), t.mdMode = e } }(), t.$observe("value", function(e) { var t = b(e);
                    n.attr("aria-valuenow", t), c() != g && d(s, t) }), t.$observe("mdBufferValue", function(e) { d(a, b(e)) }), t.$observe("disabled", function(e) { o = !0 === e || !1 === e ? !!e : se.isDefined(e), n.toggleClass(v, o), l.toggleClass(i, !o) }), t.$observe("mdMode", function(e) { switch (i && l.removeClass(i), e) {
                        case g:
                        case f:
                        case p:
                        case h:
                            l.addClass(i = "md-mode-" + e); break;
                        default:
                            l.addClass(i = "md-mode-" + h) } }) }

        function b(e) { return Math.max(0, Math.min(e || 0, 100)) } }

    function Ee(s, l, c, d) { return e.prototype = { init: function(e) { this._ngModelCtrl = e, this._ngModelCtrl.$render = se.bind(this, this.render) }, add: function(e) { this._radioButtonRenderFns.push(e) }, remove: function(e) { var t = this._radioButtonRenderFns.indexOf(e); - 1 !== t && this._radioButtonRenderFns.splice(t, 1) }, render: function() { this._radioButtonRenderFns.forEach(function(e) { e() }) }, setViewValue: function(e, t) { this._ngModelCtrl.$setViewValue(e, t), this.render() }, getViewValue: function() { return this._ngModelCtrl.$viewValue }, selectNext: function() { return t(this.$element, 1) }, selectPrevious: function() { return t(this.$element, -1) }, setActiveDescendant: function(e) { this.$element.attr("aria-activedescendant", e) }, isDisabled: function() { return this.$element[0].hasAttribute("disabled") } }, { restrict: "E", controller: ["$element", e], require: ["mdRadioGroup", "?ngModel"], link: { pre: function(t, i, e, n) { i.addClass("_md"), c(i); var o = n[0],
                        r = n[1] || s.fakeNgModel();

                    function a() { i.hasClass("md-focused") || i.addClass("md-focused") }
                    o.init(r), t.mouseActive = !1, i.attr({ role: "radiogroup", tabIndex: i.attr("tabindex") || "0" }).on("keydown", function(e) { var t = e.which || e.keyCode; if (t == l.KEY_CODE.ENTER || e.currentTarget == e.target) switch (t) {
                            case l.KEY_CODE.LEFT_ARROW:
                            case l.KEY_CODE.UP_ARROW:
                                e.preventDefault(), o.selectPrevious(), a(); break;
                            case l.KEY_CODE.RIGHT_ARROW:
                            case l.KEY_CODE.DOWN_ARROW:
                                e.preventDefault(), o.selectNext(), a(); break;
                            case l.KEY_CODE.ENTER:
                                var n = se.element(s.getClosest(i[0], "form"));
                                0 < n.length && n.triggerHandler("submit") } }).on("mousedown", function(e) { t.mouseActive = !0, d(function() { t.mouseActive = !1 }, 100) }).on("focus", function() {!1 === t.mouseActive && o.$element.addClass("md-focused") }).on("blur", function() { o.$element.removeClass("md-focused") }) } } };

        function e(e) { this._radioButtonRenderFns = [], this.$element = e }

        function t(e, t) { var n = s.iterator(e[0].querySelectorAll("md-radio-button"), !0); if (n.count()) { var i = e[0].querySelector("md-radio-button.md-checked"),
                    o = n[t < 0 ? "previous" : "next"](i, function(e) { return !se.element(e).attr("disabled") }) || n.first();
                se.element(o).triggerHandler("click") } } }

    function Ae(l, c, d) { var u = "md-checked"; return { restrict: "E", require: "^mdRadioGroup", transclude: !0, template: '<div class="md-container" data-md-ink-ripple data-md-ink-ripple-checkbox><div class="md-off"></div><div class="md-on"></div></div><div data-ng-transclude class="md-label"></div>', link: function(t, n, i, o) { var r;
                d(n),
                    function(e) { e.attr({ id: i.id || "radio_" + c.nextUid(), role: "radio", "aria-checked": "false" }), l.expectWithText(e, "aria-label") }(n), i.ngValue ? c.nextTick(e, !1) : e();

                function e() { if (!o) throw "RadioButton: No RadioGroupController could be found.";
                    o.add(s), i.$observe("value", s), n.on("click", a).on("$destroy", function() { o.remove(s) }) }

                function a(e) { n[0].hasAttribute("disabled") || o.isDisabled() || t.$Apply(function() { o.setViewValue(i.value, e && e.type) }) }

                function s() { var e = o.getViewValue() == i.value;
                    e !== r && ("md-radio-group" !== n[0].parentNode.nodeName.toLowerCase() && n.parent().toggleClass(u, e), e && o.setActiveDescendant(n.attr("id")), r = e, n.attr("aria-checked", e).toggleClass(u, e)) } } } }

    function Se(l, c) { return ["$mdUtil", "$window", function(a, s) { return { restrict: "A", multiElement: !0, link: function(i, o, t) { var r = i.$on("$md-resize-enable", function() { r(); var e = o[0],
                            n = e.nodeType === s.Node.ELEMENT_NODE ? s.getComputedStyle(e) : {};
                        i.$watch(t[l], function(e) { if (!!e === c) { a.nextTick(function() { i.$broadcast("$md-resize") }); var t = { cachedTransitionStyles: n };
                                a.dom.animator.waitTransitionEnd(o, t).then(function() { i.$broadcast("$md-resize") }) } }) }) } } }] }

    function ke(i, l, c, o) { var d = "SideNav '{0}' is not available! Did you use md-component-id='{0}'?",
            u = { find: function(e, t) { var n = i.get(e); return n || t ? n : (o.error(l.supplant(d, [e || ""])), le) }, waitFor: m }; return function(e, t) { if (se.isUndefined(e)) return u; var n, i, o = !0 === t,
                r = u.find(e, o); return !r && o ? u.waitFor(e) : !r && se.isUndefined(t) ? (n = u, i = e, se.extend({ isLockedOpen: a, isOpen: a, toggle: s, open: s, close: s, onClose: se.noop, then: function(e) { return m(i).then(e || se.noop) } }, n)) : r;

            function a() { return !1 }

            function s() { return c.when(l.supplant(d, [i || ""])) } };

        function m(e) { return i.when(e).catch(o.error) } }

    function Me(i, g, v, b, $, C, e, y, x, w, T, E, A) { return { restrict: "E", scope: { isOpen: "=?mdIsOpen" }, controller: "$mdSidenavController", compile: function(e) { return e.addClass("md-closed").attr("tabIndex", "-1"), t } };

        function t(o, r, e, t) { var a, s, l, c, d = null,
                u = null,
                m = w.when(!0),
                n = y(e.mdIsLockedOpen),
                p = se.element(E);

            function h(e) { return e.keyCode === v.KEY_CODE.ESCAPE ? f(e) : w.when(!0) }

            function f(e) { return e.preventDefault(), t.close() }
            e.mdDisableScrollTarget && ((d = T[0].querySelector(e.mdDisableScrollTarget)) ? d = se.element(d) : x.warn(g.supplant('mdSidenav: couldn\'t find element matching selector "{selector}". Falling back to parent.', { selector: e.mdDisableScrollTarget }))), d = d || r.parent(), e.hasOwnProperty("mdDisableBackdrop") || (s = g.createBackdrop(o, "md-sidenav-backdrop md-opaque data-ng-enter")), r.addClass("_md"), b(r), s && b.inherit(s, r), r.on("$destroy", function() { s && s.remove(), t.destroy() }), o.$on("$destroy", function() { s && s.remove() }), o.$watch(function() { return n(o.$parent, { $media: function(e) { return x.warn("$media is deprecated for is-locked-open. Use $mdMedia instead."), i(e) }, $mdMedia: i }) }, function(e, t) {
                (o.isLockedOpen = e) === t ? r.toggleClass("md-locked-open", !!e) : C[e ? "addClass" : "removeClass"](r, "md-locked-open");
                s && s.toggleClass("md-locked-open", !!e) }), o.$watch("isOpen", function(e) { var t = g.findFocusTarget(r) || g.findFocusTarget(r, "[md-sidenav-focus]") || r,
                    n = r.parent();
                n[e ? "on" : "off"]("keydown", h), s && s[e ? "on" : "off"]("click", f); var i = function(e, t) { var n = r[0],
                        i = e[0].scrollTop; if (t && i) { c = { top: n.style.top, bottom: n.style.bottom, height: n.style.height }; var o = { top: i + "px", bottom: "auto", height: e[0].clientHeight + "px" };
                        r.css(o), s.css(o) } if (!t && c) return function() { n.style.top = c.top, n.style.bottom = c.bottom, n.style.height = c.height, s[0].style.top = null, s[0].style.bottom = null, s[0].style.height = null, c = null } }(n, e);
                e && (u = T[0].activeElement, l = $.getLastInteractionType()); return function(e) { e && !a ? (a = d.css("overflow"), d.css("overflow", "hidden")) : se.isDefined(a) && (d.css("overflow", a), a = le) }(e), m = w.all([e && s ? C.enter(s, n) : s ? C.leave(s) : w.when(!0), C[e ? "removeClass" : "addClass"](r, "md-closed")]).then(function() { o.isOpen && (A(function() { p.triggerHandler("resize") }), t && t.focus()), i && i() }) }), t.$toggleOpen = function(e) { return o.isOpen == e ? w.when(!0) : (o.isOpen && t.onCloseCb && t.onCloseCb(), w(function(t) { o.isOpen = e, g.nextTick(function() { m.then(function(e) {!o.isOpen && u && "keyboard" === l && (u.focus(), u = null), t(e) }) }) })) } } }

    function De(t, e, n, i, o) { var r = this;
        r.isOpen = function() { return !!t.isOpen }, r.isLockedOpen = function() { return !!t.isLockedOpen }, r.onClose = function(e) { return r.onCloseCb = e, r }, r.open = function() { return r.$toggleOpen(!0) }, r.close = function() { return r.$toggleOpen(!1) }, r.toggle = function() { return r.$toggleOpen(!t.isOpen) }, r.$toggleOpen = function(e) { return i.when(t.isOpen = e) }; var a = e.mdComponentId,
            s = a && -1 < a.indexOf(o.startSymbol()),
            l = s ? o(a)(t.$parent) : a;
        r.destroy = n.register(r, l), s && e.$observe("mdComponentId", function(e) { e && e !== r.$$mdHandle && (r.destroy(), r.destroy = n.register(r, e)) }) }

    function Ie(H, z, o, W, V, Y, K, G, X, Q) { return { scope: {}, require: ["?ngModel", "?^mdSliderContainer"], template: '<div class="md-slider-wrapper"><div class="md-slider-content"><div class="md-track-container"><div class="md-track"></div><div class="md-track md-track-fill"></div><div class="md-track-ticks"></div></div><div class="md-thumb-container"><div class="md-thumb"></div><div class="md-focus-thumb"></div><div class="md-focus-ring"></div><div class="md-sign"><span class="md-thumb-text"></span></div><div class="md-disabled-thumb"></div></div></div></div>', compile: function(e, t) { var n = se.element(e[0].getElementsByClassName("md-slider-wrapper")),
                    i = t.tabindex || 0;
                n.attr("tabindex", i), (t.disabled || t.ngDisabled) && n.attr("tabindex", -1); return n.attr("role", "slider"), o.expect(e, "aria-label"), r } };

        function r(o, r, e, t) { Y(r); var n = t[0] || { $setViewValue: function(e) { this.$viewValue = e, this.$viewChangeListeners.forEach(function(e) { e() }) }, $parsers: [], $formatters: [], $viewChangeListeners: [] },
                i = t[1],
                a = (se.element(W.getClosest(r, "_md-slider-container", !0)), e.ngDisabled ? se.bind(null, G(e.ngDisabled), o.$parent) : function() { return r[0].hasAttribute("disabled") }),
                s = se.element(r[0].querySelector(".md-thumb")),
                l = se.element(r[0].querySelector(".md-thumb-text")),
                c = s.parent(),
                d = se.element(r[0].querySelector(".md-track-container")),
                u = se.element(r[0].querySelector(".md-track-fill")),
                m = se.element(r[0].querySelector(".md-track-ticks")),
                p = se.element(r[0].getElementsByClassName("md-slider-wrapper")),
                h = (se.element(r[0].getElementsByClassName("md-slider-content")), W.throttle(I, 5e3)),
                f = se.isDefined(e.mdVertical),
                g = se.isDefined(e.mdDiscrete),
                v = se.isDefined(e.mdInvert);
            se.isDefined(e.min) ? e.$observe("min", A) : A(0), se.isDefined(e.max) ? e.$observe("max", S) : S(100), se.isDefined(e.step) ? e.$observe("step", k) : k(1), se.isDefined(e.round) ? e.$observe("round", M) : M(3);
            se.noop;

            function b() { I(), P() }
            e.ngDisabled && o.$parent.$watch(e.ngDisabled, function() { r.attr("aria-disabled", !!a()) }), K.register(p, "drag", { horizontal: !f }), o.mouseActive = !1, p.on("keydown", function(e) { if (a()) return; var t;
                (f ? e.keyCode === V.KEY_CODE.DOWN_ARROW : e.keyCode === V.KEY_CODE.LEFT_ARROW) ? t = -y: (f ? e.keyCode === V.KEY_CODE.UP_ARROW : e.keyCode === V.KEY_CODE.RIGHT_ARROW) && (t = y);
                (t = v ? -t : t) && ((e.metaKey || e.ctrlKey || e.altKey) && (t *= 4), e.preventDefault(), e.stopPropagation(), o.$evalAsync(function() { O(n.$viewValue + t) })) }).on("mousedown", function() {
                (function() { if (!g || a()) return; if (se.isUndefined(y)) return; if (y <= 0) { var e = "Slider step value must be greater than zero when in discrete mode"; throw X.error(e), new Error(e) } var t = Math.floor((C - $) / y);
                    w || (w = se.element("<canvas>").css("position", "absolute"), m.append(w), T = w[0].getContext("2d")); var n, i = _();!i || i.height || i.width || (I(), i = D);
                    w[0].width = i.width, w[0].height = i.height; for (var o = 0; o <= t; o++) { var r = z.getComputedStyle(m[0]);
                        T.fillStyle = r.color || "black", n = Math.floor((f ? i.height : i.width) * (o / t)), T.fillRect(f ? 0 : n - 1, f ? n - 1 : 0, f ? i.width : 2, f ? 2 : i.height) } })(), o.mouseActive = !0, p.removeClass("md-focused"), Q(function() { o.mouseActive = !1 }, 100) }).on("focus", function() {!1 === o.mouseActive && p.addClass("md-focused") }).on("blur", function() { p.removeClass("md-focused"), r.removeClass("md-active"),
                    function() { if (w && T) { var e = _();
                            T.clearRect(0, 0, e.width, e.height) } }() }).on("$md.pressdown", function(e) { if (a()) return;
                r.addClass("md-active"), r[0].focus(), I(); var t = L(R(U(j(f ? e.pointer.y : e.pointer.x))));
                o.$Apply(function() { O(t), N(q(t)) }) }).on("$md.pressup", function(e) { if (a()) return;
                r.removeClass("md-dragging"); var t = L(R(U(j(f ? e.pointer.y : e.pointer.x))));
                o.$Apply(function() { O(t), P() }) }).on("$md.dragstart", function(e) { if (a()) return;
                F = !0, e.stopPropagation(), r.addClass("md-dragging"), B(e) }).on("$md.drag", function(e) { if (!F) return;
                e.stopPropagation(), B(e) }).on("$md.dragend", function(e) { if (!F) return;
                e.stopPropagation(), F = !1 }), setTimeout(b, 0); var $, C, y, x, w, T, E = H.throttle(b);

            function A(e) { $ = parseFloat(e), r.attr("aria-valuemin", e), b() }

            function S(e) { C = parseFloat(e), r.attr("aria-valuemax", e), b() }

            function k(e) { y = parseFloat(e) }

            function M(e) { x = L(parseInt(e), 0, 6) }
            se.element(z).on("resize", E), o.$on("$destroy", function() { se.element(z).off("resize", E) }), n.$render = P, n.$viewChangeListeners.push(P), n.$formatters.push(L), n.$formatters.push(R); var D = {};

            function I() { D = d[0].getBoundingClientRect() }

            function _() { return h(), D }

            function O(e) { n.$setViewValue(L(R(e))) }

            function P() { isNaN(n.$viewValue) && (n.$viewValue = n.$modelValue), n.$viewValue = L(n.$viewValue); var e = q(n.$viewValue);
                o.modelValue = n.$viewValue, r.attr("aria-valuenow", n.$viewValue), N(e), l.text(n.$viewValue) }

            function L(e, t, n) { if (se.isNumber(e)) return t = se.isNumber(t) ? t : $, n = se.isNumber(n) ? n : C, Math.max(t, Math.min(n, e)) }

            function R(e) { if (se.isNumber(e)) { var t = Math.round((e - $) / y) * y + $; return t = Math.round(t * Math.pow(10, x)) / Math.pow(10, x), i && i.fitInputWidthToTextLength && W.debounce(function() { i.fitInputWidthToTextLength(t.toString().length) }, 100)(), t } }

            function N(e) { var t;
                t = e; var n = 100 * (e = Math.max(0, Math.min(t || 0, 1))) + "%",
                    i = v ? 100 * (1 - e) + "%" : n;
                f ? c.css("bottom", n) : W.bidiProperty(c, "left", "right", n), u.css(f ? "height" : "width", i), r.toggleClass(v ? "md-max" : "md-min", 0 === e), r.toggleClass(v ? "md-min" : "md-max", 1 === e) }
            I(); var F = !1;

            function B(e) { var t, n, i;
                g ? (n = f ? e.pointer.y : e.pointer.x, i = L(R(U(j(n)))), N(j(n)), l.text(i)) : (t = f ? e.pointer.y : e.pointer.x, o.$evalAsync(function() { O(U(j(t))) })) }

            function j(e) { var t = (e - (f ? D.top : D.left)) / (f ? D.height : D.width); return f || "rtl" !== W.bidi() || (t = 1 - t), Math.max(0, Math.min(1, f ? 1 - t : t)) }

            function U(e) { return $ + (v ? 1 - e : e) * (C - $) }

            function q(e) { var t = (e - $) / (C - $); return v ? 1 - t : t } } }

    function _e(f, g, v, b) { var $ = v.checkStickySupport(); return function(e, t, n) { var i, o, r, a = t.controller("mdContent"); if (a)
                if ($) t.css({ position: $, top: 0, "z-index": 2 });
                else { var s = a.$element.data("$$sticky");
                    s || (o = a.$element, r = g.throttle(d), function(e) { var t, n, i = 200;

                        function o() { v.now() - n > i ? (t = !1, e.triggerHandler("$scrollend")) : (e.triggerHandler("$scroll"), g.throttle(o)) }
                        e.on("scroll touchmove", function() { t || (t = !0, g.throttle(o), e.triggerHandler("$scrollstart")), e.triggerHandler("$scroll"), n = +v.now() }) }(o), o.on("$scrollstart", r), o.on("$scroll", function e() { var t = o.prop("scrollTop"),
                            n = (e.prevScrollTop || 0) < t; if (0 !== (e.prevScrollTop = t)) { if (n) { if (i.next && i.next.top <= t) return void m(i.next); if (i.current && i.next && i.next.top - t <= i.next.height) return void h(i.current, t + (i.next.top - i.next.height - t)) } if (!n) { if (i.current && i.prev && t < i.current.top) return void m(i.prev); if (i.next && i.current && t >= i.next.top - i.current.height) return void h(i.current, t + (i.next.top - t - i.current.height)) }
                            i.current && h(i.current, t) } else m(null) }), s = i = { prev: null, current: null, next: null, items: [], add: function(n, e) { e.addClass("md-sticky-clone"); var t = { element: n, clone: e }; return i.items.push(t), v.nextTick(function() { o.prepend(t.clone) }), r(),
                                function() { i.items.forEach(function(e, t) { e.element[0] === n[0] && (i.items.splice(t, 1), e.clone.remove()) }), r() } }, refreshElements: d }, a.$element.data("$$sticky", s)); var l = n || b(t.clone())(e),
                        c = s.add(t, l);
                    e.$on("$destroy", c) }
            function d() { var e;
                i.items.forEach(u), i.items = i.items.sort(function(e, t) { return e.top < t.top ? -1 : 1 }); for (var t = o.prop("scrollTop"), n = i.items.length - 1; 0 <= n; n--)
                    if (t > i.items[n].top) { e = i.items[n]; break }
                m(e) }

            function u(e) { var t = e.element[0]; for (e.top = 0, e.left = 0, e.right = 0; t && t !== o[0];) e.top += t.offsetTop, e.left += t.offsetLeft, t.offsetParent && (e.right += t.offsetParent.offsetWidth - t.offsetWidth - t.offsetLeft), t = t.offsetParent;
                e.height = e.element.prop("offsetHeight"); var n = v.floatingScrollbars() ? "0" : le;
                v.bidi(e.clone, "margin-left", e.left, n), v.bidi(e.clone, "margin-right", n, e.right) }

            function m(e) { if (i.current !== e) { i.current && (h(i.current, null), p(i.current, null)), e && p(e, "active"), i.current = e; var t = i.items.indexOf(e);
                    i.next = i.items[t + 1], i.prev = i.items[t - 1], p(i.next, "next"), p(i.prev, "prev") } }

            function p(e, t) { e && e.state !== t && (e.state && (e.clone.attr("sticky-prev-state", e.state), e.element.attr("sticky-prev-state", e.state)), e.clone.attr("sticky-state", t), e.element.attr("sticky-state", t), e.state = t) }

            function h(e, t) { e && (null === t || t === le ? e.translateY && (e.translateY = null, e.clone.css(f.CSS.TRANSFORM, "")) : (e.translateY = t, v.bidi(e.clone, f.CSS.TRANSFORM, "translate3d(" + e.left + "px," + t + "px,0)", "translateY(" + t + "px)"))) } } }

    function Oe(s, l, c, d, u) { return { restrict: "E", replace: !0, transclude: !0, template: '<div class="md-subheader _md">  <div class="md-subheader-inner">    <div class="md-subheader-content"></div>  </div></div>', link: function(n, i, e, t, o) { c(i), i.addClass("_md"), d.prefixer().removeAttribute(i, "data-ng-repeat"); var r = i[0].outerHTML;

                function a(e) { return se.element(e[0].querySelector(".md-subheader-content")) }
                e.$set("role", "heading"), u.expect(i, "aria-level", "2"), o(n, function(e) { a(i).append(e) }), i.hasClass("md-no-sticky") || o(n, function(e) { var t = l('<div class="md-subheader-wrapper" aria-hidden="true">' + r + "</div>")(n);
                    d.nextTick(function() { a(t).append(e) }), s(n, i, t) }) } } }

    function Pe(e) { t.$inject = ["$parse"]; var r = "md" + e,
            a = "$md." + e.toLowerCase(); return t;

        function t(o) { return { restrict: "A", link: function(t, e, n) { var i = o(n[r]);
                    e.on(a, function(e) { t.$ApplyAsync(function() { i(t, { $event: e }) }) }) } } } }

    function Le(e, u, m, p, h, f, g) { var n = e[0]; return { restrict: "E", priority: m.BEFORE_NG_ARIA, transclude: !0, template: '<div class="md-container"><div class="md-bar"></div><div class="md-thumb-container"><div class="md-thumb" data-md-ink-ripple data-md-ink-ripple-checkbox></div></div></div><div data-ng-transclude class="md-label"></div>', require: ["^?mdInputContainer", "?ngModel", "?^form"], compile: function(e, t) { var d = n.compile(e, t).post; return e.addClass("md-dragging"),
                    function(t, n, e, i) { i[0]; var o = i[1] || u.fakeNgModel(),
                            r = (i[2], null);
                        null != e.disabled ? r = function() { return !0 } : e.ngDisabled && (r = p(e.ngDisabled)); var a, s = se.element(n[0].querySelector(".md-thumb-container")),
                            l = se.element(n[0].querySelector(".md-container")),
                            c = se.element(n[0].querySelector(".md-label"));
                        h(function() { n.removeClass("md-dragging") }), d(t, n, e, i), r && t.$watch(r, function(e) { n.attr("tabindex", e ? -1 : 0) }), e.$observe("mdInvert", function(e) { var t = u.parseAttributeBoolean(e);
                            t ? n.prepend(c) : n.prepend(l), n.toggleClass("md-inverted", t) }), f.register(l, "drag"), l.on("$md.dragstart", function(e) { if (r && r(t)) return;
                            e.stopPropagation(), n.addClass("md-dragging"), a = { width: s.prop("offsetWidth") } }).on("$md.drag", function(e) { if (!a) return;
                            e.stopPropagation(), e.srcEvent && e.srcEvent.preventDefault(); var t = e.pointer.distanceX / a.width,
                                n = o.$viewValue ? 1 + t : t;
                            n = Math.max(0, Math.min(1, n)), s.css(m.CSS.TRANSFORM, "translate3d(" + 100 * n + "%,0,0)"), a.translate = n }).on("$md.dragend", function(e) { if (!a) return;
                            e.stopPropagation(), n.removeClass("md-dragging"), s.css(m.CSS.TRANSFORM, ""), (o.$viewValue ? a.translate < .5 : .5 < a.translate) && function(e) { t.$Apply(function() { o.$setViewValue(e), o.$render() }) }(!o.$viewValue);
                            a = null, t.skipToggle = !0, g(function() { t.skipToggle = !1 }, 1) }) } } } }

    function Re(n) { return { restrict: "E", link: function(e, t) { t.addClass("_md"), e.$on("$destroy", function() { n.destroy() }) } } }

    function Ne(e) { n.$inject = ["$mdToast", "$scope"], o.$inject = ["$animate", "$mdToast", "$mdUtil", "$mdMedia"]; var d, i = "ok";

        function t(e) { d = e } return e("$mdToast").setDefaults({ methods: ["position", "hideDelay", "capsule", "parent", "position", "toastClass"], options: o }).addPreset("simple", { argOption: "textContent", methods: ["textContent", "content", "action", "highlightAction", "highlightClass", "theme", "parent"], options: ["$mdToast", "$mdTheming", function(e, t) { return { template: '<md-toast md-theme="{{ toast.theme }}" data-ng-class="{\'md-capsule\': toast.capsule}">  <div class="md-toast-content">    <span class="md-toast-text" role="alert" aria-relevant="all" aria-atomic="true">      {{ toast.content }}    </span>    <md-button class="md-action" data-ng-if="toast.action" data-ng-click="toast.resolve()"         data-ng-class="highlightClasses">      {{ toast.action }}    </md-button>  </div></md-toast>', controller: n, theme: t.defaultTheme(), controllerAs: "toast", bindToController: !0 } }] }).addMethod("updateTextContent", t).addMethod("updateContent", t);

        function n(t, n) { this.$onInit = function() { var e = this;
                e.highlightAction && (n.highlightClasses = ["md-highlight", e.highlightClass]), n.$watch(function() { return d }, function() { e.content = d }), this.resolve = function() { t.hide(i) } } }

        function o(i, s, l, t) { var c = "$md.swipeleft $md.swiperight $md.swipeup $md.swipedown"; return { onShow: function(e, o, r) { d = r.textContent || r.content; var a = !t("gt-sm");
                    o = l.extractElementByName(o, "md-toast", !0), r.element = o, r.onSwipe = function(e, t) { var n = e.type.replace("$md.", ""),
                            i = n.replace("swipe", ""); "down" === i && -1 != r.position.indexOf("top") && !a || "up" === i && (-1 != r.position.indexOf("bottom") || a) || ("left" === i || "right" === i) && a || (o.addClass("md-" + n), l.nextTick(s.cancel)) }, r.openClass = function(e) { return t("gt-xs") ? "md-toast-open-" + (-1 < e.indexOf("top") ? "top" : "bottom") : "md-toast-open-bottom" }(r.position), o.addClass(r.toastClass), r.parent.addClass(r.openClass), l.hasComputedStyle(r.parent, "position", "static") && r.parent.css("position", "relative");
                    o.on(c, r.onSwipe), o.addClass(a ? "md-bottom" : r.position.split(" ").map(function(e) { return "md-" + e }).join(" ")), r.parent && r.parent.addClass("md-toast-animating"); return i.enter(o, r.parent).then(function() { r.parent && r.parent.removeClass("md-toast-animating") }) }, onRemove: function(e, t, n) { t.off(c, n.onSwipe), n.parent && n.parent.addClass("md-toast-animating");
                    n.openClass && n.parent.removeClass(n.openClass); return (1 == n.$destroy ? t.remove() : i.leave(t)).then(function() { n.parent && n.parent.removeClass("md-toast-animating"), l.hasComputedStyle(n.parent, "position", "static") && n.parent.css("position", "") }) }, toastClass: "", position: "bottom left", themable: !0, hideDelay: 3e3, autoWrap: !0, transformTemplate: function(e, t) { if (t.autoWrap && e && !/md-toast-content/g.test(e)) { var n = document.createElement("md-template");
                        n.innerHTML = e; for (var i = 0; i < n.children.length; i++)
                            if ("MD-TOAST" === n.children[i].nodeName) { var o = se.element('<div class="md-toast-content">');
                                o.append(se.element(n.children[i].childNodes)), n.children[i].appendChild(o[0]) }
                        return n.innerHTML } return e || "" } } } }

    function Fe(f, g, v, e, b) { var $ = se.bind(null, v.supplant, "translate3d(0,{0}px,0)"); return { template: "", restrict: "E", link: function(m, p, h) { p.addClass("_md"), e(p), v.nextTick(function() { p.addClass("_md-toolbar-transitions") }, !1), se.isDefined(h.mdScrollShrink) && function() { var n, i, o = se.noop,
                        r = 0,
                        a = 0,
                        s = h.mdShrinkSpeedFactor || .5,
                        l = f.throttle(t),
                        c = v.debounce(e, 5e3);
                    m.$on("$mdContentLoaded", d), h.$observe("mdScrollShrink", function(e) { var t = p.parent().find("md-content");!i && t.length && d(null, t);!1 === (e = m.$eval(e)) ? o() : o = u() }), h.ngShow && m.$watch(h.ngShow, e);
                    h.ngHide && m.$watch(h.ngHide, e);

                    function d(e, t) { t && p.parent()[0] === t.parent()[0] && (i && i.off("scroll", l), i = t, o = u()) }

                    function t(e) { var t = e ? e.target.scrollTop : a;
                        c(), r = Math.min(n / s, Math.max(0, r + t - a)), p.css(g.CSS.TRANSFORM, $([-r * s])), i.css(g.CSS.TRANSFORM, $([(n - r) * s])), a = t, v.nextTick(function() { var e = p.hasClass("md-whiteframe-z1");
                            e && !r ? b.removeClass(p, "md-whiteframe-z1") : !e && r && b.addClass(p, "md-whiteframe-z1") }) }

                    function u() { return i ? (i.on("scroll", l), i.attr("scroll-shrink", "true"), v.nextTick(e, !1), function() { i.off("scroll", l), i.attr("scroll-shrink", "false"), e() }) : se.noop }

                    function e() { var e = -(n = p.prop("offsetHeight")) * s + "px";
                        i.css({ "margin-top": e, "margin-bottom": e }), t() }
                    m.$on("$destroy", o) }() } } }

    function Be(b, $, C, y, x, w, T, E) { var A = "focus touchstart mouseenter",
            S = "blur touchcancel mouseleave",
            k = { top: { x: T.xPosition.CENTER, y: T.yPosition.ABOVE }, right: { x: T.xPosition.OFFSET_END, y: T.yPosition.CENTER }, bottom: { x: T.xPosition.CENTER, y: T.yPosition.BELOW }, left: { x: T.xPosition.OFFSET_START, y: T.yPosition.CENTER } }; return { restrict: "E", priority: 210, scope: { mdZIndex: "=?mdZIndex", mdDelay: "=?mdDelay", mdVisible: "=?mdVisible", mdAutohide: "=?mdAutohide", mdDirection: "@?mdDirection" }, link: function(a, i, s) { var o, e, r, l, c, d = "md-tooltip-" + w.nextUid(),
                    u = w.getParentWithPointerEvents(i),
                    m = C.throttle(f),
                    p = !1,
                    h = null;

                function t() { a.mdZIndex = a.mdZIndex || 100, a.mdDelay = a.mdDelay || 0, k[a.mdDirection] || (a.mdDirection = "bottom") }

                function n(e) { var t = e || x(i.text().trim())(a.$parent);
                    (u.attr("aria-label") || u.attr("aria-labelledby")) && !u.attr("md-labeled-by-tooltip") || (u.attr("aria-label", t), u.attr("md-labeled-by-tooltip") || u.attr("md-labeled-by-tooltip", d)) }

                function f() { t(), l && l.panelEl && l.panelEl.removeClass(o), o = "md-origin-" + a.mdDirection, e = k[a.mdDirection], r = T.newPanelPosition().relativeTo(u).addPanelPosition(e.x, e.y), l && l.panelEl && (l.panelEl.addClass(o), l.updatePosition(r)) }

                function g(e) { g.queued && g.value === !!e || !g.queued && a.mdVisible === !!e || (g.value = !!e, g.queued || (e ? (g.queued = !0, c = b(function() { a.mdVisible = g.value, g.queued = !1, c = null, a.visibleWatcher || v(a.mdVisible) }, a.mdDelay)) : w.nextTick(function() { a.mdVisible = !1, a.visibleWatcher || v(!1) }))) }

                function v(e) { e ? function() { if (!i[0].textContent.trim()) throw new Error("Text for the tooltip has not been provided. Please include text within the mdTooltip element."); if (!l) { var e = se.element(document.body),
                                t = T.newPanelAnimation().openFrom(u).closeTo(u).withAnimation({ open: "md-show", close: "md-hide" }),
                                n = { id: d, attachTo: e, contentElement: i, propagateContainerEvents: !0, panelClass: "md-tooltip " + o, animation: t, position: r, zIndex: a.mdZIndex, focusOnOpen: !1 };
                            l = T.create(n) }
                        l.open().then(function() { l.panelEl.attr("role", "tooltip") }) }() : l && l.close() }
                t(), n(), i.detach(), f(),
                    function() { if (u[0] && "MutationObserver" in $) { var e = new MutationObserver(function(e) { e.some(function(e) { return "disabled" === e.attributeName && u[0].disabled }) });
                            e.observe(u[0], { attributes: !0 }) }

                        function t() { g(!1) }

                        function n() { h = document.activeElement === u[0] }

                        function i(e) { "focus" === e.type && h ? h = !1 : a.mdVisible || (u.on(S, o), g(!0), "touchstart" === e.type && u.one("touchend", function() { w.nextTick(function() { y.one("touchend", o) }, !1) })) }

                        function o() {
                            ((a.hasOwnProperty("mdAutohide") ? a.mdAutohide : s.hasOwnProperty("mdAutohide")) || p || y[0].activeElement !== u[0]) && (c && (b.cancel(c), g.queued = !1, c = null), u.off(S, o), u.triggerHandler("blur"), g(!1)), p = !1 }

                        function r() { p = !0 }
                        h = !1, E.register("scroll", t, !0), E.register("blur", n), E.register("resize", m), a.$on("$destroy", function() { E.deregister("scroll", t, !0), E.deregister("blur", n), E.deregister("resize", m), u.off(A, i).off(S, o).off("mousedown", r), o(), e && e.disconnect() }), u.on("mousedown", r), u.on(A, i) }(),
                    function() { if (i[0] && "MutationObserver" in $) { var e = new MutationObserver(function(e) { e.forEach(function(e) { "md-visible" !== e.attributeName || a.visibleWatcher || (a.visibleWatcher = a.$watch("mdVisible", v)) }) });
                            e.observe(i[0], { attributes: !0 }), s.hasOwnProperty("mdVisible") && (a.visibleWatcher = a.$watch("mdVisible", v)) } else a.visibleWatcher = a.$watch("mdVisible", v);

                        function t() { a.$destroy() }
                        a.$watch("mdDirection", f), i.one("$destroy", t), u.one("$destroy", t), a.$on("$destroy", function() { g(!1), l && l.destroy(), e && e.disconnect(), i.remove() }), -1 < i.text().indexOf(x.startSymbol()) && a.$watch(function() { return i.text().trim() }, n) }() } } }

    function je(e) { e.addClass("md-truncate") }

    function Ue(r) { return { link: function(e, n, i) { var o = "";
                i.$observe("mdWhiteframe", function(e) {-1 != (e = parseInt(e, 10) || 4) && (24 < e || e < 1) && (r.warn("md-whiteframe attribute value is invalid. It should be a number between 1 and 24", n[0]), e = 4); var t = -1 == e ? "" : "md-whiteframe-" + e + "dp";
                    i.$updateClass(t, o), o = t }) } } }

    function qe(l) { return { controller: "MdAutocompleteCtrl", controllerAs: "$mdAutocompleteCtrl", scope: { inputName: "@mdInputName", inputMinlength: "@mdInputMinlength", inputMaxlength: "@mdInputMaxlength", searchText: "=?mdSearchText", selectedItem: "=?mdSelectedItem", itemsExpr: "@mdItems", itemText: "&mdItemText", placeholder: "@placeholder", noCache: "=?mdNoCache", requireMatch: "=?mdRequireMatch", selectOnMatch: "=?mdSelectOnMatch", matchInsensitive: "=?mdMatchCaseInsensitive", itemChange: "&?mdSelectedItemChange", textChange: "&?mdSearchTextChange", minLength: "=?mdMinLength", delay: "=?mdDelay", autofocus: "=?mdAutofocus", floatingLabel: "@?mdFloatingLabel", autoselect: "=?mdAutoselect", menuClass: "@?mdMenuClass", inputId: "@?mdInputId", escapeOptions: "@?mdEscapeOptions", dropdownItems: "=?mdDropdownItems", dropdownPosition: "@?mdDropdownPosition", clearButton: "=?mdClearButton" }, compile: function(e, n) { var i = e.find("input"); return ["md-select-on-focus", "md-no-asterisk", "data-ng-trim", "data-ng-pattern"].forEach(function(e) { var t = n[n.$normalize(e)];
                        null !== t && i.attr(e, t) }),
                    function(e, t, n, i) { i.hasNotFound = !!t.attr("md-has-not-found"), se.isDefined(n.mdClearButton) || e.floatingLabel || (e.clearButton = !0) } }, template: function(n, e) { var t, i, o = (t = n.find("md-not-found").detach(), (i = t.length ? t.html() : "") ? '<li data-ng-if="$mdAutocompleteCtrl.notFoundVisible()"                         md-autocomplete-parent-scope>' + i + "</li>" : ""),
                    r = function() { var e = n.find("md-item-template").detach(),
                            t = e.length ? e.html() : n.html();
                        e.length || n.empty(); return "<md-autocomplete-parent-scope md-autocomplete-replace>" + t + "</md-autocomplete-parent-scope>" }(),
                    a = n.html(),
                    s = e.tabindex; return o && n.attr("md-has-not-found", !0), n.attr("tabindex", "-1"), "        <md-autocomplete-wrap            data-ng-class=\"{ 'md-whiteframe-z1': !floatingLabel,                         'md-menu-showing': !$mdAutocompleteCtrl.hidden,                         'md-show-clear-button': !!clearButton }\">          " + (e.mdFloatingLabel ? '            <md-input-container data-ng-if="floatingLabel">              <label>{{floatingLabel}}</label>              <input type="text"                  ' + (null != s ? 'tabindex="' + s + '"' : "") + '                  id="{{ inputId || \'fl-input-\' + $mdAutocompleteCtrl.id }}"                  name="{{inputName}}"                  autocomplete="off"                  data-ng-required="$mdAutocompleteCtrl.isRequired"                  data-ng-readonly="$mdAutocompleteCtrl.isReadonly"                  data-ng-minlength="inputMinlength"                  data-ng-maxlength="inputMaxlength"                  data-ng-disabled="$mdAutocompleteCtrl.isDisabled"                  data-ng-model="$mdAutocompleteCtrl.scope.searchText"                  data-ng-model-options="{ allowInvalid: true }"                  data-ng-keydown="$mdAutocompleteCtrl.keydown($event)"                  data-ng-blur="$mdAutocompleteCtrl.blur($event)"                  data-ng-focus="$mdAutocompleteCtrl.focus($event)"                  aria-owns="ul-{{$mdAutocompleteCtrl.id}}"                  aria-label="{{floatingLabel}}"                  aria-autocomplete="list"                  role="combobox"                  aria-haspopup="true"                  aria-activedescendant="true"                  aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>              <div md-autocomplete-parent-scope md-autocomplete-replace>' + a + "</div>            </md-input-container>" : '            <input type="text"                ' + (null != s ? 'tabindex="' + s + '"' : "") + '                id="{{ inputId || \'input-\' + $mdAutocompleteCtrl.id }}"                name="{{inputName}}"                data-ng-if="!floatingLabel"                autocomplete="off"                data-ng-required="$mdAutocompleteCtrl.isRequired"                data-ng-disabled="$mdAutocompleteCtrl.isDisabled"                data-ng-readonly="$mdAutocompleteCtrl.isReadonly"                data-ng-minlength="inputMinlength"                data-ng-maxlength="inputMaxlength"                data-ng-model="$mdAutocompleteCtrl.scope.searchText"                data-ng-keydown="$mdAutocompleteCtrl.keydown($event)"                data-ng-blur="$mdAutocompleteCtrl.blur($event)"                data-ng-focus="$mdAutocompleteCtrl.focus($event)"                placeholder="{{placeholder}}"                aria-owns="ul-{{$mdAutocompleteCtrl.id}}"                aria-label="{{placeholder}}"                aria-autocomplete="list"                role="combobox"                aria-haspopup="true"                aria-activedescendant="true"                aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>') + '          <button type="button" aria-label="Clear Input" tabindex="-1" data-ng-if="clearButton && $mdAutocompleteCtrl.scope.searchText" data-ng-click="$mdAutocompleteCtrl.clear($event)"><md-icon md-svg-src="' + l.mdClose + '"></md-icon></button>          <md-progress-linear              class="' + (e.mdFloatingLabel ? "md-inline" : "") + '"              data-ng-if="$mdAutocompleteCtrl.loadingIsVisible()"              md-mode="indeterminate"></md-progress-linear>          <md-virtual-repeat-container              md-auto-shrink              md-auto-shrink-min="1"              data-ng-mouseenter="$mdAutocompleteCtrl.listEnter()"              data-ng-mouseleave="$mdAutocompleteCtrl.listLeave()"              data-ng-mouseup="$mdAutocompleteCtrl.mouseUp()"              data-ng-hide="$mdAutocompleteCtrl.hidden"              class="md-autocomplete-suggestions-container md-whiteframe-z1"              data-ng-class="{ \'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"              role="presentation">            <ul class="md-autocomplete-suggestions"                data-ng-class="::menuClass"                id="ul-{{$mdAutocompleteCtrl.id}}">              <li md-virtual-repeat="item in $mdAutocompleteCtrl.matches"                  data-ng-class="{ selected: $index === $mdAutocompleteCtrl.index }"                  data-ng-click="$mdAutocompleteCtrl.select($index)"                  md-extra-name="$mdAutocompleteCtrl.itemName">                  ' + r + "                  </li>" + o + "            </ul>          </md-virtual-repeat-container>        </md-autocomplete-wrap>" } } }

    function He(e, c) { return { restrict: "AE", compile: function(e, t, l) { return function(n, t) { var e, i, o = n.$mdAutocompleteCtrl,
                        r = o.parent.$new(),
                        a = o.itemName;

                    function s(e, t) { r[t] = n[e], n.$watch(e, function(e) { c.nextTick(function() { r[t] = e }) }) }
                    s("$index", "$index"), s("item", a), i = e = !1, n.$watch(function() { i || e || (e = !0, n.$$postDigest(function() { i || r.$digest(), e = i = !1 })) }), r.$watch(function() { i = !0 }), l(r, function(e) { t.after(e) }) } }, terminal: !0, transclude: "element" } }

    function ze(e, t, n) { this.$scope = e, this.$element = t, this.$attrs = n, this.regex = null }

    function We(n, i) { return { terminal: !0, controller: "MdHighlightCtrl", compile: function(e, t) { var o = i(t.mdHighlightText),
                    r = n(e.html()); return function(e, t, n, i) { i.init(o, r) } } } }

    function Ve(e, t, n, i, o) { this.$scope = e, this.$element = t, this.$mdConstant = n, this.$timeout = i, this.$mdUtil = o, this.isEditting = !1, this.parentController = le, this.enableChipEdit = !1 }

    function Ye(o) { return { restrict: "A", require: "^mdChips", scope: !1, link: function(t, e, n, i) { e.on("click", function(e) { t.$Apply(function() { i.removeChip(t.$$replacedScope.$index) }) }), o(function() { e.attr({ tabindex: -1, "aria-hidden": !0 }), e.find("button").attr("tabindex", "-1") }) } } }

    function Ke(a) { return { restrict: "EA", terminal: !0, link: function(e, t, n) { var i = e.$parent.$mdChipsCtrl,
                    o = i.parent.$new(!1, i.parent);
                o.$$replacedScope = e, o.$chip = e.$chip, o.$index = e.$index; var r = (o.$mdChipsCtrl = i).$scope.$eval(n.mdChipTransclude);
                t.html(r), a(t.contents())(o) }, scope: !1 } }

    function Ge() { this.selectedItem = null, this.searchText = "" }

    function Xe(e, t) { var s = e('<md-icon md-svg-src="' + t.mdTabsArrow + '"></md-icon>')({})[0]; return { require: ["^^mdCalendar", "^^mdCalendarMonth", "mdCalendarMonthBody"], scope: { offset: "=mdMonthOffset" }, controller: Qe, controllerAs: "mdMonthBodyCtrl", bindToController: !0, link: function(e, t, n, i) { var o = i[0],
                    r = i[1],
                    a = i[2];
                a.calendarCtrl = o, a.monthCtrl = r, a.arrowIcon = s.cloneNode(!0), e.$watch(function() { return a.offset }, function(e) { se.isNumber(e) && a.generateContent() }) } } }

    function Qe(e, t, n) { this.$element = e, this.dateUtil = t, this.dateLocale = n, this.monthCtrl = null, this.calendarCtrl = null, this.offset = null, this.focusAfterAppend = null }

    function Ze(e, t, n) { this.$element = e, this.dateUtil = t, this.dateLocale = n, this.calendarCtrl = null, this.yearCtrl = null, this.offset = null, this.focusAfterAppend = null }

    function Je(o, t, r, a, s, i, e, n, l) { var c, d, u = s.prefixer(),
            m = this;
        this.nestLevel = parseInt(t.mdNestLevel, 10) || 0, this.init = function(e, t) { t = t || {}, c = e, (d = r[0].querySelector(u.buildSelector(["data-ng-click", "data-ng-mouseenter"]))).setAttribute("aria-expanded", "false"), this.isInMenuBar = t.isInMenuBar, this.nestedMenus = s.nodesToArray(c[0].querySelectorAll(".md-nested-menu")), c.on("$mdInterimElementRemove", function() { m.isOpen = !1, s.nextTick(function() { m.onIsOpenChanged(m.isOpen) }) }), s.nextTick(function() { m.onIsOpenChanged(m.isOpen) }); var n = "menu_container_" + s.nextUid();
            c.attr("id", n), se.element(d).attr({ "aria-owns": n, "aria-haspopup": "true" }), a.$on("$destroy", se.bind(this, function() { this.disableHoverListener(), o.destroy() })), c.on("$destroy", function() { o.destroy() }) }; var p, h, f = [];
        this.enableHoverListener = function() { f.push(e.$on("$mdMenuOpen", function(e, t) { c[0].contains(t[0]) && (m.currentlyOpenMenu = t.controller("mdMenu"), m.isAlreadyOpening = !1, m.currentlyOpenMenu.registerContainerProxy(m.triggerContainerProxy.bind(m))) })), f.push(e.$on("$mdMenuClose", function(e, t) { c[0].contains(t[0]) && (m.currentlyOpenMenu = le) })), (h = se.element(s.nodesToArray(c[0].children[0].children))).on("mouseenter", m.handleMenuItemHover), h.on("mouseleave", m.handleMenuItemMouseLeave) }, this.disableHoverListener = function() { for (; f.length;) f.shift()();
            h && h.off("mouseenter", m.handleMenuItemHover), h && h.off("mouseleave", m.handleMenuItemMouseLeave) }, this.handleMenuItemHover = function(e) { if (!m.isAlreadyOpening) { var t = e.target.querySelector("md-menu") || s.getClosest(e.target, "MD-MENU");
                p = i(function() { if (t = t && se.element(t).controller("mdMenu"), m.currentlyOpenMenu && m.currentlyOpenMenu != t) { var e = m.nestLevel + 1;
                        m.currentlyOpenMenu.close(!0, { closeTo: e }), m.isAlreadyOpening = !!t, t && t.open() } else t && !t.isOpen && t.open && (m.isAlreadyOpening = !!t, t && t.open()) }, t ? 100 : 250); var n = e.currentTarget.querySelector(".md-button:not([disabled])");
                n && n.focus() } }, this.handleMenuItemMouseLeave = function() { p && (i.cancel(p), p = le) }, this.open = function(e) { e && e.stopPropagation(), e && e.preventDefault(), m.isOpen || (m.enableHoverListener(), m.isOpen = !0, s.nextTick(function() { m.onIsOpenChanged(m.isOpen) }), (d = d || (e ? e.target : r[0])).setAttribute("aria-expanded", "true"), a.$emit("$mdMenuOpen", r), o.show({ scope: a, mdMenuCtrl: m, nestLevel: m.nestLevel, element: c, target: d, preserveElement: !0, parent: "body" }).finally(function() { d.setAttribute("aria-expanded", "false"), m.disableHoverListener() })) }, this.onIsOpenChanged = function(e) { e ? (c.attr("aria-hidden", "false"), r[0].classList.add("md-open"), se.forEach(m.nestedMenus, function(e) { e.classList.remove("md-open") })) : (c.attr("aria-hidden", "true"), r[0].classList.remove("md-open")), a.$mdMenuIsOpen = m.isOpen }, this.focusMenuContainer = function() { var e = c[0].querySelector(u.buildSelector(["md-menu-focus-target", "md-autofocus"]));
            (e = e || c[0].querySelector(".md-button:not([disabled])")).focus() }, this.registerContainerProxy = function(e) { this.containerProxy = e }, this.triggerContainerProxy = function(e) { this.containerProxy && this.containerProxy(e) }, this.destroy = function() { return m.isOpen ? o.destroy() : n.when(!1) }, this.close = function(e, t) { if (m.isOpen) { m.isOpen = !1, s.nextTick(function() { m.onIsOpenChanged(m.isOpen) }); var n = se.extend({}, t, { skipFocus: e }); if (a.$emit("$mdMenuClose", r, n), o.hide(null, t), !e) { var i = m.restoreFocusTo || r.find("button")[0];
                    i instanceof se.element && (i = i[0]), i && i.focus() } } }, this.positionMode = function() { var e = (t.mdPositionMode || "target").split(" "); return 1 == e.length && e.push(e[0]), { left: e[0], top: e[1] } }, this.offsets = function() { var e = (t.mdOffset || "0 0").split(" ").map(parseFloat); if (2 == e.length) return { left: e[0], top: e[1] }; if (1 == e.length) return { top: e[0], left: e[0] }; throw Error("Invalid offsets specified. Please follow format <x, y> or <n>") }, a.$mdMenu = { open: this.open, close: this.close }, a.$mdOpenMenu = se.bind(this, function() { return l.warn("mdMenu: The $mdOpenMenu method is deprecated. Please use `$mdMenu.open`."), this.open.Apply(this, arguments) }) }

    function et(s) { var l = "Invalid HTML for md-menu: "; return { restrict: "E", require: ["mdMenu", "?^mdMenuBar"], controller: "mdMenuCtrl", scope: !0, compile: function(e) { e.addClass("md-menu"); var t = e.children()[0],
                    n = e.children()[1],
                    i = s.prefixer();
                i.hasAttribute(t, "data-ng-click") || (t = t.querySelector(i.buildSelector(["data-ng-click", "data-ng-mouseenter"])) || t); var o = "MD-BUTTON" === t.nodeName || "BUTTON" === t.nodeName;
                t && o && !t.hasAttribute("type") && t.setAttribute("type", "button"); if (!t) throw Error(l + "Expected the menu to have a trigger element."); if (!n || "MD-MENU-CONTENT" !== n.nodeName) throw Error(l + "Expected the menu to contain a `md-menu-content` element.");
                t && t.setAttribute("aria-haspopup", "true"); var r = e[0].querySelectorAll("md-menu"),
                    a = parseInt(e[0].getAttribute("md-nest-level"), 10) || 0;
                r && se.forEach(s.nodesToArray(r), function(e) { e.hasAttribute("md-position-mode") || e.setAttribute("md-position-mode", "cascade"), e.classList.add("_md-nested-menu"), e.setAttribute("md-nest-level", a + 1) }); return c } };

        function c(e, t, n, i) { var o = i[0],
                r = !!i[1],
                a = se.element('<div class="_md md-open-menu-container md-whiteframe-z2"></div>'),
                s = t.children()[1];
            t.addClass("_md"), s.hasAttribute("role") || s.setAttribute("role", "menu"), a.append(s), t.on("$destroy", function() { a.remove() }), t.append(a), a[0].style.display = "none", o.init(a, { isInMenuBar: r }) } }

    function tt(e) { t.$inject = ["$mdUtil", "$mdTheming", "$mdConstant", "$document", "$window", "$q", "$$rAF", "$animateCss", "$animate", "$log"]; var A = 8; return e("$mdMenu").setDefaults({ methods: ["target"], options: t });

        function t(x, e, l, w, T, i, o, r, c, d) { var E = x.prefixer(),
                u = x.dom.animator; return { parent: "body", onShow: function(a, n, s) {
                    (function() { if (!s.target) throw Error("$mdMenu.show() expected a target to animate from in options.target");
                        se.extend(s, { alreadyOpen: !1, isRemoved: !1, target: se.element(s.target), parent: se.element(s.parent), menuContentEl: se.element(n[0].querySelector("md-menu-content")) }) })(), s.menuContentEl[0] ? e.inherit(s.menuContentEl, s.target) : d.warn("$mdMenu: Menu elements should always contain a `md-menu-content` element,otherwise interactivity features will not work properly.", n); return s.cleanupResizing = function() { var e = function(t, n) { return o.throttle(function() { if (!s.isRemoved) { var e = h(t, n);
                                        t.css(u.toCss(e)) } }) }(n, s); return T.addEventListener("resize", e), T.addEventListener("orientationchange", e),
                                function() { T.removeEventListener("resize", e), T.removeEventListener("orientationchange", e) } }(), s.hideBackdrop = function(e, t) { if (t.nestLevel) return se.noop;
                            t.disableParentScroll && !x.getClosest(t.target, "MD-DIALOG") ? t.restoreScroll = x.disableScrollAround(t.element, t.parent) : t.disableParentScroll = !1;
                            t.hasBackdrop && (t.backdrop = x.createBackdrop(e, "md-menu-backdrop md-click-catcher"), c.enter(t.backdrop, w[0].body)); return function() { t.backdrop && t.backdrop.remove(), t.disableParentScroll && t.restoreScroll() } }(a, s),
                        function() { return s.parent.append(n), n[0].style.display = "", i(function(e) { var t = h(n, s);
                                n.removeClass("md-leave"), r(n, { addClass: "md-active", from: u.toCss(t), to: u.toCss({ transform: "" }) }).start().then(e) }) }().then(function(e) { return s.alreadyOpen = !0, s.cleanupInteraction = function() { if (!s.menuContentEl[0]) return se.noop;
                                s.menuContentEl.on("keydown", o), s.menuContentEl[0].addEventListener("click", r, !0); var e = s.menuContentEl[0].querySelector(E.buildSelector(["md-menu-focus-target", "md-autofocus"])); if (!e)
                                    for (var t = s.menuContentEl[0].children.length, n = 0; n < t; n++) { var i = s.menuContentEl[0].children[n]; if (e = i.querySelector(".md-button:not([disabled])")) break; if (i.firstElementChild && !i.firstElementChild.disabled) { e = i.firstElementChild; break } }
                                return e && e.focus(),
                                    function() { s.menuContentEl.off("keydown", o), s.menuContentEl[0].removeEventListener("click", r, !0) };

                                function o(e) { var t; switch (e.keyCode) {
                                        case l.KEY_CODE.ESCAPE:
                                            s.mdMenuCtrl.close(!1, { closeAll: !0 }), t = !0; break;
                                        case l.KEY_CODE.UP_ARROW:
                                            m(e, s.menuContentEl, s, -1) || s.nestLevel || s.mdMenuCtrl.triggerContainerProxy(e), t = !0; break;
                                        case l.KEY_CODE.DOWN_ARROW:
                                            m(e, s.menuContentEl, s, 1) || s.nestLevel || s.mdMenuCtrl.triggerContainerProxy(e), t = !0; break;
                                        case l.KEY_CODE.LEFT_ARROW:
                                            s.nestLevel ? s.mdMenuCtrl.close() : s.mdMenuCtrl.triggerContainerProxy(e), t = !0; break;
                                        case l.KEY_CODE.RIGHT_ARROW:
                                            var n = x.getClosest(e.target, "MD-MENU");
                                            n && n != s.parent[0] ? e.target.click() : s.mdMenuCtrl.triggerContainerProxy(e), t = !0 }
                                    t && (e.preventDefault(), e.stopImmediatePropagation()) }

                                function r(e) { var t = e.target;
                                    do { if (t == s.menuContentEl[0]) return; if ((i(t, ["data-ng-click", "data-ng-href", "ui-sref"]) || "BUTTON" == t.nodeName || "MD-BUTTON" == t.nodeName) && !i(t, ["md-prevent-menu-close"])) { var n = x.getClosest(t, "MD-MENU");
                                            t.hasAttribute("disabled") || n && n != s.parent[0] || a.$Apply(function() { s.mdMenuCtrl.close(!0, { closeAll: !0 }) }); break } } while (t = t.parentNode);

                                    function i(e, t) { if (!e) return !1; for (var n, i = 0; n = t[i]; ++i)
                                            if (E.hasAttribute(e, n)) return !0;
                                        return !1 } } }(), s.cleanupBackdrop = s.backdrop ? (s.backdrop.on("click", t), function() { s.backdrop.off("click", t) }) : se.noop, n.addClass("md-clickable"), e });

                    function t(e) { e.preventDefault(), e.stopPropagation(), a.$Apply(function() { s.mdMenuCtrl.close(!0, { closeAll: !0 }) }) } }, onRemove: function(e, n, i) { return i.cleanupInteraction(), i.cleanupBackdrop(), i.cleanupResizing(), i.hideBackdrop(), n.removeClass("md-clickable"), !0 === i.$destroy ? t() : function() { return r(n, { addClass: "md-leave" }).start() }().then(t);

                    function t() { var e, t;
                        n.removeClass("md-active"), e = n, (t = i).preserveElement ? a(e).style.display = "none" : a(e).parentNode === a(t.parent) && a(t.parent).removeChild(a(e)), i.alreadyOpen = !1 } }, hasBackdrop: !0, disableParentScroll: !0, skipCompile: !0, preserveScope: !0, multiple: !0, themable: !0 };

            function m(e, t, n, i) { for (var o, r = x.getClosest(e.target, "MD-MENU-ITEM"), a = x.nodesToArray(t[0].children), s = a.indexOf(r) + i; 0 <= s && s < a.length; s += i) { if (o = p(a[s].querySelector(".md-button"))) break } return o }

            function p(e) { if (e && -1 != e.getAttribute("tabindex")) return e.focus(), w[0].activeElement == e }

            function h(e, t) { var n, i = e[0],
                    o = e[0].firstElementChild,
                    r = o.getBoundingClientRect(),
                    a = w[0].body.getBoundingClientRect(),
                    s = T.getComputedStyle(o),
                    l = t.target[0].querySelector(E.buildSelector("md-menu-origin")) || t.target[0],
                    c = l.getBoundingClientRect(),
                    d = { left: a.left + A, top: Math.max(a.top, 0) + A, bottom: Math.max(a.bottom, Math.max(a.top, 0) + a.height) - A, right: a.right - A },
                    u = { top: 0, left: 0, right: 0, bottom: 0 },
                    m = { top: 0, left: 0, right: 0, bottom: 0 },
                    p = t.mdMenuCtrl.positionMode(); "target" != p.top && "target" != p.left && "target-right" != p.left || (n = function() { for (var e = 0; e < o.children.length; ++e)
                        if ("none" != T.getComputedStyle(o.children[e]).display) return o.children[e] }()) && (u = (n = (n = n.firstElementChild || n).querySelector(E.buildSelector("md-menu-align-target")) || n).getBoundingClientRect(), m = { top: parseFloat(i.style.top || 0), left: parseFloat(i.style.left || 0) }); var h = {},
                    f = "top "; switch (p.top) {
                    case "target":
                        h.top = m.top + c.top - u.top; break;
                    case "cascade":
                        h.top = c.top - parseFloat(s.paddingTop) - l.style.top; break;
                    case "bottom":
                        h.top = c.top + c.height; break;
                    default:
                        throw new Error('Invalid target mode "' + p.top + '" specified for md-menu on Y axis.') } var g = "rtl" == x.bidi(); switch (p.left) {
                    case "target":
                        h.left = m.left + c.left - u.left, f += g ? "right" : "left"; break;
                    case "target-left":
                        h.left = c.left, f += "left"; break;
                    case "target-right":
                        h.left = c.right - r.width + (r.right - u.right), f += "right"; break;
                    case "cascade":
                        var v = g ? c.left - r.width < d.left : c.right + r.width < d.right;
                        h.left = v ? c.right - l.style.left : c.left - l.style.left - r.width, f += v ? "left" : "right"; break;
                    case "right":
                        g ? (h.left = c.right - c.width, f += "left") : (h.left = c.right - r.width, f += "right"); break;
                    case "left":
                        g ? (h.left = c.right - r.width, f += "right") : (h.left = c.left, f += "left"); break;
                    default:
                        throw new Error('Invalid target mode "' + p.left + '" specified for md-menu on X axis.') } var b, $ = t.mdMenuCtrl.offsets();
                h.top += $.top, h.left += $.left, (b = h).top = Math.max(Math.min(b.top, d.bottom - i.offsetHeight), d.top), b.left = Math.max(Math.min(b.left, d.right - i.offsetWidth), d.left); var C = Math.round(100 * Math.min(c.width / i.offsetWidth, 1)) / 100,
                    y = Math.round(100 * Math.min(c.height / i.offsetHeight, 1)) / 100; return { top: Math.round(h.top), left: Math.round(h.left), transform: t.alreadyOpen ? le : x.supplant("scale({0},{1})", [C, y]), transformOrigin: f } } }

        function a(e) { return e instanceof se.element && (e = e[0]), e } }

    function nt(n, o) { return { restrict: "E", require: "mdMenuBar", controller: "MenuBarController", compile: function(e, t) { return t.ariaRole || e[0].setAttribute("role", "menubar"), se.forEach(e[0].children, function(e) { if ("MD-MENU" == e.nodeName) { e.hasAttribute("md-position-mode") || (e.setAttribute("md-position-mode", "left bottom"), e.querySelector("button, a, md-button").setAttribute("role", "menuitem")); var t = n.nodesToArray(e.querySelectorAll("md-menu-content"));
                            se.forEach(t, function(e) { e.classList.add("md-menu-bar-menu"), e.classList.add("md-dense"), e.hasAttribute("width") || e.setAttribute("width", 5) }) } }), e.find("md-menu-item").addClass("md-in-menu-bar"),
                    function(e, t, n, i) { t.addClass("_md"), o(e, t), i.init() } } } }

    function it(e, t, n) { this.$element = t, this.$attrs = n, this.$scope = e }

    function ot(d, e, u) { return { controller: "MenuItemController", require: ["mdMenuItem", "?ngModel"], priority: e.BEFORE_NG_ARIA, compile: function(i, e) { var t, n, o = e.type,
                    r = "md-in-menu-bar"; if ("checkbox" != o && "radio" != o || !i.hasClass(r)) c("role", "menuitem", i[0].querySelector("md-button, button, a"));
                else { var a = i[0].textContent,
                        s = se.element('<md-button type="button"></md-button>'),
                        l = '<md-icon md-svg-src="' + u.mdChecked + '"></md-icon>';
                    s.html(a), s.attr("tabindex", "0"), i.html(""), i.append(se.element(l)), i.append(s), i.addClass("md-indent").removeClass(r), c("role", "checkbox" == o ? "menuitemcheckbox" : "menuitemradio", s), t = "data-ng-disabled", n = d.prefixer(t), se.forEach(n, function(e) { if (i[0].hasAttribute(e)) { var t = i[0].getAttribute(e);
                            s[0].setAttribute(e, t), i[0].removeAttribute(e) } }) } return function(e, t, n, i) { var o = i[0],
                        r = i[1];
                    o.init(r) };

                function c(e, t, n) {
                    (n = n || i) instanceof se.element && (n = n[0]), n.hasAttribute(e) || n.setAttribute(e, t) } } } }

    function rt(C, y, m, x, p, e) { var w = C.requestAnimationFrame || C.webkitRequestAnimationFrame || se.noop,
            h = C.cancelAnimationFrame || C.webkitCancelAnimationFrame || C.webkitCancelRequestAnimationFrame || se.noop,
            f = "determinate",
            T = "indeterminate",
            E = "_md-progress-circular-disabled",
            A = "md-mode-indeterminate"; return { restrict: "E", scope: { value: "@", mdDiameter: "@", mdMode: "@" }, template: '<svg xmlns="http://www.w3.org/2000/svg"><path fill="none"/></svg>', compile: function(e, t) { if (e.attr({ "aria-valuemin": 0, "aria-valuemax": 100, role: "progressbar" }), se.isUndefined(t.mdMode)) { var n = t.hasOwnProperty("value") ? f : T;
                    t.$set("mdMode", n) } else t.$set("mdMode", t.mdMode.trim()); return i } };

        function i(g, a, r) { var v, e, t = a[0],
                s = se.element(t.querySelector("svg")),
                b = se.element(t.querySelector("path")),
                n = y.startIndeterminate,
                i = y.endIndeterminate,
                o = 0,
                $ = 0;

            function l(n, e, t, i, o, r) { var a = ++$,
                    s = x.now(),
                    l = e - n,
                    c = D(g.mdDiameter),
                    d = I(c),
                    u = t || y.easeFn,
                    m = i || y.duration,
                    p = -90 * (o || 0),
                    h = r || 100;

                function f(e) { b.attr("stroke-dashoffset", k(c, d, e, h)), b.attr("transform", "rotate(" + p + " " + c / 2 + " " + c / 2 + ")") }
                e === n ? f(e) : v = w(function e() { var t = C.Math.max(0, C.Math.min(x.now() - s, m));
                    f(u(t, n, l, m)), a === $ && t < m && (v = w(e)) }) }

            function c() { l(n, i, y.easeFnIndeterminate, y.durationIndeterminate, o, 75), o = ++o % 4 }

            function d() { e || (e = p(c, y.durationIndeterminate, 0, !1), c(), a.addClass(A).removeAttr("aria-valuenow")) }

            function u() { e && (p.cancel(e), e = null, a.removeClass(A)) }
            m(a), a.toggleClass(E, r.hasOwnProperty("disabled")), g.mdMode === T && d(), g.$on("$destroy", function() { u(), v && h(v) }), g.$watchGroup(["value", "mdMode", function() { var e = t.disabled; return !0 === e || !1 === e ? e : se.isDefined(a.attr("disabled")) }], function(e, t) { var n = e[1],
                    i = e[2]; if (i !== t[2] && a.toggleClass(E, !!i), i) u();
                else if (n !== f && n !== T && (n = T, r.$set("mdMode", n)), n === T) d();
                else { var o = M(e[0]);
                    u(), a.attr("aria-valuenow", o), l(M(t[0]), o) } }), g.$watch("mdDiameter", function(e) { var t = D(e),
                    n = I(t),
                    i = M(g.value),
                    o = t / 2 + "px",
                    r = { width: t + "px", height: t + "px" };
                s[0].setAttribute("viewBox", "0 0 " + t + " " + t), s.css(r).css("transform-origin", o + " " + o + " " + o), a.css(r), b.attr("stroke-width", n), b.attr("stroke-linecap", "square"), g.mdMode == T ? (b.attr("d", S(t, n, !0)), b.attr("stroke-dasharray", (t - n) * C.Math.PI * .75), b.attr("stroke-dashoffset", k(t, n, 1, 75))) : (b.attr("d", S(t, n, !1)), b.attr("stroke-dasharray", (t - n) * C.Math.PI), b.attr("stroke-dashoffset", k(t, n, 0, 100)), l(i, i)) }) }

        function S(e, t, n) { var i = e / 2,
                o = t / 2,
                r = i + "," + o,
                a = i - o; return "M" + r + "A" + a + "," + a + " 0 1 1 " + (o + "," + i) + (n ? "" : "A" + a + "," + a + " 0 0 1 " + r) }

        function k(e, t, n, i) { return (e - t) * C.Math.PI * (3 * (i || 100) / 100 - n / 100) }

        function M(e) { return C.Math.max(0, C.Math.min(e || 0, 100)) }

        function D(e) { var t = y.progressSize; if (e) { var n = parseFloat(e); return e.lastIndexOf("%") === e.length - 1 && (n = n / 100 * t), n } return t }

        function I(e) { return y.strokeWidth / 100 * e } }

    function at(i) { return { restrict: "A", compile: function(e, t) { var n = i(t.mdTabScroll, null, !0); return function(t, e) { e.on("mousewheel", function(e) { t.$Apply(function() { n(t, { $event: e }) }) }) } } } }

    function st(a, l, n, i, o, c, d, r, s, e, t, u) { var m = this,
            p = !1,
            h = (I(), []),
            f = !1,
            g = !1;

        function v(t, e) { var n = r.$normalize("md-" + t);

            function i(e) { m[t] = "false" !== e }
            e && P(t, e), r.hasOwnProperty(n) && i(r[n]), r.$observe(n, i) }

        function b() { f = !0, se.element(n).off("resize", k) }

        function $(e) { var t = I();
            se.element(t.wrapper).toggleClass("md-stretch-tabs", function() { switch (m.stretchTabs) {
                    case "always":
                        return !0;
                    case "never":
                        return !1;
                    default:
                        return !m.shouldPaginate && n.matchMedia("(max-width: 600px)").matches } }()), H() }

        function C(e) { m.shouldCenterTabs = _() }

        function y(t, e) { if (t !== e) { var n = I();
                se.forEach(n.tabs, function(e) { e.style.maxWidth = t + "px" }), se.forEach(n.dummies, function(e) { e.style.maxWidth = t + "px" }), c.nextTick(m.updateInkBarStyles) } }

        function x(e, t) { e !== t && (m.maxTabWidth = N(), m.shouldCenterTabs = _(), c.nextTick(function() { m.maxTabWidth = N(), j(m.selectedIndex) })) }

        function w(e) { l[e ? "removeClass" : "addClass"]("md-no-tab-content") }

        function T(e) { var t = I(),
                n = (m.shouldCenterTabs || W() ? "" : "-") + e + "px";
            n = n.replace("--", ""), se.element(t.paging).css(i.CSS.TRANSFORM, "translate3d(" + n + ", 0, 0)"), a.$broadcast("$mdTabsPaginationChanged") }

        function E(e, t) { e !== t && I().tabs[e] && (j(), B()) }

        function A(e, t) { e !== t && (m.selectedIndex = O(e), m.lastSelectedIndex = t, m.updateInkBarStyles(), q(), j(e), a.$broadcast("$mdTabsChanged"), m.tabs[t] && m.tabs[t].scope.deselect(), m.tabs[e] && m.tabs[e].scope.select()) }

        function S(e, t) { p || (m.focusIndex = m.selectedIndex = e), t && m.noSelectClick || c.nextTick(function() { m.tabs[e].element.triggerHandler("click") }, !1) }

        function k() { m.lastSelectedIndex = m.selectedIndex, m.offsetLeft = z(m.offsetLeft), c.nextTick(function() { m.updateInkBarStyles(), L() }) }

        function M(e) { se.element(I().inkBar).toggleClass("data-ng-hide", e) }

        function D(e) { l.toggleClass("md-dynamic-height", e) }

        function I() { var e = {},
                t = l[0]; return e.wrapper = t.querySelector("md-tabs-wrapper"), e.canvas = e.wrapper.querySelector("md-tabs-canvas"), e.paging = e.canvas.querySelector("md-pagination-wrapper"), e.inkBar = e.paging.querySelector("md-ink-bar"), e.nextButton = t.querySelector("md-next-button"), e.prevButton = t.querySelector("md-prev-button"), e.contents = t.querySelectorAll("md-tabs-content-wrapper > md-tab-content"), e.tabs = e.paging.querySelectorAll("md-tab-item"), e.dummies = e.canvas.querySelectorAll("md-dummy-tab"), e }

        function _() { return m.centerTabs && !m.shouldPaginate }

        function O(e) { if (-1 === e) return -1; var t, n, i = Math.max(m.tabs.length - e, e); for (t = 0; t <= i; t++) { if ((n = m.tabs[e + t]) && !0 !== n.scope.disabled) return n.getIndex(); if ((n = m.tabs[e - t]) && !0 !== n.scope.disabled) return n.getIndex() } return e }

        function P(e, n, i) { Object.defineProperty(m, e, { get: function() { return i }, set: function(e) { var t = i;
                    i = e, n && n(e, t) } }) }

        function L() { m.maxTabWidth = N(), m.shouldPaginate = function() { if (m.noPagination || !g) return !1; var t = l.prop("clientWidth"); return se.forEach(I().tabs, function(e) { t -= e.offsetWidth }), t < 0 }() }

        function R(e) { var t = 0; return se.forEach(e, function(e) { t += Math.max(e.offsetWidth, e.getBoundingClientRect().width) }), Math.ceil(t) }

        function N() { var e = I().canvas.clientWidth; return Math.max(0, Math.min(e - 1, 264)) }

        function F(e, t) { var n, i = t ? "focusIndex" : "selectedIndex",
                o = m[i]; for (n = o + e; m.tabs[n] && m.tabs[n].scope.disabled; n += e);
            n = (o + e + m.tabs.length) % m.tabs.length, m.tabs[n] && (m[i] = n) }

        function B() { m.styleTabItemFocus = "keyboard" === t.getLastInteractionType(), I().tabs[m.focusIndex].focus() }

        function j(e) { var t = I(); if (se.isNumber(e) || (e = m.focusIndex), t.tabs[e] && !m.shouldCenterTabs) { var n = t.tabs[e],
                    i = n.offsetLeft,
                    o = n.offsetWidth + i; if (0 != e)
                    if (W()) { var r = R(Array.prototype.slice.call(t.tabs, 0, e)),
                            a = R(Array.prototype.slice.call(t.tabs, 0, e + 1));
                        m.offsetLeft = Math.min(m.offsetLeft, z(r)), m.offsetLeft = Math.max(m.offsetLeft, z(a - t.canvas.clientWidth)) } else m.offsetLeft = Math.max(m.offsetLeft, z(o - t.canvas.clientWidth + 32)), m.offsetLeft = Math.min(m.offsetLeft, z(i));
                else m.offsetLeft = 0 } }

        function U() { m.selectedIndex = O(m.selectedIndex), m.focusIndex = O(m.focusIndex) }

        function q() { if (!m.dynamicHeight) return l.css("height", ""); if (!m.tabs.length) return h.push(q); var e = I(),
                t = e.contents[m.selectedIndex],
                n = t ? t.offsetHeight : 0,
                i = e.wrapper.offsetHeight,
                o = n + i,
                r = l.prop("clientHeight"); if (r !== o) { "bottom" === l.attr("md-align-tabs") && (r -= i, o -= i, l.attr("md-border-bottom") !== le && ++r), p = !0; var a = { height: r + "px" },
                    s = { height: o + "px" };
                l.css(a), d(l, { from: a, to: s, easing: "cubic-bezier(0.35, 0, 0.25, 1)", duration: .5 }).start().done(function() { l.css({ transition: "none", height: "" }), c.nextTick(function() { l.css("transition", "") }), p = !1 }) } }

        function H() { var e = I(); if (e.tabs[m.selectedIndex]) { if (!m.tabs.length) return h.push(m.updateInkBarStyles); if (!l.prop("offsetParent")) return function e() { e.watcher || (e.watcher = a.$watch(function() { c.nextTick(function() { e.watcher && l.prop("offsetParent") && (e.watcher(), e.watcher = null, k()) }, !1) })) }(); var t = m.selectedIndex,
                    n = e.paging.offsetWidth,
                    i = e.tabs[t],
                    o = i.offsetLeft,
                    r = n - o - i.offsetWidth; if (m.shouldCenterTabs) R(e.tabs) < n && c.nextTick(H, !1);! function() { var e = I(),
                        t = m.selectedIndex,
                        n = m.lastSelectedIndex,
                        i = se.element(e.inkBar); if (!se.isNumber(n)) return;
                    i.toggleClass("md-left", t < n).toggleClass("md-right", n < t) }(), se.element(e.inkBar).css({ left: o + "px", right: r + "px" }) } else se.element(e.inkBar).css({ left: "auto", right: "auto" }) }

        function z(e) { var t = I(); if (!t.tabs.length || !m.shouldPaginate) return 0; var n = t.tabs[t.tabs.length - 1],
                i = n.offsetLeft + n.offsetWidth; return e = W() ? (e = Math.min(t.paging.offsetWidth - t.canvas.clientWidth, e), Math.max(0, e)) : (e = Math.max(0, e), Math.min(i - t.canvas.clientWidth, e)) }

        function W() { return "rtl" == c.bidi() }
        m.$onInit = function() {
            (function(t, e) { var n = r.$normalize("md-" + t);
                e && P(t, e);
                r.$observe(n, function(e) { m[t] = e }) })("stretchTabs", $), P("focusIndex", E, m.selectedIndex || 0), P("offsetLeft", T, 0), P("hasContent", w, !1), P("maxTabWidth", y, N()), P("shouldPaginate", x, !1), v("noInkBar", M), v("dynamicHeight", D), v("noPagination"), v("swipeContent"), v("noDisconnect"), v("autoselect"), v("noSelectClick"), v("centerTabs", C), v("enableDisconnect"), m.scope = a, m.parent = a.$parent, m.tabs = [], m.lastSelectedIndex = null, m.hasFocus = !1, m.styleTabItemFocus = !1, m.shouldCenterTabs = _(), m.tabContentPrefix = "tab-content-", m.selectedIndex = m.selectedIndex || 0,
                function() { var e = r.$mdTabsTemplate,
                        t = se.element(l[0].querySelector("md-tab-data"));
                    t.html(e), s(t.contents())(m.parent), delete r.$mdTabsTemplate }(), a.$watch("$mdTabsCtrl.selectedIndex", A), se.element(n).on("resize", k), a.$on("$destroy", b), e(l), c.nextTick(function() { I(), q(), j(), H(), m.tabs[m.selectedIndex] && m.tabs[m.selectedIndex].scope.select(), g = !0, L() }) }, m.updatePagination = c.debounce(L, 100), m.redirectFocus = B, m.attachRipple = function(e, t) { var n = I(),
                i = { colorElement: se.element(n.inkBar) };
            o.attach(e, t, i) }, m.insertTab = function(e, t) { var n = g,
                i = { getIndex: function() { return m.tabs.indexOf(o) }, isActive: function() { return this.getIndex() === m.selectedIndex }, isLeft: function() { return this.getIndex() < m.selectedIndex }, isRight: function() { return this.getIndex() > m.selectedIndex }, shouldRender: function() { return !m.noDisconnect || this.isActive() }, hasFocus: function() { return m.styleTabItemFocus && m.hasFocus && this.getIndex() === m.focusIndex }, id: c.nextUid(), hasContent: !(!e.template || !e.template.trim()) },
                o = se.extend(i, e);
            se.isDefined(t) ? m.tabs.splice(t, 0, o) : m.tabs.push(o); return function() { h.forEach(function(e) { c.nextTick(e) }), h = [] }(),
                function() { for (var e = !1, t = 0; t < m.tabs.length; t++)
                        if (m.tabs[t].hasContent) { e = !0; break }
                    m.hasContent = e }(), c.nextTick(function() { L(),
                        function(e) { if (e.hasContent) { var t = l[0].querySelectorAll('[md-tab-id="' + e.id + '"]');
                                se.element(t).attr("aria-controls", m.tabContentPrefix + e.id) } }(o), n && m.autoselect && c.nextTick(function() { c.nextTick(function() { S(m.tabs.indexOf(o)) }) }) }), o }, m.removeTab = function(e) { if (f) return; var t = m.selectedIndex,
                n = m.tabs.splice(e.getIndex(), 1)[0];
            U(), m.selectedIndex === t && (n.scope.deselect(), m.tabs[m.selectedIndex] && m.tabs[m.selectedIndex].scope.select());
            c.nextTick(function() { L(), m.offsetLeft = z(m.offsetLeft) }) }, m.select = S, m.scroll = function(e) { if (!m.shouldPaginate) return;
            e.preventDefault(), m.offsetLeft = z(m.offsetLeft - e.wheelDelta) }, m.nextPage = function() { if (!m.canPageForward()) return; var e = u.increasePageOffset(I(), m.offsetLeft);
            m.offsetLeft = z(e) }, m.previousPage = function() { if (!m.canPageBack()) return; var e = u.decreasePageOffset(I(), m.offsetLeft);
            m.offsetLeft = z(e) }, m.keydown = function(e) { switch (e.keyCode) {
                case i.KEY_CODE.LEFT_ARROW:
                    e.preventDefault(), F(-1, !0); break;
                case i.KEY_CODE.RIGHT_ARROW:
                    e.preventDefault(), F(1, !0); break;
                case i.KEY_CODE.SPACE:
                case i.KEY_CODE.ENTER:
                    e.preventDefault(), p || S(m.focusIndex); break;
                case i.KEY_CODE.TAB:
                    m.focusIndex !== m.selectedIndex && (m.focusIndex = m.selectedIndex) } }, m.canPageForward = function() { var e = I(),
                t = e.tabs[e.tabs.length - 1]; if (W()) return m.offsetLeft < e.paging.offsetWidth - e.canvas.offsetWidth; return t && t.offsetLeft + t.offsetWidth > e.canvas.clientWidth + m.offsetLeft }, m.canPageBack = function() { return 0 < m.offsetLeft }, m.refreshIndex = U, m.incrementIndex = F, m.getTabElementIndex = function(e) { var t = l[0].getElementsByTagName("md-tab"); return Array.prototype.indexOf.call(t, e[0]) }, m.updateInkBarStyles = c.debounce(H, 100), m.updateTabOrder = c.debounce(function() { var e = m.tabs[m.selectedIndex],
                t = m.tabs[m.focusIndex];
            m.tabs = m.tabs.sort(function(e, t) { return e.index - t.index }), m.selectedIndex = m.tabs.indexOf(e), m.focusIndex = m.tabs.indexOf(t) }, 100), m.getFocusedTabId = function() { var e = m.tabs[m.focusIndex]; return e && e.id ? "tab-item-" + e.id : null }, 1 === se.version.major && se.version.minor <= 4 && this.$onInit() }

    function lt(n) { return { scope: { selectedIndex: "=?mdSelected" }, template: function(e, t) { return t.$mdTabsTemplate = e.html(), '<md-tabs-wrapper> <md-tab-data></md-tab-data> <md-prev-button tabindex="-1" role="button" aria-label="Previous Page" aria-disabled="{{!$mdTabsCtrl.canPageBack()}}" data-ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageBack() }" data-ng-if="$mdTabsCtrl.shouldPaginate" data-ng-click="$mdTabsCtrl.previousPage()"> <md-icon md-svg-src="' + n.mdTabsArrow + '"></md-icon> </md-prev-button> <md-next-button tabindex="-1" role="button" aria-label="Next Page" aria-disabled="{{!$mdTabsCtrl.canPageForward()}}" data-ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageForward() }" data-ng-if="$mdTabsCtrl.shouldPaginate" data-ng-click="$mdTabsCtrl.nextPage()"> <md-icon md-svg-src="' + n.mdTabsArrow + '"></md-icon> </md-next-button> <md-tabs-canvas data-ng-focus="$mdTabsCtrl.redirectFocus()" data-ng-class="{ \'md-paginated\': $mdTabsCtrl.shouldPaginate, \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" data-ng-keydown="$mdTabsCtrl.keydown($event)"> <md-pagination-wrapper data-ng-class="{ \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" md-tab-scroll="$mdTabsCtrl.scroll($event)" role="tablist"> <md-tab-item tabindex="{{ tab.isActive() ? 0 : -1 }}" class="md-tab" data-ng-repeat="tab in $mdTabsCtrl.tabs" role="tab" id="tab-item-{{::tab.id}}" md-tab-id="{{::tab.id}}"aria-selected="{{tab.isActive()}}" aria-disabled="{{tab.scope.disabled || \'false\'}}" data-ng-click="$mdTabsCtrl.select(tab.getIndex())" data-ng-focus="$mdTabsCtrl.hasFocus = true" data-ng-blur="$mdTabsCtrl.hasFocus = false" data-ng-class="{ \'md-active\':    tab.isActive(), \'md-focused\':   tab.hasFocus(), \'md-disabled\':  tab.scope.disabled }" data-ng-disabled="tab.scope.disabled" md-swipe-left="$mdTabsCtrl.nextPage()" md-swipe-right="$mdTabsCtrl.previousPage()" md-tabs-template="::tab.label" md-scope="::tab.parent"></md-tab-item> <md-ink-bar></md-ink-bar> </md-pagination-wrapper> <md-tabs-dummy-wrapper aria-hidden="true" class="md-visually-hidden md-dummy-wrapper"> <md-dummy-tab class="md-tab" tabindex="-1" data-ng-repeat="tab in $mdTabsCtrl.tabs" md-tabs-template="::tab.label" md-scope="::tab.parent"></md-dummy-tab> </md-tabs-dummy-wrapper> </md-tabs-canvas> </md-tabs-wrapper> <md-tabs-content-wrapper data-ng-show="$mdTabsCtrl.hasContent && $mdTabsCtrl.selectedIndex >= 0" class="_md"> <md-tab-content id="{{:: $mdTabsCtrl.tabContentPrefix + tab.id}}" class="_md" role="tabpanel" aria-labelledby="tab-item-{{::tab.id}}" md-swipe-left="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(1)" md-swipe-right="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(-1)" data-ng-if="tab.hasContent" data-ng-repeat="(index, tab) in $mdTabsCtrl.tabs" data-ng-class="{ \'md-no-transition\': $mdTabsCtrl.lastSelectedIndex == null, \'md-active\':        tab.isActive(), \'md-left\':          tab.isLeft(), \'md-right\':         tab.isRight(), \'md-no-scroll\':     $mdTabsCtrl.dynamicHeight }"> <div md-tabs-template="::tab.template" md-connected-if="tab.isActive()" md-scope="::tab.parent" data-ng-if="$mdTabsCtrl.enableDisconnect || tab.shouldRender()"></div> </md-tab-content> </md-tabs-content-wrapper>' }, controller: "MdTabsController", controllerAs: "$mdTabsCtrl", bindToController: !0 } }

    function ct(l, c) { return { require: "^?mdTabs", link: function(e, t, n, i) { if (i) { var o, r, a = function() { i.updatePagination(), i.updateInkBarStyles() }; if ("MutationObserver" in c) {
                        (o = new MutationObserver(a)).observe(t[0], { childList: !0, subtree: !0, characterData: !0 }), r = o.disconnect.bind(o) } else { var s = l.debounce(a, 15, null, !1);
                        t.on("DOMSubtreeModified", s), r = t.off.bind(t, "DOMSubtreeModified", s) }
                    e.$on("$destroy", function() { r() }) } } } }

    function dt(a, s) { return { restrict: "A", link: function(e, t, n, i) { if (!i) return; var o = i.enableDisconnect ? e.compileScope.$new() : e.compileScope; return t.html(e.template), a(t.contents())(o), s.nextTick(function() { e.$watch("connected", function(e) {!1 === e ? i.enableDisconnect && s.disconnectScope(o) : r() }), e.$on("$destroy", r) });

                function r() { i.enableDisconnect && s.reconnectScope(o) } }, scope: { template: "=mdTabsTemplate", connected: "=?mdConnectedIf", compileScope: "=mdScope" }, require: "^?mdTabs" } }
    se.module("ngMaterial", ["ng", "ngAnimate", "ngAria", "material.core", "material.core.gestures", "material.core.interaction", "material.core.layout", "material.core.meta", "material.core.theming.palette", "material.core.theming", "material.core.animate", "material.components.autocomplete", "material.components.backdrop", "material.components.bottomSheet", "material.components.button", "material.components.card", "material.components.checkbox", "material.components.chips", "material.components.colors", "material.components.content", "material.components.datepicker", "material.components.dialog", "material.components.divider", "material.components.fabActions", "material.components.fabShared", "material.components.fabSpeedDial", "material.components.fabToolbar", "material.components.gridList", "material.components.icon", "material.components.input", "material.components.list", "material.components.menu", "material.components.menuBar", "material.components.navBar", "material.components.panel", "material.components.progressCircular", "material.components.progressLinear", "material.components.radioButton", "material.components.select", "material.components.showHide", "material.components.sidenav", "material.components.slider", "material.components.sticky", "material.components.subheader", "material.components.swipe", "material.components.switch", "material.components.tabs", "material.components.toast", "material.components.toolbar", "material.components.tooltip", "material.components.truncate", "material.components.virtualRepeat", "material.components.whiteframe"]), e.$inject = ["$log", "$injector"], t.$inject = ["$provide", "$mdThemingProvider"], n.$inject = ["$delegate"], i.$inject = ["$delegate"], se.module("material.core", ["ngAnimate", "material.core.animate", "material.core.layout", "material.core.interaction", "material.core.gestures", "material.core.theming"]).config(t).run(e), o.$inject = ["$parse"], se.module("material.core").directive("mdAutofocus", o).directive("mdAutoFocus", o).directive("mdSidenavFocus", o), se.module("material.core").factory("$mdColorUtil", function() { return { rgbaToHex: function(e) { return ((e = e.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === e.length ? "#" + ("0" + parseInt(e[1], 10).toString(16)).slice(-2) + ("0" + parseInt(e[2], 10).toString(16)).slice(-2) + ("0" + parseInt(e[3], 10).toString(16)).slice(-2) : "").toUpperCase() }, hexToRgba: function(e) { var t = "#" === e[0] ? e.substr(1) : e,
                        n = t.length / 3,
                        i = t.substr(0, n),
                        o = t.substr(n, n),
                        r = t.substr(2 * n); return 1 == n && (i += i, o += o, r += r), "rgba(" + parseInt(i, 16) + "," + parseInt(o, 16) + "," + parseInt(r, 16) + ",0.1)" }, rgbToRgba: function(e) { return e.replace(")", ", 0.1)").replace("(", "a(") }, rgbaToRgb: function(e) { return e ? e.replace("rgba", "rgb").replace(/,[^\),]+\)/, ")") : "rgb(0,0,0)" } } }), se.module("material.core").factory("$mdConstant", function() { var i = document.createElement("div"),
                o = function(e) { var t, n, i = /^(Moz|webkit|ms)(?=[A-Z])/; for (t in e.style)
                        if (n = i.exec(t)) return n[0] }(i),
                e = /webkit/i.test(o),
                r = /([:\-_]+(.))/g;

            function t(e) { var t = (o + "-" + e).replace(r, function(e, t, n, i) { return i ? n.toUpperCase() : n }),
                    n = t.charAt(0).toLowerCase() + t.substring(1); return a(i, e) ? e : a(i, t) ? t : a(i, n) ? n : e }

            function a(e, t) { return se.isDefined(e.style[t]) } var n = { isInputKey: function(e) { return 31 <= e.keyCode && e.keyCode <= 90 }, isNumPadKey: function(e) { return 3 === e.location && 97 <= e.keyCode && e.keyCode <= 105 }, isMetaKey: function(e) { return 91 <= e.keyCode && e.keyCode <= 93 }, isFnLockKey: function(e) { return 112 <= e.keyCode && e.keyCode <= 145 }, isNavigationKey: function(e) { var t = n.KEY_CODE; return -1 != [t.SPACE, t.ENTER, t.UP_ARROW, t.DOWN_ARROW].indexOf(e.keyCode) }, hasModifierKey: function(e) { return e.ctrlKey || e.metaKey || e.altKey }, ELEMENT_MAX_PIXELS: 1533917, BEFORE_NG_ARIA: 210, KEY_CODE: { COMMA: 188, SEMICOLON: 186, ENTER: 13, ESCAPE: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT_ARROW: 37, UP_ARROW: 38, RIGHT_ARROW: 39, DOWN_ARROW: 40, TAB: 9, BACKSPACE: 8, DELETE: 46 }, CSS: { TRANSITIONEND: "transitionend" + (e ? " webkitTransitionEnd" : ""), ANIMATIONEND: "animationend" + (e ? " webkitAnimationEnd" : ""), TRANSFORM: t("transform"), TRANSFORM_ORIGIN: t("transformOrigin"), TRANSITION: t("transition"), TRANSITION_DURATION: t("transitionDuration"), ANIMATION_PLAY_STATE: t("animationPlayState"), ANIMATION_DURATION: t("animationDuration"), ANIMATION_NAME: t("animationName"), ANIMATION_TIMING: t("animationTimingFunction"), ANIMATION_DIRECTION: t("animationDirection") }, MEDIA: { xs: "(max-width: 599px)", "gt-xs": "(min-width: 600px)", sm: "(min-width: 600px) and (max-width: 959px)", "gt-sm": "(min-width: 960px)", md: "(min-width: 960px) and (max-width: 1279px)", "gt-md": "(min-width: 1280px)", lg: "(min-width: 1280px) and (max-width: 1919px)", "gt-lg": "(min-width: 1920px)", xl: "(min-width: 1920px)", landscape: "(orientation: landscape)", portrait: "(orientation: portrait)", print: "print" }, MEDIA_PRIORITY: ["xl", "gt-lg", "lg", "gt-md", "md", "gt-sm", "sm", "gt-xs", "xs", "landscape", "portrait", "print"] }; return n }), se.module("material.core").config(["$provide", function(e) { e.decorator("$mdUtil", ["$delegate", function(e) { return e.iterator = r, e }]) }]), a.$inject = ["$mdConstant", "$rootScope", "$window"], se.module("material.core").factory("$mdMedia", a), se.module("material.core").config(["$provide", function(e) { e.decorator("$mdUtil", ["$delegate", function(e) { return e.prefixer = s, e }]) }]),
        function() { e.$inject = ["$document", "$timeout", "$compile", "$rootScope", "$$mdAnimate", "$interpolate", "$log", "$rootElement", "$window", "$$rAF"]; var v = 0;

            function e(l, s, n, a, e, t, r, i, c, u) {
                function o(e, t, n) { var i = !1; if (e && e.length) { var o = c.getComputedStyle(e[0]);
                        i = se.isDefined(o[t]) && (!n || o[t] == n) } return i } var d = t.startSymbol(),
                    m = t.endSymbol(),
                    p = "{{" === d && "}}" === m;

                function h(e) { return e ? -1 < String(e).indexOf("px") || -1 < String(e).indexOf("%") ? e : e + "px" : "0" } var f = { dom: {}, now: j.performance && j.performance.now ? se.bind(j.performance, j.performance.now) : Date.now || function() { return (new Date).getTime() }, getModelOption: function(e, t) { if (e.$options) { var n = e.$options; return n.getOption ? n.getOption(t) : n[t] } }, bidi: function(e, t, n, i) { var o = !("rtl" == l[0].dir || "rtl" == l[0].body.dir); if (0 == arguments.length) return o ? "ltr" : "rtl"; var r = se.element(e);
                        o && se.isDefined(n) ? r.css(t, h(n)) : !o && se.isDefined(i) && r.css(t, h(i)) }, bidiProperty: function(e, t, n, i) { var o = !("rtl" == l[0].dir || "rtl" == l[0].body.dir),
                            r = se.element(e);
                        o && se.isDefined(t) ? (r.css(t, h(i)), r.css(n, "")) : !o && se.isDefined(n) && (r.css(n, h(i)), r.css(t, "")) }, clientRect: function(e, t, n) { var i = g(e);
                        t = g(t || i.offsetParent || document.body); var o = i.getBoundingClientRect(),
                            r = n ? t.getBoundingClientRect() : { left: 0, top: 0, width: 0, height: 0 }; return { left: o.left - r.left, top: o.top - r.top, width: o.width, height: o.height } }, offsetRect: function(e, t) { return f.clientRect(e, t, !0) }, nodesToArray: function(e) { e = e || []; for (var t = [], n = 0; n < e.length; ++n) t.push(e.item(n)); return t }, getViewportTop: function() { return j.scrollY || j.pageYOffset || 0 }, findFocusTarget: function(e, t) { var n, i = this.prefixer("md-autofocus", !0); return (n = o(e, t || i)) || t == i || (n = (n = o(e, this.prefixer("md-auto-focus", !0))) || o(e, i)), n;

                        function o(e, t) { var n, i = e[0].querySelectorAll(t); return i && i.length && i.length && se.forEach(i, function(e) {
                                (e = se.element(e)).hasClass("md-autofocus") && (n = e) }), n } }, disableScrollAround: function(e, t, i) { if (i = i || {}, f.disableScrollAround._count = Math.max(0, f.disableScrollAround._count || 0), f.disableScrollAround._count++, f.disableScrollAround._restoreScroll) return f.disableScrollAround._restoreScroll; var s = l[0].body,
                            n = function() { var e = l[0].documentElement,
                                    t = e.style.cssText || "",
                                    n = s.style.cssText || "",
                                    i = f.getViewportTop(),
                                    o = s.clientWidth,
                                    r = s.scrollHeight > s.clientHeight + 1,
                                    a = 0 < e.scrollTop ? e : s;
                                r && se.element(s).css({ position: "fixed", width: "100%", top: -i + "px" });
                                s.clientWidth < o && (s.style.overflow = "hidden");
                                r && (e.style.overflowY = "scroll"); return function() { s.style.cssText = n, e.style.cssText = t, a.scrollTop = i } }(),
                            o = function(e) { var t;
                                e = se.element(e || s), i.disableScrollMask ? t = e : (t = se.element('<div class="md-scroll-mask">  <div class="md-scroll-mask-bar"></div></div>'), e.append(t)); return t.on("wheel", n), t.on("touchmove", n),
                                    function() { t.off("wheel"), t.off("touchmove"), !i.disableScrollMask && t[0].parentNode && t[0].parentNode.removeChild(t[0]) };

                                function n(e) { e.preventDefault() } }(t); return f.disableScrollAround._restoreScroll = function() {--f.disableScrollAround._count <= 0 && (n(), o(), delete f.disableScrollAround._restoreScroll) } }, enableScrolling: function() { var e = this.disableScrollAround._restoreScroll;
                        e && e() }, floatingScrollbars: function() { if (this.floatingScrollbars.cached === le) { var e = se.element("<div><div></div></div>").css({ width: "100%", "z-index": -1, position: "absolute", height: "35px", "overflow-y": "scroll" });
                            e.children().css("height", "60px"), l[0].body.appendChild(e[0]), this.floatingScrollbars.cached = e[0].offsetWidth == e[0].childNodes[0].offsetWidth, e.remove() } return this.floatingScrollbars.cached }, forceFocus: function(e) { var n = e[0] || e;
                        document.addEventListener("click", function e(t) { t.target === n && t.$focus && (n.focus(), t.stopImmediatePropagation(), t.preventDefault(), n.removeEventListener("click", e)) }, !0); var t = document.createEvent("MouseEvents");
                        t.initMouseEvent("click", !1, !0, j, {}, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), t.$material = !0, t.$focus = !0, n.dispatchEvent(t) }, createBackdrop: function(e, t) { return n(f.supplant('<md-backdrop class="{0}">', [t]))(e) }, supplant: function(e, r, t) { return t = t || /\{([^\{\}]*)\}/g, e.replace(t, function(t, e) { var n = e.split("."),
                                i = r; try { for (var o in n) n.hasOwnProperty(o) && (i = i[n[o]]) } catch (e) { i = t } return "string" == typeof i || "number" == typeof i ? i : t }) }, fakeNgModel: function() { return { $fake: !0, $setTouched: se.noop, $setViewValue: function(e) { this.$viewValue = e, this.$render(e), this.$viewChangeListeners.forEach(function(e) { e() }) }, $isEmpty: function(e) { return 0 === ("" + e).length }, $parsers: [], $formatters: [], $viewChangeListeners: [], $render: se.noop } }, debounce: function(n, i, o, r) { var a; return function() { var e = o,
                                t = Array.prototype.slice.call(arguments);
                            s.cancel(a), a = s(function() { a = le, n.Apply(e, t) }, i || 10, r) } }, throttle: function(n, i) { var o; return function() { var e = arguments,
                                t = f.now();
                            (!o || i < t - o) && (n.Apply(this, e), o = t) } }, time: function(e) { var t = f.now(); return e(), f.now() - t }, valueOnUse: function(e, t, n) { var i = null,
                            o = Array.prototype.slice.call(arguments),
                            r = 3 < o.length ? o.slice(3) : [];
                        Object.defineProperty(e, t, { get: function() { return null === i && (i = n.Apply(e, r)), i } }) }, nextUid: function() { return "" + v++ }, disconnectScope: function(e) { if (e && e.$root !== e && !e.$$destroyed) { var t = e.$parent;
                            e.$$disconnected = !0, t.$$childHead === e && (t.$$childHead = e.$$nextSibling), t.$$childTail === e && (t.$$childTail = e.$$prevSibling), e.$$prevSibling && (e.$$prevSibling.$$nextSibling = e.$$nextSibling), e.$$nextSibling && (e.$$nextSibling.$$prevSibling = e.$$prevSibling), e.$$nextSibling = e.$$prevSibling = null } }, reconnectScope: function(e) { if (e && e.$root !== e && e.$$disconnected) { var t = e,
                                n = t.$parent;
                            t.$$disconnected = !1, t.$$prevSibling = n.$$childTail, n.$$childHead ? (n.$$childTail.$$nextSibling = t, n.$$childTail = t) : n.$$childHead = n.$$childTail = t } }, getClosest: function(e, t, n) { if (se.isString(t)) { var i = t.toUpperCase();
                            t = function(e) { return e.nodeName.toUpperCase() === i } } if (e instanceof se.element && (e = e[0]), n && (e = e.parentNode), !e) return null;
                        do { if (t(e)) return e } while (e = e.parentNode); return null }, elementContains: function(t, n) { return (j.Node && j.Node.prototype && Node.prototype.contains ? se.bind(t, t.contains) : se.bind(t, function(e) { return t === n || !!(16 & this.compareDocumentPosition(e)) }))(n) }, extractElementByName: function(e, i, t, n) { var o = s(e); return !o && n && r.warn(f.supplant("Unable to find node '{0}' in element '{1}'.", [i, e[0].outerHTML])), se.element(o || e);

                        function s(e) { return function(e) { if (e)
                                    for (var t = 0, n = e.length; t < n; t++)
                                        if (e[t].nodeName.toLowerCase() === i) return e[t];
                                return null }(e) || (t ? function(e) { var t; if (e)
                                    for (var n = 0, i = e.length; n < i; n++) { var o = e[n]; if (!t)
                                            for (var r = 0, a = o.childNodes.length; r < a; r++) t = t || s([o.childNodes[r]]) }
                                return t }(e) : null) } }, initOptionalProperties: function(i, o, r) { r = r || {}, se.forEach(i.$$isolateBindings, function(e, t) { if (e.optional && se.isUndefined(i[t])) { var n = se.isDefined(o[e.attrName]);
                                i[t] = se.isDefined(r[t]) ? r[t] : n } }) }, nextTick: function(e, t, n) { var i = f.nextTick,
                            o = i.timeout,
                            r = i.queue || []; return r.push({ scope: n, callback: e }), null == t && (t = !0), i.digest = i.digest || t, i.queue = r, o || (i.timeout = s(function() { var e = i.queue,
                                t = i.digest;
                            i.queue = [], i.timeout = null, i.digest = !1, e.forEach(function(e) { e.scope && e.scope.$$destroyed || e.callback() }), t && a.$digest() }, 0, !1)) }, processTemplate: function(e) { return p ? e : e && se.isString(e) ? e.replace(/\{\{/g, d).replace(/}}/g, m) : e }, getParentWithPointerEvents: function(e) { for (var t = e.parent(); o(t, "pointer-events", "none");) t = t.parent(); return t }, getNearestContentElement: function(e) { for (var t = e.parent()[0]; t && t !== i[0] && t !== document.body && "MD-CONTENT" !== t.nodeName.toUpperCase();) t = t.parentNode; return t }, checkStickySupport: function() { var e, t = se.element("<div>");
                        l[0].body.appendChild(t[0]); for (var n = ["sticky", "-webkit-sticky"], i = 0; i < n.length; ++i)
                            if (t.css({ position: n[i], top: 0, "z-index": 2 }), t.css("position") == n[i]) { e = n[i]; break }
                        return t.remove(), e }, parseAttributeBoolean: function(e, t) { return "" === e || !!e && (!1 === t || "false" !== e && "0" !== e) }, hasComputedStyle: o, isParentFormSubmitted: function(e) { var t = f.getClosest(e, "form"),
                            n = t ? se.element(t).controller("form") : null; return !!n && n.$submitted }, animateScrollTo: function(o, r, a) { var s = o.scrollTop,
                            l = r - s,
                            c = s < r,
                            d = f.now();
                        u(function e() { var t = (n = a || 1e3, i = f.now() - d, function(e, t, n, i) { if (i < e) return t + n; var o = (e /= i) * e; return t + n * (o * e * -2 + 3 * o) }(i, s, l, n)); var n, i;
                            o.scrollTop = t;
                            (c ? t < r : r < t) && u(e) }) }, uniq: function(e) { if (e) return e.filter(function(e, t, n) { return n.indexOf(e) === t }) } }; return f.dom.animator = e(f), f;

                function g(e) { return e[0] || e } }
            se.module("material.core").factory("$mdUtil", e), se.element.prototype.focus = se.element.prototype.focus || function() { return this.length && this[0].focus(), this }, se.element.prototype.blur = se.element.prototype.blur || function() { return this.length && this[0].blur(), this } }(), l.$inject = ["$$rAF", "$log", "$window", "$interpolate"], se.module("material.core").provider("$mdAria", function() { var o = { showWarnings: !0 }; return { disableWarnings: function() { o.showWarnings = !1 }, $get: ["$$rAF", "$log", "$window", "$interpolate", function(e, t, n, i) { return l.Apply(o, arguments) }] } }), se.module("material.core").provider("$mdCompiler", c), c.$inject = ["$compileProvider"],
        function() { o.$inject = ["$$MdGestureHandler", "$$rAF", "$timeout"]; var r, i, d = {},
                u = !(n.$inject = ["$mdGesture", "$$MdGestureHandler"]),
                m = 6,
                a = null,
                s = !1;

            function e() {}

            function o(i, e, n) { var t = navigator.userAgent || navigator.vendor || j.opera,
                    o = t.match(/ipad|iphone|ipod/i),
                    r = t.match(/android/i),
                    a = function() { for (var e = document.createElement("div"), t = ["", "webkit", "Moz", "MS", "ms", "o"], n = 0; n < t.length; n++) { var i = t[n],
                                o = i ? i + "TouchAction" : "touchAction"; if (se.isDefined(e.style[o])) return o } }(),
                    s = void 0 !== j.jQuery && se.element === j.jQuery,
                    l = { handler: function(e, t) { var n = new i(e); return se.extend(n, t), d[e] = n, l }, register: function(e, t, n) { var i = d[t.replace(/^\$md./, "")]; if (i) return i.registerElement(e, n); throw new Error("Failed to register element with handler " + t + ". Available handlers: " + Object.keys(d).join(", ")) }, isHijackingClicks: (o || r) && !s && !u };

                function c(n) { return function(e, t) { t.distance < this.state.options.maxDistance && this.dispatchEvent(e, n, t) } } return l.isHijackingClicks && (l.handler("click", { options: { maxDistance: m }, onEnd: c("click") }), l.handler("focus", { options: { maxDistance: m }, onEnd: function(e, t) { t.distance < this.state.options.maxDistance && g(e.target) && (this.dispatchEvent(e, "focus", t), e.target.focus()) } }), l.handler("mouseup", { options: { maxDistance: m }, onEnd: c("mouseup") }), l.handler("mousedown", { onStart: function(e) { this.dispatchEvent(e, "mousedown") } })), l.handler("press", { onStart: function(e, t) { this.dispatchEvent(e, "$md.pressdown") }, onEnd: function(e, t) { this.dispatchEvent(e, "$md.pressup") } }).handler("hold", { options: { maxDistance: 6, delay: 500 }, onCancel: function() { n.cancel(this.state.timeout) }, onStart: function(e, t) { if (!this.state.registeredParent) return this.cancel();
                        this.state.pos = { x: t.x, y: t.y }, this.state.timeout = n(se.bind(this, function() { this.dispatchEvent(e, "$md.hold"), this.cancel() }), this.state.options.delay, !1) }, onMove: function(e, t) { a || "touchmove" !== e.type || e.preventDefault(); var n = this.state.pos.x - t.x,
                            i = this.state.pos.y - t.y;
                        Math.sqrt(n * n + i * i) > this.options.maxDistance && this.cancel() }, onEnd: function() { this.onCancel() } }).handler("drag", { options: { minDistance: 6, horizontal: !0, cancelMultiplier: 1.5 }, onSetup: function(e, t) { a && (this.oldTouchAction = e[0].style[a], e[0].style[a] = t.horizontal ? "pan-y" : "pan-x") }, onCleanup: function(e) { this.oldTouchAction && (e[0].style[a] = this.oldTouchAction) }, onStart: function(e) { this.state.registeredParent || this.cancel() }, onMove: function(e, t) { var n, i;
                        a || "touchmove" !== e.type || e.preventDefault(), this.state.dragPointer ? this.dispatchDragMove(e) : (i = this.state.options.horizontal ? (n = Math.abs(t.distanceX) > this.state.options.minDistance, Math.abs(t.distanceY) > this.state.options.minDistance * this.state.options.cancelMultiplier) : (n = Math.abs(t.distanceY) > this.state.options.minDistance, Math.abs(t.distanceX) > this.state.options.minDistance * this.state.options.cancelMultiplier), n ? (this.state.dragPointer = p(e), h(e, this.state.dragPointer), this.dispatchEvent(e, "$md.dragstart", this.state.dragPointer)) : i && this.cancel()) }, dispatchDragMove: e.throttle(function(e) { this.state.isRunning && (h(e, this.state.dragPointer), this.dispatchEvent(e, "$md.drag", this.state.dragPointer)) }), onEnd: function(e, t) { this.state.dragPointer && (h(e, this.state.dragPointer), this.dispatchEvent(e, "$md.dragend", this.state.dragPointer)) } }).handler("swipe", { options: { minVelocity: .65, minDistance: 10 }, onEnd: function(e, t) { var n;
                        Math.abs(t.velocityX) > this.state.options.minVelocity && Math.abs(t.distanceX) > this.state.options.minDistance ? (n = "left" == t.directionX ? "$md.swipeleft" : "$md.swiperight", this.dispatchEvent(e, n)) : Math.abs(t.velocityY) > this.state.options.minVelocity && Math.abs(t.distanceY) > this.state.options.minDistance && (n = "up" == t.directionY ? "$md.swipeup" : "$md.swipedown", this.dispatchEvent(e, n)) } }) }

            function t(e) { this.name = e, this.state = {} }

            function n(e, o) {
                function t(e) {!e.clientX && !e.clientY || e.$material || e.isIonicTap || c(e) || "mousedown" === e.type && (g(e.target) || g(document.activeElement)) || (e.preventDefault(), e.stopPropagation()) }
                document.contains || (document.contains = function(e) { return document.body.contains(e) }), !s && e.isHijackingClicks && (document.addEventListener("click", function(e) { var t = 0 === e.clientX && 0 === e.clientY,
                        n = e.target && "submit" === e.target.type;
                    t || e.$material || e.isIonicTap || c(e) || n ? (a = null, "label" == e.target.tagName.toLowerCase() && (a = { x: e.x, y: e.y })) : (e.preventDefault(), e.stopPropagation(), a = null) }, !0), document.addEventListener("mouseup", t, !0), document.addEventListener("mousedown", t, !0), document.addEventListener("focus", t, !0), s = !0);

                function n(e, t) { var n; for (var i in d)(n = d[i]) instanceof o && ("start" === e && n.cancel(), n[e](t, r)) }
                se.element(document).on("mousedown touchstart pointerdown", function(e) { if (r) return; var t = +Date.now(); if (i && !l(e, i) && t - i.endTime < 1500) return;
                    r = p(e), n("start", e) }).on("mousemove touchmove pointermove", function(e) { if (!r || !l(e, r)) return;
                    h(e, r), n("move", e) }).on("mouseup mouseleave touchend touchcancel pointerup pointercancel", function(e) { if (!r || !l(e, r)) return;
                    h(e, r), r.endTime = +Date.now(), "pointercancel" !== e.type && n("end", e);
                    i = r, r = null }).on("$$mdGestureReset", function() { i = r = null }) }

            function p(e) { var t = f(e),
                    n = { startTime: +Date.now(), target: e.target, type: e.type.charAt(0) }; return n.startX = n.x = t.pageX, n.startY = n.y = t.pageY, n }

            function l(e, t) { return e && t && e.type.charAt(0) === t.type }

            function c(e) { return a && a.x == e.x && a.y == e.y }

            function h(e, t) { var n = f(e),
                    i = t.x = n.pageX,
                    o = t.y = n.pageY;
                t.distanceX = i - t.startX, t.distanceY = o - t.startY, t.distance = Math.sqrt(t.distanceX * t.distanceX + t.distanceY * t.distanceY), t.directionX = 0 < t.distanceX ? "right" : t.distanceX < 0 ? "left" : "", t.directionY = 0 < t.distanceY ? "down" : t.distanceY < 0 ? "up" : "", t.duration = Date.now() - t.startTime, t.velocityX = t.distanceX / t.duration, t.velocityY = t.distanceY / t.duration }

            function f(e) { return (e = e.originalEvent || e).touches && e.touches[0] || e.changedTouches && e.changedTouches[0] || e }

            function g(e) { return !!e && "-1" != e.getAttribute("tabindex") && !e.hasAttribute("disabled") && (e.hasAttribute("tabindex") || e.hasAttribute("href") || e.isContentEditable || -1 != ["INPUT", "SELECT", "BUTTON", "TEXTAREA", "VIDEO", "AUDIO"].indexOf(e.nodeName)) }
            se.module("material.core.gestures", []).provider("$mdGesture", e).factory("$$MdGestureHandler", function() { var e = void 0 !== j.jQuery && se.element === j.jQuery; return t.prototype = { options: {}, dispatchEvent: e ? function(e, t, n) { n = n || r; var i = new se.element.Event(t);
                        i.$material = !0, i.pointer = n, i.srcEvent = e, se.extend(i, { clientX: n.x, clientY: n.y, screenX: n.x, screenY: n.y, pageX: n.x, pageY: n.y, ctrlKey: e.ctrlKey, altKey: e.altKey, shiftKey: e.shiftKey, metaKey: e.metaKey }), se.element(n.target).trigger(i) } : function(e, t, n) { var i;
                        n = n || r, "click" === t || "mouseup" == t || "mousedown" == t ? (i = document.createEvent("MouseEvents")).initMouseEvent(t, !0, !0, j, e.detail, n.x, n.y, n.x, n.y, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget || null) : (i = document.createEvent("CustomEvent")).initCustomEvent(t, !0, !0, {});
                        i.$material = !0, i.pointer = n, i.srcEvent = e, n.target.dispatchEvent(i) }, onSetup: se.noop, onCleanup: se.noop, onStart: se.noop, onMove: se.noop, onEnd: se.noop, onCancel: se.noop, start: function(e, t) { if (!this.state.isRunning) { var n = this.getNearestParent(e.target),
                                i = n && n.$mdGesture[this.name] || {};
                            this.state = { isRunning: !0, options: se.extend({}, this.options, i), registeredParent: n }, this.onStart(e, t) } }, move: function(e, t) { this.state.isRunning && this.onMove(e, t) }, end: function(e, t) { this.state.isRunning && (this.onEnd(e, t), this.state.isRunning = !1) }, cancel: function(e, t) { this.onCancel(e, t), this.state = {} }, getNearestParent: function(e) { for (var t = e; t;) { if ((t.$mdGesture || {})[this.name]) return t;
                            t = t.parentNode } return null }, registerElement: function(e, t) { var n = this; return e[0].$mdGesture = e[0].$mdGesture || {}, e[0].$mdGesture[this.name] = t || {}, e.on("$destroy", i), n.onSetup(e, t || {}), i;

                        function i() { delete e[0].$mdGesture[n.name], e.off("$destroy", i), n.onCleanup(e, t || {}) } } }, t }).run(n), e.prototype = { skipClickHijack: function() { return u = !0 }, setMaxClickDistance: function(e) { m = parseInt(e) }, $get: ["$$MdGestureHandler", "$$rAF", "$timeout", function(e, t, n) { return new o(e, t, n) }] } }(), d.$inject = ["$timeout", "$mdUtil"], se.module("material.core.interaction", []).service("$mdInteraction", d), d.prototype.initializeEvents = function() { var e = "MSPointerEvent" in j ? "MSPointerDown" : "PointerEvent" in j ? "pointerdown" : null;
            this.bodyElement.on("keydown mousedown", this.onInputEvent.bind(this)), "ontouchstart" in document.documentElement && this.bodyElement.on("touchstart", this.onBufferInputEvent.bind(this)), e && this.bodyElement.on(e, this.onInputEvent.bind(this)) }, d.prototype.onInputEvent = function(e) { if (!this.isBuffering) { var t = this.inputEventMap[e.type]; "pointer" === t && (t = this.iePointerMap[e.pointerType] || e.pointerType), this.lastInteractionType = t, this.lastInteractionTime = this.$mdUtil.now() } }, d.prototype.onBufferInputEvent = function(e) { this.$timeout.cancel(this.bufferTimeout), this.onInputEvent(e), this.isBuffering = !0, this.bufferTimeout = this.$timeout(function() { this.isBuffering = !1 }.bind(this), 650, !1) }, d.prototype.getLastInteractionType = function() { return this.lastInteractionType }, d.prototype.isUserInvoked = function(e) { var t = se.isNumber(e) ? e : 15; return this.lastInteractionTime >= this.$mdUtil.now() - t }, se.module("material.core").provider("$$interimElement", function() { return t.$inject = ["$document", "$q", "$rootScope", "$timeout", "$rootElement", "$animate", "$mdUtil", "$mdCompiler", "$mdTheming", "$injector", "$exceptionHandler"], e.$get = t, e;

            function e(o) { e.$inject = ["$$interimElement", "$injector"]; var n = ["onHide", "onShow", "onRemove"],
                    r = {},
                    c = { presets: {} },
                    i = { setDefaults: function(e) { return c.optionsFactory = e.options, c.methods = (e.methods || []).concat(n), i }, addPreset: function(e, t) { if ((t = t || {}).methods = t.methods || [], t.options = t.options || function() { return {} }, /^cancel|hide|show$/.test(e)) throw new Error("Preset '" + e + "' in " + o + " is reserved!"); if (-1 < t.methods.indexOf("_options")) throw new Error("Method '_options' in " + o + " is reserved!"); return c.presets[e] = { methods: t.methods.concat(n), optionsFactory: t.options, argOption: t.argOption }, i }, addMethod: function(e, t) { return r[e] = t, i }, $get: e }; return i.addPreset("build", { methods: ["controller", "controllerAs", "resolve", "multiple", "template", "templateUrl", "themable", "transformTemplate", "parent", "contentElement"] }), i;

                function e(e, i) { var a, t, n = e(),
                        s = { hide: n.hide, cancel: n.cancel, show: function(e) {
                                (e = e || {})._options && (e = e._options); return n.show(se.extend({}, t, e)) }, destroy: function(e) { return n.destroy(e) } }; return a = c.methods || [], t = l(c.optionsFactory, {}), se.forEach(r, function(e, t) { s[t] = e }), se.forEach(c.presets, function(t, n) { var i = l(t.optionsFactory, {}),
                            e = (t.methods || []).concat(a);

                        function o(e) { this._options = se.extend({}, i, e) } if (se.extend(i, { $type: n }), se.forEach(e, function(t) { o.prototype[t] = function(e) { return this._options[t] = e, this } }), t.argOption) { var r = "show" + n.charAt(0).toUpperCase() + n.slice(1);
                            s[r] = function(e) { var t = s[n](e); return s.show(t) } }
                        s[n] = function(e) { return arguments.length && t.argOption && !se.isObject(e) && !se.isArray(e) ? (new o)[t.argOption](e) : new o(e) } }), s;

                    function l(e, t) { var n = {}; return n[o] = s, i.invoke(e || function() { return t }, {}, n) } } }

            function t(u, m, t, p, h, i, n, f, g, l, c) { return function() { var d, o = [],
                        r = [],
                        a = []; return d = { show: function(e) { var t = new s((e = e || {}) || {}),
                                n = e.multiple ? m.resolve() : m.all(o);
                            e.multiple || (n = n.then(function() { var e = r.concat(a.map(d.cancel)); return m.all(e) })); var i = n.then(function() { return t.show().catch(function(e) { return e }).finally(function() { o.splice(o.indexOf(i), 1), a.push(t) }) }); return o.push(i), t.deferred.promise.catch(function(e) { return e instanceof Error && c(e), e }), t.deferred.promise }, hide: e(function(n, i) {
                            { if ((i = i || {}).closeAll) return m.all(a.slice().reverse().map(e)); if (i.closeTo !== le) return m.all(a.slice(i.closeTo).map(e)) } return e(a[a.length - 1]);

                            function e(e) { var t = e.remove(n, !1, i || {}).catch(function(e) { return e }).finally(function() { r.splice(r.indexOf(t), 1) }); return a.splice(a.indexOf(e), 1), r.push(t), e.deferred.promise } }), cancel: e(function(e, t) { var n = a.pop(); if (!n) return m.when(e); var i = n.remove(e, !0, t || {}).catch(function(e) { return e }).finally(function() { r.splice(r.indexOf(i), 1) }); return r.push(i), n.deferred.promise.catch(se.noop) }), destroy: function(e) { var t = e ? null : a.shift(),
                                n = se.element(e).length && se.element(e)[0].parentNode; if (n) { var i = a.filter(function(e) { return e.options.element[0] === n });
                                i.length && (t = i[0], a.splice(a.indexOf(t), 1)) } return t ? t.remove(!1, !1, { $destroy: !0 }) : m.when(!1) }, $injector_: l };

                    function e(t) { return function() { var e = arguments; return a.length ? t.Apply(d, e) : o.length ? o[0].finally(function() { return t.Apply(d, e) }) : m.when("No interim elements currently showing up.") } }

                    function s(a) { var r, s, l = m.when(!0); return a = function(e) {
                            (e = e || {}).template && (e.template = n.processTemplate(e.template)); return se.extend({ preserveScope: !1, cancelAutoHide: se.noop, scope: e.scope || t.$new(e.isolateScope), onShow: function(e, t, n) { return i.enter(t, n.parent) }, onRemove: function(e, t) { return t && i.leave(t) || m.when() } }, e) }(a), r = { options: a, deferred: m.defer(), show: function() { return m(function(t, n) { var i;

                                    function o(e) { r.deferred.reject(e), n(e) }
                                    a.onCompiling && a.onCompiling(a), (((i = a).skipCompile ? null : f.compile(i)) || m(function(e) { e({ locals: {}, link: function() { return i.element } }) })).then(function(e) { s = function(e, t) { se.extend(e.locals, t); var n = e.link(t.scope);
                                            t.element = n, t.parent = function(e, t) { var n, i = t.parent;
                                                i = se.isFunction(i) ? i(t.scope, e, t) : se.isString(i) ? se.element(u[0].querySelector(i)) : se.element(i); if ((i || {}).length) return i;
                                                h[0] && h[0].querySelector && (n = h[0].querySelector(":not(svg) > body"));
                                                n = n || h[0]; "#comment" == n.nodeName && (n = u[0].body); return se.element(n) }(n, t), t.themable && g(n); return n }(e, a), a.cleanupElement = e.cleanup, l = function(n, i, o) { var e = i.onShowing || se.noop,
                                                r = i.onComplete || se.noop; try { e(i.scope, n, i, o) } catch (e) { return m.reject(e) } return m(function(e, t) { try { m.when(i.onShow(i.scope, n, i, o)).then(function() { r(i.scope, n, i),
                                                            function() { var e, t = se.noop;
                                                                a.hideDelay && (e = p(d.hide, a.hideDelay), t = function() { p.cancel(e) });
                                                                a.cancelAutoHide = function() { t(), a.cancelAutoHide = le } }(), e(n) }, t) } catch (e) { t(e.message) } }) }(s, a, e.controller).then(t, o) }).catch(o) }) }, remove: function(e, t, n) { if (!s) return m.when(!1); return (a = se.extend(a || {}, n || {})).cancelAutoHide && a.cancelAutoHide(), a.element.triggerHandler("$mdInterimElementRemove"), !0 === a.$destroy ? c(a.element, a).then(function() { t && o(e) || i(e) }) : (m.when(l).finally(function() { c(a.element, a).then(function() { t ? o(e) : i(e) }, o) }), r.deferred.promise);

                                function i(e) { r.deferred.resolve(e) }

                                function o(e) { r.deferred.reject(e) } } };

                        function c(i, o) { var r = o.onRemoving || se.noop; return m(function(e, t) { try { var n = m.when(o.onRemove(o.scope, i, o) || !0);
                                    r(i, n), o.$destroy ? (e(i), !o.preserveScope && o.scope && n.then(function() { o.scope.$destroy() })) : n.then(function() {!o.preserveScope && o.scope && o.scope.$destroy(), e(i) }, t) } catch (e) { t(e.message) } }) } } } } }), D = /(-gt)?-(sm|md|lg|print)/g, I = /\s+/g, _ = ["grow", "initial", "auto", "none", "noshrink", "nogrow"], O = ["row", "column"], P = ["", "start", "center", "end", "stretch", "space-around", "space-between"], L = ["", "start", "center", "end", "stretch"], R = { enabled: !0, breakpoints: [] }, E = se.module("material.core.layout", ["ng"]), A = /^((?:x|data)[\:\-_])/i, S = /([\:\-\_]+(.))/g, k = ["layout", "flex", "flex-order", "flex-offset", "layout-align"], M = ["show", "hide", "layout-padding", "layout-margin"], se.forEach(["", "xs", "gt-xs", "sm", "gt-sm", "md", "gt-md", "lg", "gt-lg", "xl", "print"], function(n) { se.forEach(k, function(e) { var l, t = n ? e + "-" + n : e;

                function i(e, t, n) { var i, o, r, a = (i = t, o = l, function(e) { var t = v(o, e || "");
                            se.isDefined(t) && (r && i.removeClass(r), r = t ? o + "-" + t.trim().replace(I, "-") : o, i.addClass(r)) }),
                        s = n.$observe(n.$normalize(l), a);
                    a(C(l, n, "")), e.$on("$destroy", function() { s() }) }
                E.directive(u(t), (l = t, ["$mdUtil", "$interpolate", "$log", function(e, t, n) { return x = e, w = t, T = n, { restrict: "A", compile: function(e, t) { var n; return R.enabled && (g(l, t, e, T), v(l, C(l, t, ""), b(e, l, t)), n = i), n || se.noop } } }])) }), se.forEach(M, function(e) { var t = n ? e + "-" + n : e;
                E.directive(u(t), h(t)) }) }), E.provider("$$mdLayout", function() { return { $get: se.noop, validateAttributeValue: v, validateAttributeUsage: g, disableLayouts: function(e) { R.enabled = !0 !== e } } }).directive("mdLayoutCss", p).directive("ngCloak", function(i) { return ["$timeout", function(n) { return { restrict: "A", priority: -10, compile: function(e) { return R.enabled ? (e.addClass(i), function(e, t) { n(function() { t.removeClass(i) }, 10, !1) }) : se.noop } } }] }("data-ng-cloak")).directive("layoutWrap", h("layout-wrap")).directive("layoutNowrap", h("layout-nowrap")).directive("layoutNoWrap", h("layout-no-wrap")).directive("layoutFill", h("layout-fill")).directive("layoutLtMd", f("layout-lt-md")).directive("layoutLtLg", f("layout-lt-lg")).directive("flexLtMd", f("flex-lt-md")).directive("flexLtLg", f("flex-lt-lg")).directive("layoutAlignLtMd", f("layout-align-lt-md")).directive("layoutAlignLtLg", f("layout-align-lt-lg")).directive("flexOrderLtMd", f("flex-order-lt-md")).directive("flexOrderLtLg", f("flex-order-lt-lg")).directive("offsetLtMd", f("flex-offset-lt-md")).directive("offsetLtLg", f("flex-offset-lt-lg")).directive("hideLtMd", f("hide-lt-md")).directive("hideLtLg", f("hide-lt-lg")).directive("showLtMd", f("show-lt-md")).directive("showLtLg", f("show-lt-lg")).config(m), z.$inject = ["$timeout"], se.module("material.core").service("$mdLiveAnnouncer", z), z.prototype.announce = function(e, t) { t = t || "polite"; var n = this;
            n._liveElement.textContent = "", n._liveElement.setAttribute("aria-live", t), n._$timeout(function() { n._liveElement.textContent = e }, n._announceTimeout, !1) }, z.prototype._createLiveElement = function() { var e = document.createElement("div"); return e.classList.add("md-visually-hidden"), e.setAttribute("role", "status"), e.setAttribute("aria-atomic", "true"), e.setAttribute("aria-live", "polite"), document.body.appendChild(e), e }, se.module("material.core.meta", []).provider("$$mdMeta", function() { var i = se.element(document.head),
                o = {};

            function r(e) { if (o[e]) return !0; var t = document.getElementsByName(e)[0]; return !!t && (o[e] = se.element(t), !0) } var e = { setMeta: function(e, t) { if (r(e), o[e]) o[e].attr("content", t);
                    else { var n = se.element('<meta name="' + e + '" content="' + t + '"/>');
                        i.append(n), o[e] = n } return function() { o[e].attr("content", ""), o[e].remove(), delete o[e] } }, getMeta: function(e) { if (!r(e)) throw Error("$$mdMeta: could not find a meta tag with the name '" + e + "'"); return o[e].attr("content") } }; return se.extend({}, e, { $get: function() { return e } }) }), W.$inject = ["$log", "$q"], se.module("material.core").factory("$mdComponentRegistry", W), V.$inject = ["$mdInkRipple"], se.module("material.core").factory("$mdButtonInkRipple", V), Y.$inject = ["$mdInkRipple"], se.module("material.core").factory("$mdCheckboxInkRipple", Y), K.$inject = ["$mdInkRipple"], se.module("material.core").factory("$mdListInkRipple", K),
        function() { r.$inject = ["$scope", "$element", "rippleOptions", "$window", "$timeout", "$mdUtil", "$mdColorUtil"], e.$inject = ["$mdButtonInkRipple", "$mdCheckboxInkRipple"], se.module("material.core").provider("$mdInkRipple", function() { var o = !1; return { disableInkRipple: function() { o = !0 }, $get: ["$injector", function(i) { return { attach: function(e, t, n) { return o || t.controller("mdNoInk") ? se.noop : i.instantiate(r, { $scope: e, $element: t, rippleOptions: n }) } } }] } }).directive("mdInkRipple", e).directive("mdNoInk", n).directive("mdNoBar", n).directive("mdNoStretch", n);

            function e(i, o) { return { controller: se.noop, link: function(e, t, n) { n.hasOwnProperty("mdInkRippleCheckbox") ? o.attach(e, t) : i.attach(e, t) } } }

            function r(e, t, n, i, o, r, a) { this.$window = i, this.$timeout = o, this.$mdUtil = r, this.$mdColorUtil = a, this.$scope = e, this.$element = t, this.options = n, this.mousedown = !1, this.ripples = [], this.timeout = null, this.lastRipple = null, r.valueOnUse(this, "container", this.createContainer), this.$element.addClass("md-ink-ripple"), (t.controller("mdInkRipple") || {}).createRipple = se.bind(this, this.createRipple), (t.controller("mdInkRipple") || {}).setColor = se.bind(this, this.color), this.bindEvents() }

            function t(e, t) {
                (e.mousedown || e.lastRipple) && (e.mousedown = !1, e.$mdUtil.nextTick(se.bind(e, t), !1)) }

            function n() { return { controller: se.noop } }
            r.prototype.color = function(e) { var t, n, i = this; return se.isDefined(e) && (i._color = i._parseColor(e)), i._color || i._parseColor(i.inkRipple()) || i._parseColor((t = i.options && i.options.colorElement ? i.options.colorElement : [], (n = t.length ? t[0] : i.$element[0]) ? i.$window.getComputedStyle(n).color : "rgb(0,0,0)")) }, r.prototype.calculateColor = function() { return this.color() }, r.prototype._parseColor = function(e, t) { t = t || 1; var n = this.$mdColorUtil; if (e) return 0 === e.indexOf("rgba") ? e.replace(/\d?\.?\d*\s*\)\s*$/, (.1 * t).toString() + ")") : 0 === e.indexOf("rgb") ? n.rgbToRgba(e) : 0 === e.indexOf("#") ? n.hexToRgba(e) : void 0 }, r.prototype.bindEvents = function() { this.$element.on("mousedown", se.bind(this, this.handleMousedown)), this.$element.on("mouseup touchend", se.bind(this, this.handleMouseup)), this.$element.on("mouseleave", se.bind(this, this.handleMouseup)), this.$element.on("touchmove", se.bind(this, this.handleTouchmove)) }, r.prototype.handleMousedown = function(e) { if (!this.mousedown)
                    if (e.hasOwnProperty("originalEvent") && (e = e.originalEvent), this.mousedown = !0, this.options.center) this.createRipple(this.container.prop("clientWidth") / 2, this.container.prop("clientWidth") / 2);
                    else if (e.srcElement !== this.$element[0]) { var t = this.$element[0].getBoundingClientRect(),
                        n = e.clientX - t.left,
                        i = e.clientY - t.top;
                    this.createRipple(n, i) } else this.createRipple(e.offsetX, e.offsetY) }, r.prototype.handleMouseup = function() { t(this, this.clearRipples) }, r.prototype.handleTouchmove = function() { t(this, this.deleteRipples) }, r.prototype.deleteRipples = function() { for (var e = 0; e < this.ripples.length; e++) this.ripples[e].remove() }, r.prototype.clearRipples = function() { for (var e = 0; e < this.ripples.length; e++) this.fadeInComplete(this.ripples[e]) }, r.prototype.createContainer = function() { var e = se.element('<div class="md-ripple-container"></div>'); return this.$element.append(e), e }, r.prototype.clearTimeout = function() { this.timeout && (this.$timeout.cancel(this.timeout), this.timeout = null) }, r.prototype.isRippleAllowed = function() { var e = this.$element[0];
                do { if (!e.tagName || "BODY" === e.tagName) break; if (e && se.isFunction(e.hasAttribute)) { if (e.hasAttribute("disabled")) return !1; if ("false" === this.inkRipple() || "0" === this.inkRipple()) return !1 } } while (e = e.parentNode); return !0 }, r.prototype.inkRipple = function() { return this.$element.attr("data-md-ink-ripple") }, r.prototype.createRipple = function(e, t) { if (this.isRippleAllowed()) { var n, i, o, r = this,
                        a = r.$mdColorUtil,
                        s = se.element('<div class="md-ripple"></div>'),
                        l = this.$element.prop("clientWidth"),
                        c = this.$element.prop("clientHeight"),
                        d = 2 * Math.max(Math.abs(l - e), e),
                        u = 2 * Math.max(Math.abs(c - t), t),
                        m = (n = this.options.fitRipple, i = d, o = u, n ? Math.max(i, o) : Math.sqrt(Math.pow(i, 2) + Math.pow(o, 2))),
                        p = this.calculateColor();
                    s.css({ left: e + "px", top: t + "px", background: "black", width: m + "px", height: m + "px", backgroundColor: a.rgbaToRgb(p), borderColor: a.rgbaToRgb(p) }), this.lastRipple = s, this.clearTimeout(), this.timeout = this.$timeout(function() { r.clearTimeout(), r.mousedown || r.fadeInComplete(s) }, 157.5, !1), this.options.dimBackground && this.container.css({ backgroundColor: p }), this.container.append(s), this.ripples.push(s), s.addClass("md-ripple-placed"), this.$mdUtil.nextTick(function() { s.addClass("md-ripple-scaled md-ripple-active"), r.$timeout(function() { r.clearRipples() }, 450, !1) }, !1) } }, r.prototype.fadeInComplete = function(e) { this.lastRipple === e && (this.timeout || this.mousedown) || this.removeRipple(e) }, r.prototype.removeRipple = function(e) { var t = this;
                this.ripples.indexOf(e) < 0 || (this.ripples.splice(this.ripples.indexOf(e), 1), e.removeClass("md-ripple-active"), e.addClass("md-ripple-remove"), 0 === this.ripples.length && this.container.css({ backgroundColor: "" }), this.$timeout(function() { t.fadeOutComplete(e) }, 450, !1)) }, r.prototype.fadeOutComplete = function(e) { e.remove(), this.lastRipple = null } }(), G.$inject = ["$mdInkRipple"], se.module("material.core").factory("$mdTabInkRipple", G), se.module("material.core.theming.palette", []).constant("$mdColorPalette", { red: { 50: "#ffebee", 100: "#ffcdd2", 200: "#ef9a9a", 300: "#e57373", 400: "#ef5350", 500: "#f44336", 600: "#e53935", 700: "#d32f2f", 800: "#c62828", 900: "#b71c1c", A100: "#ff8a80", A200: "#ff5252", A400: "#ff1744", A700: "#d50000", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 300 A100", contrastStrongLightColors: "400 500 600 700 A200 A400 A700" }, pink: { 50: "#fce4ec", 100: "#f8bbd0", 200: "#f48fb1", 300: "#f06292", 400: "#ec407a", 500: "#e91e63", 600: "#d81b60", 700: "#c2185b", 800: "#ad1457", 900: "#880e4f", A100: "#ff80ab", A200: "#ff4081", A400: "#f50057", A700: "#c51162", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 A100", contrastStrongLightColors: "500 600 A200 A400 A700" }, purple: { 50: "#f3e5f5", 100: "#e1bee7", 200: "#ce93d8", 300: "#ba68c8", 400: "#ab47bc", 500: "#9c27b0", 600: "#8e24aa", 700: "#7b1fa2", 800: "#6a1b9a", 900: "#4a148c", A100: "#ea80fc", A200: "#e040fb", A400: "#d500f9", A700: "#aa00ff", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 A100", contrastStrongLightColors: "300 400 A200 A400 A700" }, "deep-purple": { 50: "#ede7f6", 100: "#d1c4e9", 200: "#b39ddb", 300: "#9575cd", 400: "#7e57c2", 500: "#673ab7", 600: "#5e35b1", 700: "#512da8", 800: "#4527a0", 900: "#311b92", A100: "#b388ff", A200: "#7c4dff", A400: "#651fff", A700: "#6200ea", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 A100", contrastStrongLightColors: "300 400 A200" }, indigo: { 50: "#e8eaf6", 100: "#c5cae9", 200: "#9fa8da", 300: "#7986cb", 400: "#5c6bc0", 500: "#3f51b5", 600: "#3949ab", 700: "#303f9f", 800: "#283593", 900: "#1a237e", A100: "#8c9eff", A200: "#536dfe", A400: "#3d5afe", A700: "#304ffe", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 A100", contrastStrongLightColors: "300 400 A200 A400" }, blue: { 50: "#e3f2fd", 100: "#bbdefb", 200: "#90caf9", 300: "#64b5f6", 400: "#42a5f5", 500: "#2196f3", 600: "#1e88e5", 700: "#1976d2", 800: "#1565c0", 900: "#0d47a1", A100: "#82b1ff", A200: "#448aff", A400: "#2979ff", A700: "#2962ff", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 300 400 A100", contrastStrongLightColors: "500 600 700 A200 A400 A700" }, "light-blue": { 50: "#e1f5fe", 100: "#b3e5fc", 200: "#81d4fa", 300: "#4fc3f7", 400: "#29b6f6", 500: "#03a9f4", 600: "#039be5", 700: "#0288d1", 800: "#0277bd", 900: "#01579b", A100: "#80d8ff", A200: "#40c4ff", A400: "#00b0ff", A700: "#0091ea", contrastDefaultColor: "dark", contrastLightColors: "600 700 800 900 A700", contrastStrongLightColors: "600 700 800 A700" }, cyan: { 50: "#e0f7fa", 100: "#b2ebf2", 200: "#80deea", 300: "#4dd0e1", 400: "#26c6da", 500: "#00bcd4", 600: "#00acc1", 700: "#0097a7", 800: "#00838f", 900: "#006064", A100: "#84ffff", A200: "#18ffff", A400: "#00e5ff", A700: "#00b8d4", contrastDefaultColor: "dark", contrastLightColors: "700 800 900", contrastStrongLightColors: "700 800 900" }, teal: { 50: "#e0f2f1", 100: "#b2dfdb", 200: "#80cbc4", 300: "#4db6ac", 400: "#26a69a", 500: "#009688", 600: "#00897b", 700: "#00796b", 800: "#00695c", 900: "#004d40", A100: "#a7ffeb", A200: "#64ffda", A400: "#1de9b6", A700: "#00bfa5", contrastDefaultColor: "dark", contrastLightColors: "500 600 700 800 900", contrastStrongLightColors: "500 600 700" }, green: { 50: "#e8f5e9", 100: "#c8e6c9", 200: "#a5d6a7", 300: "#81c784", 400: "#66bb6a", 500: "#4caf50", 600: "#43a047", 700: "#388e3c", 800: "#2e7d32", 900: "#1b5e20", A100: "#b9f6ca", A200: "#69f0ae", A400: "#00e676", A700: "#00c853", contrastDefaultColor: "dark", contrastLightColors: "500 600 700 800 900", contrastStrongLightColors: "500 600 700" }, "light-green": { 50: "#f1f8e9", 100: "#dcedc8", 200: "#c5e1a5", 300: "#aed581", 400: "#9ccc65", 500: "#8bc34a", 600: "#7cb342", 700: "#689f38", 800: "#558b2f", 900: "#33691e", A100: "#ccff90", A200: "#b2ff59", A400: "#76ff03", A700: "#64dd17", contrastDefaultColor: "dark", contrastLightColors: "700 800 900", contrastStrongLightColors: "700 800 900" }, lime: { 50: "#f9fbe7", 100: "#f0f4c3", 200: "#e6ee9c", 300: "#dce775", 400: "#d4e157", 500: "#cddc39", 600: "#c0ca33", 700: "#afb42b", 800: "#9e9d24", 900: "#827717", A100: "#f4ff81", A200: "#eeff41", A400: "#c6ff00", A700: "#aeea00", contrastDefaultColor: "dark", contrastLightColors: "900", contrastStrongLightColors: "900" }, yellow: { 50: "#fffde7", 100: "#fff9c4", 200: "#fff59d", 300: "#fff176", 400: "#ffee58", 500: "#ffeb3b", 600: "#fdd835", 700: "#fbc02d", 800: "#f9a825", 900: "#f57f17", A100: "#ffff8d", A200: "#ffff00", A400: "#ffea00", A700: "#ffd600", contrastDefaultColor: "dark" }, amber: { 50: "#fff8e1", 100: "#ffecb3", 200: "#ffe082", 300: "#ffd54f", 400: "#ffca28", 500: "#ffc107", 600: "#ffb300", 700: "#ffa000", 800: "#ff8f00", 900: "#ff6f00", A100: "#ffe57f", A200: "#ffd740", A400: "#ffc400", A700: "#ffab00", contrastDefaultColor: "dark" }, orange: { 50: "#fff3e0", 100: "#ffe0b2", 200: "#ffcc80", 300: "#ffb74d", 400: "#ffa726", 500: "#ff9800", 600: "#fb8c00", 700: "#f57c00", 800: "#ef6c00", 900: "#e65100", A100: "#ffd180", A200: "#ffab40", A400: "#ff9100", A700: "#ff6d00", contrastDefaultColor: "dark", contrastLightColors: "800 900", contrastStrongLightColors: "800 900" }, "deep-orange": { 50: "#fbe9e7", 100: "#ffccbc", 200: "#ffab91", 300: "#ff8a65", 400: "#ff7043", 500: "#ff5722", 600: "#f4511e", 700: "#e64a19", 800: "#d84315", 900: "#bf360c", A100: "#ff9e80", A200: "#ff6e40", A400: "#ff3d00", A700: "#dd2c00", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 300 400 A100 A200", contrastStrongLightColors: "500 600 700 800 900 A400 A700" }, brown: { 50: "#efebe9", 100: "#d7ccc8", 200: "#bcaaa4", 300: "#a1887f", 400: "#8d6e63", 500: "#795548", 600: "#6d4c41", 700: "#5d4037", 800: "#4e342e", 900: "#3e2723", A100: "#d7ccc8", A200: "#bcaaa4", A400: "#8d6e63", A700: "#5d4037", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 A100 A200", contrastStrongLightColors: "300 400" }, grey: { 50: "#fafafa", 100: "#f5f5f5", 200: "#eeeeee", 300: "#e0e0e0", 400: "#bdbdbd", 500: "#9e9e9e", 600: "#757575", 700: "#616161", 800: "#424242", 900: "#212121", A100: "#ffffff", A200: "#000000", A400: "#303030", A700: "#616161", contrastDefaultColor: "dark", contrastLightColors: "600 700 800 900 A200 A400 A700" }, "blue-grey": { 50: "#eceff1", 100: "#cfd8dc", 200: "#b0bec5", 300: "#90a4ae", 400: "#78909c", 500: "#607d8b", 600: "#546e7a", 700: "#455a64", 800: "#37474f", 900: "#263238", A100: "#cfd8dc", A200: "#b0bec5", A400: "#78909c", A700: "#455a64", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 300 A100 A200", contrastStrongLightColors: "400 500 700" } }),
        function($) {
            function e(e) { var t = !!document.querySelector("[md-themes-disabled]");
                e.disableTheming(t) }
            e.$inject = ["$mdThemingProvider"], n.$inject = ["$mdTheming", "$interpolate", "$parse", "$mdUtil", "$q", "$log"], i.$inject = ["$mdTheming"], t.$inject = ["$mdColorPalette", "$$mdMetaProvider"], o.$inject = ["$injector", "$mdTheming"], $.module("material.core.theming", ["material.core.theming.palette", "material.core.meta"]).directive("mdTheme", n).directive("mdThemable", i).directive("mdThemesDisabled", function() { return y.disableTheming = !0, { restrict: "A", priority: "900" } }).provider("$mdTheming", t).config(e).run(o); var m, l = {},
                s = { name: "dark", 1: "rgba(0,0,0,0.87)", 2: "rgba(0,0,0,0.54)", 3: "rgba(0,0,0,0.38)", 4: "rgba(0,0,0,0.12)" },
                p = { name: "light", 1: "rgba(255,255,255,1.0)", 2: "rgba(255,255,255,0.7)", 3: "rgba(255,255,255,0.5)", 4: "rgba(255,255,255,0.12)" },
                h = "1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)",
                f = "",
                c = E("rgba(0,0,0,0.87)"),
                d = E("rgba(255,255,255,0.87)"),
                u = E("rgb(255,255,255)"),
                g = ["primary", "accent", "warn", "background"],
                r = "primary",
                v = { accent: { default: "A200", "hue-1": "A100", "hue-2": "A400", "hue-3": "A700" }, background: { default: "50", "hue-1": "A100", "hue-2": "100", "hue-3": "300" } },
                b = { background: { default: "A400", "hue-1": "800", "hue-2": "900", "hue-3": "A200" } };
            g.forEach(function(e) { var t = { default: "500", "hue-1": "300", "hue-2": "800", "hue-3": "A100" };
                v[e] || (v[e] = t), b[e] || (b[e] = t) }); var C = ["50", "100", "200", "300", "400", "500", "600", "700", "800", "900", "A100", "A200", "A400", "A700"],
                y = { disableTheming: !1, generateOnDemand: !1, registeredStyles: [], nonce: null };

            function t(e, l) { a.$inject = ["$rootScope", "$mdUtil", "$q", "$log"]; var n, c = {},
                    d = !(m = {}),
                    u = "default";
                $.extend(m, e); var t = function(e) { var t, n, i, o = (e = $.isObject(e) ? e : {}).theme || "default",
                        r = e.hue || "800",
                        a = m[e.palette] || m[c[o].colors[e.palette || "primary"].name],
                        s = $.isObject(a[r]) ? a[r].hex : a[r]; return t = s, n = l.setMeta("theme-color", t), i = l.setMeta("msapplication-navbutton-color", t),
                        function() { n(), i() } }; return n = { definePalette: function(e, t) { return t = t || {}, m[e] = i(e, t), n }, extendPalette: function(e, t) { return i(e, $.extend({}, m[e] || {}, t)) }, theme: r, configuration: function() { return $.extend({}, y, { defaultTheme: u, alwaysWatchTheme: d, registeredStyles: [].concat(y.registeredStyles) }) }, disableTheming: function(e) { y.disableTheming = $.isUndefined(e) || !!e }, registerStyles: function(e) { y.registeredStyles.push(e) }, setNonce: function(e) { y.nonce = e }, generateThemesOnDemand: function(e) { y.generateOnDemand = e }, setDefaultTheme: function(e) { u = e }, alwaysWatchTheme: function(e) { d = e }, enableBrowserColor: t, $get: a, _LIGHT_DEFAULT_HUES: v, _DARK_DEFAULT_HUES: b, _PALETTES: m, _THEMES: c, _parseRules: x, _rgba: A };

                function i(e, t) { var n = C.filter(function(e) { return !t[e] }); if (n.length) throw new Error("Missing colors %1 in palette %2!".replace("%1", n.join(", ")).replace("%2", e)); return t }

                function r(e, t) { if (c[e]) return c[e]; var n = "string" == typeof(t = t || "default") ? c[t] : t,
                        i = new o(e); return n && $.forEach(n.colors, function(e, t) { i.colors[t] = { name: e.name, hues: $.extend({}, e.hues) } }), c[e] = i }

                function o(e) { var a = this;

                    function t(e) { if ((e = 0 === arguments.length || !!e) !== a.isDark) { a.isDark = e, a.foregroundPalette = a.isDark ? p : s, a.foregroundShadow = a.isDark ? h : f; var t = a.isDark ? b : v,
                                r = a.isDark ? v : b; return $.forEach(t, function(e, t) { var n = a.colors[t],
                                    i = r[t]; if (n)
                                    for (var o in n.hues) n.hues[o] === i[o] && (n.hues[o] = e[o]) }), a } }
                    a.name = e, a.colors = {}, (a.dark = t)(!1), g.forEach(function(i) { var o = (a.isDark ? b : v)[i];
                        a[i + "Palette"] = function(t, e) { var n = a.colors[i] = { name: t, hues: $.extend({}, o, e) }; return Object.keys(n.hues).forEach(function(e) { if (!o[e]) throw new Error("Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4".replace("%1", e).replace("%2", a.name).replace("%3", t).replace("%4", Object.keys(o).join(", "))) }), Object.keys(n.hues).map(function(e) { return n.hues[e] }).forEach(function(e) { if (-1 == C.indexOf(e)) throw new Error("Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5".replace("%1", e).replace("%2", a.name).replace("%3", i).replace("%4", t).replace("%5", C.join(", "))) }), a }, a[i + "Color"] = function() { var e = Array.prototype.slice.call(arguments); return console.warn("$mdThemingProviderTheme." + i + "Color() has been deprecated. Use $mdThemingProviderTheme." + i + "Palette() instead."), a[i + "Palette"].Apply(a, e) } }) }

                function a(n, a, i, s) { var o = function(e, t) { t === le && (t = e, e = le), e === le && (e = n), o.inherit(t, t) }; return Object.defineProperty(o, "THEMES", { get: function() { return $.extend({}, c) } }), Object.defineProperty(o, "PALETTES", { get: function() { return $.extend({}, m) } }), Object.defineProperty(o, "ALWAYS_WATCH", { get: function() { return d } }), o.inherit = function(n, e) { var i = e.controller("mdTheme") || n.data("$mdThemeController"); if (r(i && i.$mdTheme || ("default" == u ? "" : u)), i) var t = d || i.$shouldWatch || a.parseAttributeBoolean(n.attr("md-theme-watch")),
                            o = i.registerChanges(function(e) { r(e), t ? n.on("$destroy", o) : o() });

                        function r(e) { if (e) { l(e) || s.warn("Attempted to use unregistered theme '" + e + "'. Register it with $mdThemingProvider.theme()."); var t = n.data("$mdThemeName");
                                t && n.removeClass("md-" + t + "-theme"), n.addClass("md-" + e + "-theme"), n.data("$mdThemeName", e), i && n.data("$mdThemeController", i) } } }, o.registered = l, o.defaultTheme = function() { return u }, o.generateTheme = function(e) { T(c[e], e, y.nonce) }, o.defineTheme = function(e, t) { t = t || {}; var n = r(e); return t.primary && n.primaryPalette(t.primary), t.accent && n.accentPalette(t.accent), t.warn && n.warnPalette(t.warn), t.background && n.backgroundPalette(t.background), t.dark && n.dark(), this.generateTheme(e), i.resolve(e) }, o.setBrowserColor = t, o;

                    function l(e) { return e === le || "" === e || o.THEMES[e] !== le } } }

            function n(p, h, f, g, v, b) { return { priority: 101, link: { pre: function(t, e, n) { var i = [],
                                o = h.startSymbol(),
                                r = h.endSymbol(),
                                a = n.mdTheme.trim(),
                                s = a.substr(0, o.length) === o && a.lastIndexOf(r) === a.length - r.length,
                                l = "::" === n.mdTheme.split(o).join("").split(r).join("").trim().substr(0, "::".length),
                                c = { registerChanges: function(t, e) { return e && (t = $.bind(e, t)), i.push(t),
                                            function() { var e = i.indexOf(t); - 1 < e && i.splice(e, 1) } }, $setTheme: function(e) { p.registered(e) || b.warn("attempted to use unregistered theme '" + e + "'"), c.$mdTheme = e; for (var t = i.length; t--;) i[t](e) }, $shouldWatch: g.parseAttributeBoolean(e.attr("md-theme-watch")) || p.ALWAYS_WATCH || s && !l };
                            e.data("$mdThemeController", c);

                            function d() { var e = h(n.mdTheme)(t); return f(e)(t) || e }

                            function u(e) { if ("string" == typeof e) return c.$setTheme(e);
                                v.when($.isFunction(e) ? e() : e).then(function(e) { c.$setTheme(e) }) }
                            u(d()); var m = t.$watch(d, function(e) { e && (u(e), c.$shouldWatch || m()) }) } } } }

            function i(e) { return e }

            function x(a, e, n) {! function(e, t) { if (!m[(e.colors[t] || {}).name]) throw new Error("You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3".replace("%1", e.name).replace("%2", t).replace("%3", Object.keys(m).join(", "))) }(a, e), n = n.replace(/THEME_NAME/g, a.name); var i = [],
                    t = a.colors[e],
                    o = new RegExp("\\.md-" + a.name + "-theme", "g"),
                    s = new RegExp("('|\")?{{\\s*(" + e + ")-(color|contrast)-?(\\d\\.?\\d*)?\\s*}}(\"|')?", "g"),
                    l = m[t.name]; return n = n.replace(/'?"?\{\{\s*([a-zA-Z]+)-(A?\d+|hue\-[0-3]|shadow|default)-?(\d\.?\d*)?(contrast)?\s*\}\}'?"?/g, function(e, t, n, i, o) { return "foreground" === t ? "shadow" == n ? a.foregroundShadow : a.foregroundPalette[n] || a.foregroundPalette[1] : (0 !== n.indexOf("hue") && "default" !== n || (n = a.colors[t].hues[n]), A((m[a.colors[t].name][n] || "")[o ? "contrast" : "value"], i)) }), $.forEach(t.hues, function(r, e) { var t = n.replace(s, function(e, t, n, i, o) { return A(l[r]["color" === i ? "value" : "contrast"], o) }); if ("default" !== e && (t = t.replace(o, ".md-" + a.name + "-theme.md-" + e)), "default" == a.name) { t = t.replace(/((?:\s|>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)\.md-default-theme((?:\s|>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)/g, function(e, t, n) { return e + ", " + t + n }) }
                    i.push(t) }), i } var w = {};

            function o(e, t) { var n = document.head; if ((n ? n.firstElementChild : null) && 0 !== "".length) { $.forEach(m, function(i, e) { var o = i.contrastDefaultColor,
                            r = i.contrastLightColors || [],
                            a = i.contrastStrongLightColors || [],
                            s = i.contrastDarkColors || []; "string" == typeof r && (r = r.split(" ")); "string" == typeof a && (a = a.split(" ")); "string" == typeof s && (s = s.split(" "));
                        delete i.contrastDefaultColor, delete i.contrastLightColors, delete i.contrastStrongLightColors, delete i.contrastDarkColors, $.forEach(i, function(e, t) { if (!$.isObject(e)) { var n = E(e); if (!n) throw new Error("Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected.".replace("%1", e).replace("%2", i.name).replace("%3", t));
                                i[t] = { hex: i[t], value: n, contrast: "light" === o ? -1 < s.indexOf(t) ? c : -1 < a.indexOf(t) ? u : d : -1 < r.indexOf(t) ? -1 < a.indexOf(t) ? u : d : c } } }) }); var i = "".split(/\}(?!(\}|'|"|;))/).filter(function(e) { return e && e.trim().length }).map(function(e) { return e.trim() + "}" }),
                        o = new RegExp("md-(" + g.join("|") + ")", "g");
                    g.forEach(function(e) { w[e] = "" }), i.forEach(function(e) { e.match(o); for (var t, n = 0; t = g[n]; n++)
                            if (-1 < e.indexOf(".md-" + t)) return w[t] += e;
                        for (n = 0; t = g[n]; n++)
                            if (-1 < e.indexOf(t)) return w[t] += e;
                        return w[r] += e }), y.generateOnDemand || $.forEach(t.THEMES, function(e) { l[e.name] || "default" !== t.defaultTheme() && "default" === e.name || T(e, e.name, y.nonce) }) } }

            function T(o, e, r) { var a = document.head,
                    s = a ? a.firstElementChild : null;
                l[e] || (g.forEach(function(e) { for (var t = x(o, e, w[e]); t.length;) { var n = t.shift(); if (n) { var i = document.createElement("style");
                            i.setAttribute("data-md-theme-style", ""), r && i.setAttribute("nonce", r), i.appendChild(document.createTextNode(n)), a.insertBefore(i, s) } } }), l[o.name] = !0) }

            function E(e) { if ($.isArray(e) && 3 == e.length) return e; if (/^rgb/.test(e)) return e.replace(/(^\s*rgba?\(|\)\s*$)/g, "").split(",").map(function(e, t) { return 3 == t ? parseFloat(e, 10) : parseInt(e, 10) }); if ("#" == e.charAt(0) && (e = e.substring(1)), /^([a-fA-F0-9]{3}){1,2}$/g.test(e)) { var t = e.length / 3,
                        n = e.substr(0, t),
                        i = e.substr(t, t),
                        o = e.substr(2 * t); return 1 == t && (n += n, i += i, o += o), [parseInt(n, 16), parseInt(i, 16), parseInt(o, 16)] } }

            function A(e, t) { return e ? (4 == e.length && (e = $.copy(e), t ? e.pop() : t = e.pop()), t && ("number" == typeof t || "string" == typeof t && t.length) ? "rgba(" + e.join(",") + "," + t + ")" : "rgb(" + e.join(",") + ")") : "rgb('0,0,0')" } }(j.angular), se.module("material.core").factory("$$mdAnimate", ["$q", "$timeout", "$mdConstant", "$animateCss", function(i, o, a, s) { return function(e) { return n = e, t = i, l = o, c = a, r = s, d = { translate3d: function(t, n, e, i) { return r(t, { from: n, to: e, addClass: i.transitionInClass, removeClass: i.transitionOutClass, duration: i.duration }).start().then(function() { return o });

                        function o(e) { return r(t, { to: e || n, addClass: i.transitionOutClass, removeClass: i.transitionInClass, duration: i.duration }).start() } }, waitTransitionEnd: function(r, a) { var s = 3e3; return t(function(t, e) { var n; "0s" != (n = (n = (a = a || {}).cachedTransitionStyles) || j.getComputedStyle(r[0])).transitionDuration && (n.transition || n.transitionProperty) || (s = 0); var i = l(o, a.timeout || s);

                            function o(e) { e && e.target !== r[0] || (e && l.cancel(i), r.off(c.CSS.TRANSITIONEND, o), t()) }
                            r.on(c.CSS.TRANSITIONEND, o) }) }, calculateTransformValues: function(e, t) { var n, i, o = t.element,
                            r = t.bounds; if (o || r) { var a = o ? d.clientRect(o) || (n = e ? e.parent() : null, (i = n ? n.parent() : null) ? d.clientRect(i) : null) : d.copyRect(r),
                                s = d.copyRect(e[0].getBoundingClientRect()),
                                l = d.centerPointFor(s),
                                c = d.centerPointFor(a); return { centerX: c.x - l.x, centerY: c.y - l.y, scaleX: Math.round(100 * Math.min(.5, a.width / s.width)) / 100, scaleY: Math.round(100 * Math.min(.5, a.height / s.height)) / 100 } } return { centerX: 0, centerY: 0, scaleX: .5, scaleY: .5 } }, calculateZoomToOrigin: function(e, t) { return se.bind(null, n.supplant, "translate3d( {centerX}px, {centerY}px, 0 ) scale( {scaleX}, {scaleY} )")(d.calculateTransformValues(e, t)) }, calculateSlideToOrigin: function(e, t) { return se.bind(null, n.supplant, "translate3d( {centerX}px, {centerY}px, 0 )")(d.calculateTransformValues(e, t)) }, toCss: function(e) { var i = {}; return se.forEach(e, function(e, t) { if (!se.isUndefined(e))
                                if (0 <= "left top right bottom width height x y min-width min-height max-width max-height".indexOf(t)) i[t] = e + "px";
                                else switch (t) {
                                    case "transition":
                                        n(0, c.CSS.TRANSITION, e); break;
                                    case "transform":
                                        n(0, c.CSS.TRANSFORM, e); break;
                                    case "transformOrigin":
                                        n(0, c.CSS.TRANSFORM_ORIGIN, e); break;
                                    case "font-size":
                                        i["font-size"] = e } }), i;

                        function n(e, t, n) { se.forEach(t.split(" "), function(e) { i[e] = n }) } }, toTransformCss: function(t, e, n) { var i = {}; return se.forEach(c.CSS.TRANSFORM.split(" "), function(e) { i[e] = t }), e && (n = n || "all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) !important", i.transition = n), i }, copyRect: function(t, n) { return t ? (n = n || {}, se.forEach("left top right bottom width height".split(" "), function(e) { n[e] = Math.round(t[e]) }), n.width = n.width || n.right - n.left, n.height = n.height || n.bottom - n.top, n) : null }, clientRect: function(e) { var t, n = se.element(e)[0].getBoundingClientRect(); return (t = n) && 0 < t.width && 0 < t.height ? d.copyRect(n) : null }, centerPointFor: function(e) { return e ? { x: Math.round(e.left + e.width / 2), y: Math.round(e.top + e.height / 2) } : { x: 0, y: 0 } } }; var n, t, l, c, r, d } }]), 4 <= se.version.minor ? se.module("material.core.animate", []) : (N = se.forEach, F = se.isDefined(document.documentElement.style.WebkitAppearance), B = F ? "-webkit-" : "", U = (F ? "webkitTransitionEnd " : "") + "transitionend", q = (F ? "webkitAnimationEnd " : "") + "animationend", H = ["$q", "$$rAFMutex", function(t, n) {
            function e(e) { this.setHost(e), this._doneCallbacks = [], this._runInAnimationFrame = n(), this._state = 0 } return e.prototype = { setHost: function(e) { this.host = e || {} }, done: function(e) { 2 === this._state ? e() : this._doneCallbacks.push(e) }, progress: se.noop, getPromise: function() { if (!this.promise) { var e = this;
                        this.promise = t(function(t, n) { e.done(function(e) {!1 === e ? n() : t() }) }) } return this.promise }, then: function(e, t) { return this.getPromise().then(e, t) }, catch: function(e) { return this.getPromise().catch(e) }, finally: function(e) { return this.getPromise().finally(e) }, pause: function() { this.host.pause && this.host.pause() }, resume: function() { this.host.resume && this.host.resume() }, end: function() { this.host.end && this.host.end(), this._resolve(!0) }, cancel: function() { this.host.cancel && this.host.cancel(), this._resolve(!1) }, complete: function(e) { var t = this;
                    0 === t._state && (t._state = 1, t._runInAnimationFrame(function() { t._resolve(e) })) }, _resolve: function(t) { 2 !== this._state && (N(this._doneCallbacks, function(e) { e(t) }), this._doneCallbacks.length = 0, this._state = 2) } }, e.all = function(t, n) { var i = 0,
                    o = !0;

                function r(e) { o = o && e, ++i === t.length && n(o) }
                N(t, function(e) { e.done(r) }) }, e }], se.module("material.core.animate", []).factory("$$forceReflow", ["$document", function(e) { return function() { return e[0].body.clientWidth + 1 } }]).factory("$$AnimateRunner", H).factory("$$rAFMutex", ["$$rAF", function(n) { return function() { var t = !1; return n(function() { t = !0 }),
                    function(e) { t ? e() : n(e) } } }]).factory("$animateCss", ["$window", "$$rAF", "$$AnimateRunner", "$$forceReflow", "$$jqLite", "$timeout", "$animate", function(h, r, a, f, n, g, s) {
            function v(e, t) { t.addClass && (n.addClass(e, t.addClass), t.addClass = null), t.removeClass && (n.removeClass(e, t.removeClass), t.removeClass = null) }

            function b(e) { var t = 0,
                    n = (e || "").split(/\s*,\s*/); return N(n, function(e) { "s" == e.charAt(e.length - 1) && (e = e.substring(0, e.length - 1)), e = parseFloat(e) || 0, t = t ? Math.max(e, t) : e }), t } var $, C = [];

            function y(e, t) { t.from && (e.css(t.from), t.from = null) }

            function x(e, t) { t.to && (e.css(t.to), t.to = null) }

            function w(e) { for (var t = 0; t < e.length; t++)
                    if (1 === e[t].nodeType) return e[t] }

            function T(e, t) { var n = w(e),
                    i = X(B + "transition-delay");
                n.style[i] = t ? "-9999s" : "" } return function(i, l) { var c = [],
                    d = w(i),
                    e = d && s.enabled(),
                    t = !1,
                    n = !1;
                e && (l.transitionStyle && c.push([B + "transition", l.transitionStyle]), l.keyframeStyle && c.push([B + "animation", l.keyframeStyle]), l.delay && c.push([B + "transition-delay", l.delay + "s"]), l.duration && c.push([B + "transition-duration", l.duration + "s"]), t = l.keyframeStyle || l.to && (0 < l.duration || l.transitionStyle), n = !!l.addClass || !!l.removeClass, T(i, !0)); var u = e && (t || n);
                y(i, l); var m, p, o = !1; return { close: h.close, start: function() { var n = new a; return function(e) { $ && $();
                            C.push(e), $ = r(function() { $ = null; for (var e = f(), t = 0; t < C.length; t++) C[t](e);
                                C.length = 0 }) }(function() { if (T(i, !1), !u) return s();
                            N(c, function(e) { var t = e[0],
                                    n = e[1];
                                d.style[X(t)] = n }), v(i, l); var e = function(e) { var t = w(e),
                                    n = h.getComputedStyle(t),
                                    i = b(n[c("transitionDuration")]),
                                    o = b(n[c("animationDuration")]),
                                    r = b(n[c("transitionDelay")]),
                                    a = b(n[c("animationDelay")]);
                                o *= parseInt(n[c("animationIterationCount")], 10) || 1; var s = Math.max(o, i),
                                    l = Math.max(a, r); return { duration: s, delay: l, animationDuration: o, transitionDuration: i, animationDelay: a, transitionDelay: r };

                                function c(e) { return F ? "Webkit" + e.charAt(0).toUpperCase() + e.substr(1) : e } }(i); if (0 === e.duration) return s(); var t = [];
                            l.easing && (e.transitionDuration && t.push([B + "transition-timing-function", l.easing]), e.animationDuration && t.push([B + "animation-timing-function", l.easing])), l.delay && e.animationDelay && t.push([B + "animation-delay", l.delay + "s"]), l.duration && e.animationDuration && t.push([B + "animation-duration", l.duration + "s"]), N(t, function(e) { var t = e[0],
                                    n = e[1];
                                d.style[X(t)] = n, c.push(e) }); var o = 1e3 * e.delay,
                                r = e.duration,
                                n = 1e3 * r,
                                a = Date.now();
                            m = [], e.transitionDuration && m.push(U), e.animationDuration && m.push(q), m = m.join(" "), p = function(e) { e.stopPropagation(); var t = e.originalEvent || e,
                                    n = t.timeStamp || Date.now(),
                                    i = parseFloat(t.elapsedTime.toFixed(3));
                                Math.max(n - a, 0) >= o && r <= i && s() }, i.on(m, p), x(i, l), g(s, o + 1.5 * n, !1) }), n;

                        function s() { var e, t; if (!o) return o = !0, m && p && i.off(m, p), v(i, l), y(e = i, t = l), x(e, t), N(c, function(e) { d.style[X(e[0])] = "" }), n.complete(!0), n } } } } }])), se.module("material.components.autocomplete", ["material.core", "material.components.icon", "material.components.virtualRepeat"]), se.module("material.components.backdrop", ["material.core"]).directive("mdBackdrop", ["$mdTheming", "$mdUtil", "$animate", "$rootElement", "$window", "$log", "$$rAF", "$document", function(a, s, t, l, c, d, u, m) { return { restrict: "E", link: function(n, i, e) { t.pin && t.pin(i, l); var o;

                    function r() { var e = parseInt(o.height, 10) + Math.abs(parseInt(o.top, 10));
                        i.css("height", e + "px") }
                    u(function() { if ("fixed" === (o = c.getComputedStyle(m[0].body)).position) { var e = s.debounce(function() { o = c.getComputedStyle(m[0].body), r() }, 60, null, !1);
                            r(), se.element(c).on("resize", e), n.$on("$destroy", function() { se.element(c).off("resize", e) }) } var t = i.parent();
                        t.length && ("BODY" === t[0].nodeName && i.css("position", "fixed"), "static" === c.getComputedStyle(t[0]).position && d.warn("<md-backdrop> may not work properly in a scrolled, static-positioned parent container."), a.inherit(i, t)) }) } } }]), Q.$inject = ["$mdBottomSheet"], Z.$inject = ["$$interimElementProvider"], se.module("material.components.bottomSheet", ["material.core", "material.components.backdrop"]).directive("mdBottomSheet", Q).provider("$mdBottomSheet", Z), ee.$inject = ["$mdButtonInkRipple", "$mdTheming", "$mdAria", "$mdInteraction"], J.$inject = ["$mdTheming"], se.module("material.components.button", ["material.core"]).directive("mdButton", ee).directive("a", J), te.$inject = ["$mdTheming"], se.module("material.components.card", ["material.core"]).directive("mdCard", te), ne.$inject = ["inputDirective", "$mdAria", "$mdConstant", "$mdTheming", "$mdUtil", "$mdInteraction"], se.module("material.components.checkbox", ["material.core"]).directive("mdCheckbox", ne), se.module("material.components.chips", ["material.core", "material.components.autocomplete"]),
        function() { t.$inject = ["$mdColors", "$mdUtil", "$log", "$parse"], e.$inject = ["$mdTheming", "$mdUtil", "$log"]; var a = /^{((\s|,)*?["'a-zA-Z-]+?\s*?:\s*?('|")[a-zA-Z0-9-.]*('|"))+\s*}$/,
                c = null;

            function e(r, a, n) { return c = c || Object.keys(r.PALETTES), { ApplyThemeColors: function(e, t) { try { t && e.css(function(e) { var o = {},
                                    r = e.hasOwnProperty("color"); return se.forEach(e, function(e, t) { var n = l(e),
                                        i = -1 < t.indexOf("background");
                                    o[t] = s(n), i && !r && (o.color = s(n, !0)) }), o }(t)) } catch (e) { n.error(e.message) } }, getThemeColor: function(e) { return s(l(e)) }, hasTheme: function(e) { return se.isDefined(r.THEMES[e.split("-")[0]]) } };

                function s(e, t) { t = t || !1; var n = r.PALETTES[e.palette][e.hue]; return n = t ? n.contrast : n.value, a.supplant("rgba({0}, {1}, {2}, {3})", [n[0], n[1], n[2], n[3] || e.opacity]) }

                function l(e) { var t = e.split("-"),
                        n = se.isDefined(r.THEMES[t[0]]) ? t.splice(0, 1)[0] : r.defaultTheme(); return { theme: n, palette: function(e, t) { var n = 1 < e.length && -1 !== c.indexOf(e[1]),
                                i = e[0].replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
                            n && (i = e[0] + "-" + e.splice(1, 1)); if (-1 === c.indexOf(i)) { var o = r.THEMES[t].colors[i]; if (!o) throw new Error(a.supplant("mdColors: couldn't find '{palette}' in the palettes.", { palette: i }));
                                i = o.name } return i }(t, n), hue: function(e, t) { var n = r.THEMES[t].colors; if ("hue" !== e[1]) return e[1] || n[e[0] in n ? e[0] : "primary"].hues.default; var i = parseInt(e.splice(2, 1)[0], 10); if (i < 1 || 3 < i) throw new Error(a.supplant("mdColors: 'hue-{hueNumber}' is not a valid hue, can be only 'hue-1', 'hue-2' and 'hue-3'", { hueNumber: i })); if (e[1] = "hue-" + i, e[0] in n) return n[e[0]].hues[e[1]]; throw new Error(a.supplant("mdColors: 'hue-x' can only be used with [{availableThemes}], but was used with '{usedTheme}'", { availableThemes: Object.keys(n).join(", "), usedTheme: e[0] })) }(t, n), opacity: t[2] || 1 } } }

            function t(d, r, u, m) { return { restrict: "A", require: ["^?mdTheme"], compile: function(e, o) { var c = function() { var e = o.mdColors,
                                t = -1 < e.indexOf("::"),
                                n = t || a.test(o.mdColors);
                            o.mdColors = e.replace("::", ""); var i = se.isDefined(o.mdColorsWatch); return !t && !n && (!i || r.parseAttributeBoolean(o.mdColorsWatch)) }(); return function(e, n, t, i) {
                            function o(n) { "string" != typeof n && (n = ""), t.mdColors || (t.mdColors = "{}"); var i = m(t.mdColors)(e); return r && Object.keys(i).forEach(function(e) { var t = i[e];
                                    d.hasTheme(t) || (i[e] = (n || r.$mdTheme) + "-" + t) }), s(i), i } var r = i[0],
                                a = {},
                                s = function(e) { if (!se.equals(e, a)) { var t = Object.keys(a);
                                        a.background && !t.color && t.push("color"), t.forEach(function(e) { n.css(e, "") }) }
                                    a = e },
                                l = se.noop;
                            r && (l = r.registerChanges(function(e) { d.ApplyThemeColors(n, o(e)) })), e.$on("$destroy", function() { l() }); try { c ? e.$watch(o, se.bind(this, d.ApplyThemeColors, n), !0) : d.ApplyThemeColors(n, o()) } catch (e) { u.error(e.message) } } } } }
            se.module("material.components.colors", ["material.core"]).directive("mdColors", t).service("$mdColors", e) }(), ie.$inject = ["$mdTheming"], se.module("material.components.content", ["material.core"]).directive("mdContent", ie), se.module("material.components.datepicker", ["material.core", "material.components.icon", "material.components.virtualRepeat"]), oe.$inject = ["$$rAF", "$mdTheming", "$mdDialog"], re.$inject = ["$$interimElementProvider"], se.module("material.components.dialog", ["material.core", "material.components.backdrop"]).directive("mdDialog", oe).provider("$mdDialog", re), ae.$inject = ["$mdTheming"], se.module("material.components.divider", ["material.core"]).directive("mdDivider", ae), ce.$inject = ["$mdUtil"], se.module("material.components.fabActions", ["material.core"]).directive("mdFabActions", ce), de.$inject = ["$scope", "$element", "$animate", "$mdUtil", "$mdConstant", "$timeout"], se.module("material.components.fabShared", ["material.core"]).controller("MdFabController", de),
        function() { e.$inject = ["$timeout"], t.$inject = ["$timeout"]; var n = 300;

            function e(t) {
                function i(e) { t(e, n, !1) }

                function o(e) { if (!e.hasClass("md-animations-waiting") || e.hasClass("_md-animations-ready")) { var t = e[0],
                            l = e.controller("mdFabSpeedDial"),
                            i = t.querySelectorAll(".md-fab-action-item"),
                            c = t.querySelector("md-fab-trigger"),
                            n = t.querySelector("._md-css-variables"),
                            o = parseInt(j.getComputedStyle(n).zIndex);
                        se.forEach(i, function(e, t) { var n = e.style;
                            n.transform = n.webkitTransform = "", n.transitionDelay = "", n.opacity = 1, n.zIndex = i.length - t + o }), c.style.zIndex = o + i.length + 1, l.isOpen || se.forEach(i, function(e, t) { var n, i, o = e.style,
                                r = (c.clientHeight - e.clientHeight) / 2,
                                a = (c.clientWidth - e.clientWidth) / 2; switch (l.direction) {
                                case "up":
                                    n = e.scrollHeight * (t + 1) + r, i = "Y"; break;
                                case "down":
                                    n = -(e.scrollHeight * (t + 1) + r), i = "Y"; break;
                                case "left":
                                    n = e.scrollWidth * (t + 1) + a, i = "X"; break;
                                case "right":
                                    n = -(e.scrollWidth * (t + 1) + a), i = "X" } var s = "translate" + i + "(" + n + "px)";
                            o.transform = o.webkitTransform = s }) } } return { addClass: function(e, t, n) { e.hasClass("md-fling") ? (o(e), i(n)) : n() }, removeClass: function(e, t, n) { o(e), i(n) } } }

            function t(t) {
                function i(e) { t(e, n, !1) }

                function o(e) { var t = e[0],
                        o = e.controller("mdFabSpeedDial"),
                        r = t.querySelectorAll(".md-fab-action-item"),
                        n = t.querySelector("._md-css-variables"),
                        a = parseInt(j.getComputedStyle(n).zIndex);
                    se.forEach(r, function(e, t) { var n = e.style,
                            i = 65 * t;
                        n.opacity = o.isOpen ? 1 : 0, n.transform = n.webkitTransform = o.isOpen ? "scale(1)" : "scale(0)", n.transitionDelay = (o.isOpen ? i : r.length - i) + "ms", n.zIndex = r.length - t + a }) } return { addClass: function(e, t, n) { o(e), i(n) }, removeClass: function(e, t, n) { o(e), i(n) } } }
            se.module("material.components.fabSpeedDial", ["material.core", "material.components.fabShared", "material.components.fabActions"]).directive("mdFabSpeedDial", function() { return { restrict: "E", scope: { direction: "@?mdDirection", isOpen: "=?mdOpen" }, bindToController: !0, controller: "MdFabController", controllerAs: "vm", link: function(e, t) { t.prepend('<div class="_md-css-variables"></div>') } } }).animation(".md-fling", e).animation(".md-scale", t).service("mdFabSpeedDialFlingAnimation", e).service("mdFabSpeedDialScaleAnimation", t) }(), se.module("material.components.fabToolbar", ["material.core", "material.components.fabShared", "material.components.fabActions"]).directive("mdFabToolbar", function() { return { restrict: "E", transclude: !0, template: '<div class="md-fab-toolbar-wrapper">  <div class="md-fab-toolbar-content" data-ng-transclude></div></div>', scope: { direction: "@?mdDirection", isOpen: "=?mdOpen" }, bindToController: !0, controller: "MdFabController", controllerAs: "vm", link: function(e, t, n) { t.addClass("md-fab-toolbar"), t.find("md-fab-trigger").find("button").prepend('<div class="md-fab-toolbar-background"></div>') } } }).animation(".md-fab-toolbar", ue).service("mdFabToolbarAnimation", ue), pe.$inject = ["$mdUtil"], he.$inject = ["$mdUtil"], me.$inject = ["$interpolate", "$mdConstant", "$mdGridLayout", "$mdMedia"], fe.$inject = ["$mdMedia"], se.module("material.components.gridList", ["material.core"]).directive("mdGridList", me).directive("mdGridTile", fe).directive("mdGridTileFooter", ge).directive("mdGridTileHeader", ge).factory("$mdGridLayout", he), pe.prototype = { invalidateTiles: function() { this.tilesInvalidated = !0, this.invalidateLayout() }, invalidateLayout: function() { this.layoutInvalidated || (this.layoutInvalidated = !0, this.$timeout_(se.bind(this, this.layout))) }, layout: function() { try { this.layoutDelegate(this.tilesInvalidated) } finally { this.layoutInvalidated = !1, this.tilesInvalidated = !1 } } }, se.module("material.components.icon", ["material.core"]),
        function() { t.$inject = ["$mdTheming", "$parse"], n.$inject = ["$mdUtil", "$window", "$mdAria", "$timeout", "$mdGesture"], i.$inject = ["$animate", "$mdUtil"], o.$inject = ["$compile"], u.$inject = ["$mdUtil"], r.$inject = ["$timeout"], m.$inject = ["$$AnimateRunner", "$animateCss", "$mdUtil", "$log"], p.$inject = ["$$AnimateRunner", "$animateCss", "$mdUtil", "$log"], h.$inject = ["$$AnimateRunner", "$animateCss", "$mdUtil", "$log"]; var e = se.module("material.components.input", ["material.core"]).directive("mdInputContainer", t).directive("label", function() { return { restrict: "E", require: "^?mdInputContainer", link: function(e, t, n, i) {!i || n.mdNoFloat || t.hasClass("md-container-ignore") || (i.label = t, e.$on("$destroy", function() { i.label = null })) } } }).directive("input", n).directive("textarea", n).directive("mdMaxlength", i).directive("placeholder", o).directive("ngMessages", function() { return { restrict: "EA", link: function(e, t, n, i) { if (!i) return;
                        t.toggleClass("md-input-messages-animation", !0), t.toggleClass("md-auto-hide", !0), "false" != n.mdAutoHide && ! function(t) { return d.some(function(e) { return t[e] }) }(n) || t.toggleClass("md-auto-hide", !1) }, require: "^^?mdInputContainer" } }).directive("ngMessage", u).directive("ngMessageExp", u).directive("mdSelectOnFocus", r).animation(".md-input-invalid", m).animation(".md-input-messages-animation", p).animation(".md-input-message-animation", h);

            function t(i, r) { t.$inject = ["$scope", "$element", "$attrs", "$animate"]; var e = ["INPUT", "TEXTAREA", "SELECT", "MD-SELECT"],
                    o = e.reduce(function(e, t) { return e.concat(["md-icon ~ " + t, ".md-icon ~ " + t]) }, []).join(","),
                    a = e.reduce(function(e, t) { return e.concat([t + " ~ md-icon", t + " ~ .md-icon"]) }, []).join(","); return { restrict: "E", compile: function(e) { var t = e[0].querySelector(o),
                            n = e[0].querySelector(a);
                        t && e.addClass("md-icon-left");
                        n && e.addClass("md-icon-right"); return function(e, t) { i(t) } }, controller: t };

                function t(e, t, n, i) { var o = this;
                    o.isErrorGetter = n.mdIsError && r(n.mdIsError), o.delegateClick = function() { o.input.focus() }, o.element = t, o.setFocused = function(e) { t.toggleClass("md-input-focused", !!e) }, o.setHasValue = function(e) { t.toggleClass("md-input-has-value", !!e) }, o.setHasPlaceholder = function(e) { t.toggleClass("md-input-has-placeholder", !!e) }, o.setInvalid = function(e) { e ? i.addClass(t, "md-input-invalid") : i.removeClass(t, "md-input-invalid") }, e.$watch(function() { return o.label && o.input }, function(e) { e && !o.label.attr("for") && o.label.attr("for", o.input.attr("id")) }) } }

            function n(g, v, b, $, C) { return { restrict: "E", require: ["^?mdInputContainer", "?ngModel", "?^form"], link: function(d, u, m, e) { var p = e[0],
                            h = !!e[1],
                            f = e[1] || g.fakeNgModel(),
                            t = e[2],
                            n = se.isDefined(m.readonly),
                            i = g.parseAttributeBoolean(m.mdNoAsterisk),
                            o = u[0].tagName.toLowerCase(); if (!p) return; { if ("hidden" === m.type) return void u.attr("aria-hidden", "true"); if (p.input) { if (p.input[0].contains(u[0])) return; throw new Error("<md-input-container> can only have *one* <input>, <textarea> or <md-select> child element!") } }
                        p.input = u, p.label && m.$observe("required", function(e) { p.label.toggleClass("md-required", e && !i) }); var r = se.element('<div class="md-errors-spacer">');
                        u.after(r); var a = se.isString(m.placeholder) ? m.placeholder.trim() : "";
                        p.label || a.length || b.expect(u, "aria-label");
                        u.addClass("md-input"), u.attr("id") || u.attr("id", "input_" + g.nextUid()); "input" === o && "number" === m.type && m.min && m.max && !m.step ? u.attr("step", "any") : "textarea" === o && function() { var t = !m.hasOwnProperty("mdNoAutogrow"); if (function() { if (m.hasOwnProperty("mdNoResize")) return; var e = se.element('<div class="md-resize-handle"></div>'),
                                        t = !1,
                                        n = 0,
                                        i = p.element,
                                        o = C.register(e, "drag", { horizontal: !1 });

                                    function r(e) { e.preventDefault(), t = !0, e.clientY, n = parseFloat(u.css("height")) || u.prop("offsetHeight") }

                                    function a(e) { t && (e.preventDefault(), c(), i.addClass("md-input-resized")) }

                                    function s(e) { t && u.css("height", n + e.pointer.distanceY + "px") }

                                    function l(e) { t && (t = !1, i.removeClass("md-input-resized")) }
                                    u.wrap('<div class="md-resize-wrapper">').after(e), e.on("mousedown", r), i.on("$md.dragstart", a).on("$md.drag", s).on("$md.dragend", l), d.$on("$destroy", function() { e.off("mousedown", r).remove(), i.off("$md.dragstart", a).off("$md.drag", s).off("$md.dragend", l), o(), o = i = e = null }) }(), !t) return; var r = m.hasOwnProperty("rows") ? parseInt(m.rows) : NaN,
                                a = m.hasOwnProperty("maxRows") ? parseInt(m.maxRows) : NaN,
                                n = d.$on("md-resize-textarea", i),
                                s = null,
                                l = u[0];
                            $(function() { g.nextTick(i) }, 10, !1), u.on("input", i), h && f.$formatters.push(o);
                            r || u.attr("rows", 1);

                            function i() { u.attr("rows", 1).css("height", "auto").addClass("md-no-flex"); var e, t, n = (e = l.offsetHeight, t = l.scrollHeight - e, e + Math.max(t, 0)); if (!s) { var i = u[0].style.padding || "";
                                    s = u.css("padding", 0).prop("offsetHeight"), u[0].style.padding = i } if (r && s && (n = Math.max(n, s * r)), a && s) { var o = s * a;
                                    o < n ? (u.attr("md-no-autogrow", ""), n = o) : u.removeAttr("md-no-autogrow") }
                                s && u.attr("rows", Math.round(n / s)), u.css("height", n + "px").removeClass("md-no-flex") }

                            function o(e) { return g.nextTick(i), e }

                            function c() { if (t && (t = !1, se.element(v).off("resize", i), n && n(), u.attr("md-no-autogrow", "").off("input", i), h)) { var e = f.$formatters.indexOf(o); - 1 < e && f.$formatters.splice(e, 1) } } if (se.element(v).on("resize", i), d.$on("$destroy", c), m.hasOwnProperty("mdDetectHidden")) { var e = function() { var t = !1; return function() { var e = 0 === l.offsetHeight;!1 == e && !0 === t && i(), t = e } }();
                                d.$watch(function() { return g.nextTick(e, !1), !0 }) } }();
                        h || c(); var s = p.isErrorGetter || function() { return f.$invalid && (f.$touched || t && t.$submitted) };
                        d.$watch(s, p.setInvalid), m.ngValue && m.$observe("value", c);
                        f.$parsers.push(l), f.$formatters.push(l), u.on("input", c), n || u.on("focus", function(e) { g.nextTick(function() { p.setFocused(!0) }) }).on("blur", function(e) { g.nextTick(function() { p.setFocused(!1), c() }) });

                        function l(e) { return p.setHasValue(!f.$isEmpty(e)), e }

                        function c() { p.setHasValue(0 < u.val().length || (u[0].validity || {}).badInput) }
                        d.$on("$destroy", function() { p.setFocused(!1), p.setHasValue(!1), p.input = null }) } } }

            function i(d, u) { return { restrict: "A", require: ["ngModel", "^mdInputContainer"], link: function(e, n, t, i) { var o, r, a, s = i[0],
                            l = i[1];

                        function c(e) { return r.parent && r.text(String(n.val() || e || "").length + " / " + o), e }
                        u.nextTick(function() { a = se.element(l.element[0].querySelector(".md-errors-spacer")), r = se.element('<div class="md-char-counter">'), a.append(r), t.$set("ngTrim", "false"), e.$watch(t.mdMaxlength, function(e) { o = e, se.isNumber(e) && 0 < e ? (r.parent().length || d.enter(r, a), c()) : d.leave(r) }), s.$validators["md-maxlength"] = function(e, t) { return !se.isNumber(o) || o < 0 || (c(), (e || n.val() || t || "").length <= o) } }) } } }

            function o(s) { return { restrict: "A", require: "^^?mdInputContainer", priority: 200, link: { pre: function(e, t, n, i) { if (!i) return; var o = i.element.find("label"),
                                r = i.element.attr("md-no-float"); if (o && o.length || "" === r || e.$eval(r)) return void i.setHasPlaceholder(!0); if ("MD-SELECT" != t[0].nodeName) { var a = se.element('<label data-ng-click="delegateClick()" tabindex="-1">' + n.placeholder + "</label>");
                                n.$set("placeholder", null), i.element.addClass("md-icon-float").prepend(a), s(a)(e) } } } } }

            function r(a) { return { restrict: "A", link: function(e, t, n) { if ("INPUT" !== t[0].nodeName && "TEXTAREA" !== t[0].nodeName) return; var i = !1;

                        function o() { a(function() { t[0].select(), i = !1 }, 1, !(i = !0)) }

                        function r(e) { i && e.preventDefault() }
                        t.on("focus", o).on("mouseup", r), e.$on("$destroy", function() { t.off("focus", o).off("mouseup", r) }) } } }
            j._mdMocksIncluded && e.service("$$mdInput", function() { return { messages: { show: f, hide: g, getElement: $ } } }).service("mdInputInvalidAnimation", m).service("mdInputMessagesAnimation", p).service("mdInputMessageAnimation", h); var a, s, l, c, d = ["ngIf", "ngShow", "ngHide", "ngSwitchWhen", "ngSwitchDefault"];

            function u(t) { return { restrict: "EA", compile: function(n) { if (i(n)) o(n);
                        else if (function() { var e = n[0]; for (; e = e.parentNode;)
                                    if (e.nodeType === Node.DOCUMENT_FRAGMENT_NODE) return !0;
                                return !1 }()) return function(e, t) { i(t) && o(n) };

                        function i(e) { return !!t.getClosest(e, "md-input-container") }

                        function o(e) { e.toggleClass("md-input-message-animation", !0) } }, priority: 100 } }

            function m(e, t, n, i) { return C(e, t, n, i), { addClass: function(e, t, n) { f(e, n) } } }

            function p(e, t, n, i) { return C(e, t, n, i), { enter: function(e, t) { f(e, t) }, leave: function(e, t) { g(e, t) }, addClass: function(e, t, n) { "data-ng-hide" == t ? g(e, n) : n() }, removeClass: function(e, t, n) { "data-ng-hide" == t ? f(e, n) : n() } } }

            function h(e, t, n, i) { return C(e, t, n, i), { enter: function(e, t) { v(e).start().done(t) }, leave: function(e, t) { b(e).start().done(t) } } }

            function f(e, t) { var n, i = [],
                    o = $(e),
                    r = o.children(); if (0 == o.length || 0 == r.length) return c.warn("mdInput messages show animation called on invalid messages element: ", e), void t();
                se.forEach(r, function(e) { n = v(se.element(e)), i.push(n.start()) }), a.all(i, t) }

            function g(e, t) { var n, i = [],
                    o = $(e),
                    r = o.children(); if (0 == o.length || 0 == r.length) return c.warn("mdInput messages hide animation called on invalid messages element: ", e), void t();
                se.forEach(r, function(e) { n = b(se.element(e)), i.push(n.start()) }), a.all(i, t) }

            function v(e) { var t = parseInt(j.getComputedStyle(e[0]).height),
                    n = parseInt(j.getComputedStyle(e[0]).marginTop),
                    i = $(e),
                    o = e.controller("mdInputContainer").element; return -t < n || i.hasClass("md-auto-hide") && !o.hasClass("md-input-invalid") ? s(e, {}) : s(e, { event: "enter", structural: !0, from: { opacity: 0, "margin-top": -t + "px" }, to: { opacity: 1, "margin-top": "0" }, duration: .3 }) }

            function b(e) { var t = e[0].offsetHeight,
                    n = j.getComputedStyle(e[0]); return 0 === parseInt(n.opacity) ? s(e, {}) : s(e, { event: "leave", structural: !0, from: { opacity: 1, "margin-top": 0 }, to: { opacity: 0, "margin-top": -t + "px" }, duration: .3 }) }

            function $(e) { return e.hasClass("md-input-messages-animation") ? e : e.hasClass("md-input-message-animation") ? se.element(l.getClosest(e, function(e) { return e.classList.contains("md-input-messages-animation") })) : se.element(e[0].querySelector(".md-input-messages-animation")) }

            function C(e, t, n, i) { a = e, s = t, l = n, c = i } }(), $e.$inject = ["$scope", "$element", "$mdListInkRipple"], ve.$inject = ["$mdTheming"], be.$inject = ["$mdAria", "$mdConstant", "$mdUtil", "$timeout"], se.module("material.components.list", ["material.core"]).controller("MdListController", $e).directive("mdList", ve).directive("mdListItem", be), se.module("material.components.menu", ["material.core", "material.components.backdrop"]), se.module("material.components.menuBar", ["material.core", "material.components.icon", "material.components.menu"]), ye.$inject = ["$element", "$scope", "$timeout", "$mdConstant"], xe.$inject = ["$mdAria", "$$rAF"], we.$inject = ["$element"], Ce.$inject = ["$mdAria", "$mdTheming"], se.module("material.components.navBar", ["material.core"]).controller("MdNavBarController", ye).directive("mdNavBar", Ce).controller("MdNavItemController", we).directive("mdNavItem", xe), ye.prototype._initTabs = function() { this._inkbar = se.element(this._navBarEl.querySelector("md-nav-ink-bar")); var n = this;
            this._$timeout(function() { n._updateTabs(n.mdSelectedNavItem, le) }), this._$scope.$watch("ctrl.mdSelectedNavItem", function(e, t) { n._$timeout(function() { n._updateTabs(e, t) }) }) }, ye.prototype._updateTabs = function(e, t) { var n = this,
                i = this._getTabs(); if (i) { var o = -1,
                    r = -1,
                    a = this._getTabByName(e),
                    s = this._getTabByName(t);
                s && (s.setSelected(!1), o = i.indexOf(s)), a && (a.setSelected(!0), r = i.indexOf(a)), this._$timeout(function() { n._updateInkBarStyles(a, r, o) }) } }, ye.prototype._updateInkBarStyles = function(e, t, n) { if (this._inkbar.toggleClass("_md-left", t < n).toggleClass("_md-right", n < t), this._inkbar.css({ display: t < 0 ? "none" : "" }), e) { var i = e.getButtonEl(),
                    o = i.offsetLeft;
                this._inkbar.css({ left: o + "px", width: i.offsetWidth + "px" }) } }, ye.prototype._getTabs = function() { var e = Array.prototype.slice.call(this._navBarEl.querySelectorAll(".md-nav-item")).map(function(e) { return se.element(e).controller("mdNavItem") }); return e.indexOf(le) ? e : null }, ye.prototype._getTabByName = function(t) { return this._findTab(function(e) { return e.getName() == t }) }, ye.prototype._getSelectedTab = function() { return this._findTab(function(e) { return e.isSelected() }) }, ye.prototype.getFocusedTab = function() { return this._findTab(function(e) { return e.hasFocus() }) }, ye.prototype._findTab = function(e) { for (var t = this._getTabs(), n = 0; n < t.length; n++)
                if (e(t[n])) return t[n];
            return null }, ye.prototype.onFocus = function() { var e = this._getSelectedTab();
            e && e.setFocused(!0) }, ye.prototype._moveFocus = function(e, t) { e.setFocused(!1), t.setFocused(!0) }, ye.prototype.onKeydown = function(e) { var t = this._$mdConstant.KEY_CODE,
                n = this._getTabs(),
                i = this.getFocusedTab(); if (i) { var o = n.indexOf(i); switch (e.keyCode) {
                    case t.UP_ARROW:
                    case t.LEFT_ARROW:
                        0 < o && this._moveFocus(i, n[o - 1]); break;
                    case t.DOWN_ARROW:
                    case t.RIGHT_ARROW:
                        o < n.length - 1 && this._moveFocus(i, n[o + 1]); break;
                    case t.SPACE:
                    case t.ENTER:
                        this._$timeout(function() { i.getButtonEl().click() }) } } }, we.prototype.getNgClassMap = function() { return { "md-active": this._selected, "md-primary": this._selected, "md-unselected": !this._selected, "md-focused": this._focused } }, we.prototype.getName = function() { return this.name }, we.prototype.getButtonEl = function() { return this._$element[0].querySelector("._md-nav-button") }, we.prototype.setSelected = function(e) { this._selected = e }, we.prototype.isSelected = function() { return this._selected }, we.prototype.setFocused = function(e) {
            (this._focused = e) && this.getButtonEl().focus() }, we.prototype.hasFocus = function() { return this._focused },
        function() { s.$inject = ["presets", "$rootElement", "$rootScope", "$injector", "$window"], se.module("material.components.panel", ["material.core", "material.components.backdrop"]).provider("$mdPanel", function() { return { definePreset: e, getAllPresets: t, clearPresets: i, $get: ["$rootElement", "$rootScope", "$injector", "$window", function(e, t, n, i) { return new s(o, e, t, n, i) }] } }); var r = 80,
                a = "_md-panel-hidden",
                n = se.element('<div class="_md-panel-focus-trap" tabindex="0"></div>'),
                o = {};

            function e(e, t) { if (!e || !t) throw new Error("mdPanelProvider: The panel preset definition is malformed. The name and preset object are required."); if (o.hasOwnProperty(e)) throw new Error("mdPanelProvider: The panel preset you have requested has already been defined.");
                delete t.id, delete t.position, delete t.animation, o[e] = t }

            function t() { return se.copy(o) }

            function i() { o = {} }

            function s(e, t, n, i, o) { this._defaultConfigOptions = { bindToController: !0, clickOutsideToClose: !1, disableParentScroll: !1, escapeToClose: !1, focusOnOpen: !0, fullscreen: !1, hasBackdrop: !1, propagateContainerEvents: !1, transformTemplate: se.bind(this, this._wrapTemplate), trapFocus: !1, zIndex: r }, this._config = {}, this._presets = e, this._$rootElement = t, this._$rootScope = n, this._$injector = i, this._$window = o, this._$mdUtil = this._$injector.get("$mdUtil"), this._trackedPanels = {}, this._groups = Object.create(null), this.animation = c.animation, this.xPosition = h.xPosition, this.yPosition = h.yPosition, this.interceptorTypes = l.interceptorTypes, this.closeReasons = l.closeReasons, this.absPosition = h.absPosition }

            function l(e, t) { this._$q = t.get("$q"), this._$mdCompiler = t.get("$mdCompiler"), this._$mdConstant = t.get("$mdConstant"), this._$mdUtil = t.get("$mdUtil"), this._$mdTheming = t.get("$mdTheming"), this._$rootScope = t.get("$rootScope"), this._$animate = t.get("$animate"), this._$mdPanel = t.get("$mdPanel"), this._$log = t.get("$log"), this._$window = t.get("$window"), this._$$rAF = t.get("$$rAF"), this.id = e.id, this.config = e, this.panelContainer, this.panelEl, this.isAttached = !1, this._removeListeners = [], this._topFocusTrap, this._bottomFocusTrap, this._backdropRef, this._restoreScroll = null, this._interceptors = Object.create(null), this._compilerCleanup = null, this._restoreCache = { styles: "", classes: "" } }

            function h(e) { this._$window = e.get("$window"), this._isRTL = "rtl" === e.get("$mdUtil").bidi(), this._$mdConstant = e.get("$mdConstant"), this._absolute = !1, this._relativeToEl, this._top = "", this._bottom = "", this._left = "", this._right = "", this._translateX = [], this._translateY = [], this._positions = [], this._actualPosition }

            function c(e) { this._$mdUtil = e.get("$mdUtil"), this._openFrom, this._closeTo, this._animationClass = "", this._openDuration, this._closeDuration, this._rawDuration }

            function d(e) { var t = se.isString(e) ? document.querySelector(e) : e; return se.element(t) }
            s.prototype.create = function(e, t) { if ("string" == typeof e ? e = this._getPresetByName(e) : "object" != typeof e || !se.isUndefined(t) && t || (t = e, e = {}), e = e || {}, t = t || {}, se.isDefined(t.id) && this._trackedPanels[t.id]) { var n = this._trackedPanels[t.id]; return se.extend(n.config, t), n }
                this._config = se.extend({ id: t.id || "panel_" + this._$mdUtil.nextUid(), scope: this._$rootScope.$new(!0), attachTo: this._$rootElement }, this._defaultConfigOptions, t, e); var i = new l(this._config, this._$injector); return this._trackedPanels[t.id] = i, this._config.groupName && (se.isString(this._config.groupName) && (this._config.groupName = [this._config.groupName]), se.forEach(this._config.groupName, function(e) { i.addToGroup(e) })), this._config.scope.$on("$destroy", se.bind(i, i.detach)), i }, s.prototype.open = function(e, t) { var n = this.create(e, t); return n.open().then(function() { return n }) }, s.prototype._getPresetByName = function(e) { if (!this._presets[e]) throw new Error("mdPanel: The panel preset configuration that you requested does not exist. Use the $mdPanelProvider to create a preset before requesting one."); return this._presets[e] }, s.prototype.newPanelPosition = function() { return new h(this._$injector) }, s.prototype.newPanelAnimation = function() { return new c(this._$injector) }, s.prototype.newPanelGroup = function(e, t) { if (!this._groups[e]) { var n = { panels: [], openPanels: [], maxOpen: 0 < (t = t || {}).maxOpen ? t.maxOpen : 1 / 0 };
                    this._groups[e] = n } return this._groups[e] }, s.prototype.setGroupMaxOpen = function(e, t) { if (!this._groups[e]) throw new Error("mdPanel: Group does not exist yet. Call newPanelGroup().");
                this._groups[e].maxOpen = t }, s.prototype._openCountExceedsMaxOpen = function(e) { if (this._groups[e]) { var t = this._groups[e]; return 0 < t.maxOpen && t.openPanels.length > t.maxOpen } return !1 }, s.prototype._closeFirstOpenedPanel = function(e) { this._groups[e].openPanels[0].close() }, s.prototype._wrapTemplate = function(e) { return '<div class="md-panel-outer-wrapper">  <div class="md-panel _md-panel-offscreen">' + (e || "") + "</div></div>" }, s.prototype._wrapContentElement = function(e) { var t = se.element('<div class="md-panel-outer-wrapper">'); return e.addClass("md-panel _md-panel-offscreen"), t.append(e), t }, l.interceptorTypes = { CLOSE: "onClose" }, l.prototype.open = function() { var o = this; return this._$q(function(e, t) { var n = o._done(e, o),
                        i = o._simpleBind(o.show, o);
                    o.attach().then(i).then(function() { o.config.groupName && se.forEach(o.config.groupName, function(e) { o._$mdPanel._openCountExceedsMaxOpen(e) && o._$mdPanel._closeFirstOpenedPanel(e) }) }).then(n).catch(t) }) }, l.prototype.close = function(r) { var a = this; return this._$q(function(i, o) { a._callInterceptors(l.interceptorTypes.CLOSE).then(function() { var e = a._done(i, a),
                            t = a._simpleBind(a.detach, a),
                            n = a.config.onCloseSuccess || se.noop;
                        n = se.bind(a, n, a, r), a.hide().then(t).then(e).then(n).catch(o) }, o) }) }, l.prototype.attach = function() { if (this.isAttached && this.panelEl) return this._$q.when(this); var o = this; return this._$q(function(e, t) { var n = o._done(e, o),
                        i = o.config.onDomAdded || se.noop;
                    o._$q.all([o._createBackdrop(), o._createPanel().then(function(e) { return o.isAttached = !0, o._addEventListeners(), e }).catch(t)]).then(i).then(n).catch(t) }) }, l.prototype.detach = function() { if (!this.isAttached) return this._$q.when(this); var i = this,
                    o = i.config.onDomRemoved || se.noop; return this._restoreScroll && (this._restoreScroll(), this._restoreScroll = null), this._$q(function(e, t) { var n = i._done(e, i);
                    i._$q.all([(i._removeEventListeners(), i._topFocusTrap && i._topFocusTrap.parentNode && i._topFocusTrap.parentNode.removeChild(i._topFocusTrap), i._bottomFocusTrap && i._bottomFocusTrap.parentNode && i._bottomFocusTrap.parentNode.removeChild(i._bottomFocusTrap), i._restoreCache.classes && (i.panelEl[0].className = i._restoreCache.classes), i.panelEl[0].style.cssText = i._restoreCache.styles || "", i._compilerCleanup(), i.panelContainer.remove(), i.isAttached = !1, i._$q.when(i)), !i._backdropRef || i._backdropRef.detach()]).then(o).then(n).catch(t) }) }, l.prototype.destroy = function() { var t = this;
                this.config.groupName && se.forEach(this.config.groupName, function(e) { t.removeFromGroup(e) }), this.config.scope.$destroy(), this.config.locals = null, this._interceptors = null }, l.prototype.show = function() { if (!this.panelContainer) return this._$q(function(e, t) { t("mdPanel: Panel does not exist yet. Call open() or attach().") }); if (!this.panelContainer.hasClass(a)) return this._$q.when(this); var o = this; return this._$q(function(e, t) { var n = o._done(e, o),
                        i = o.config.onOpenComplete || se.noop;
                    o._$q.all([o._backdropRef ? o._backdropRef.show() : o, (o.panelContainer.removeClass(a), o._animateOpen()).then(function() { o._focusOnOpen() }, t)]).then(i).then(function() { o.config.groupName && se.forEach(o.config.groupName, function(e) { o._$mdPanel._groups[e].openPanels.push(o) }) }).then(n).catch(t) }) }, l.prototype.hide = function() { if (!this.panelContainer) return this._$q(function(e, t) { t("mdPanel: Panel does not exist yet. Call open() or attach().") }); if (this.panelContainer.hasClass(a)) return this._$q.when(this); var o = this; return this._$q(function(e, t) { var n = o._done(e, o),
                        i = o.config.onRemoving || se.noop;
                    o._$q.all([o._backdropRef ? o._backdropRef.hide() : o, o._animateClose().then(i).then(function() { o.panelContainer.addClass(a) }).then(function() { var t;
                        o.config.groupName && se.forEach(o.config.groupName, function(e) { e = o._$mdPanel._groups[e], -1 < (t = e.openPanels.indexOf(o)) && e.openPanels.splice(t, 1) }) }).then(function() { var e = o.config.origin;
                        e && d(e).focus() }).catch(t)]).then(n, t) }) }, l.prototype.addClass = function(e, t) { if (this._$log.warn("mdPanel: The addClass method is in the process of being deprecated. Full deprecation is scheduled for the AngularJS Material 1.2 release. To achieve the same results, use the panelContainer or panelEl JQLite elements that are referenced in MdPanelRef."), !this.panelContainer) throw new Error("mdPanel: Panel does not exist yet. Call open() or attach().");
                t || this.panelContainer.hasClass(e) ? t && !this.panelEl.hasClass(e) && this.panelEl.addClass(e) : this.panelContainer.addClass(e) }, l.prototype.removeClass = function(e, t) { if (this._$log.warn("mdPanel: The removeClass method is in the process of being deprecated. Full deprecation is scheduled for the AngularJS Material 1.2 release. To achieve the same results, use the panelContainer or panelEl JQLite elements that are referenced in MdPanelRef."), !this.panelContainer) throw new Error("mdPanel: Panel does not exist yet. Call open() or attach().");!t && this.panelContainer.hasClass(e) ? this.panelContainer.removeClass(e) : t && this.panelEl.hasClass(e) && this.panelEl.removeClass(e) }, l.prototype.toggleClass = function(e, t) { if (this._$log.warn("mdPanel: The toggleClass method is in the process of being deprecated. Full deprecation is scheduled for the AngularJS Material 1.2 release. To achieve the same results, use the panelContainer or panelEl JQLite elements that are referenced in MdPanelRef."), !this.panelContainer) throw new Error("mdPanel: Panel does not exist yet. Call open() or attach().");
                t ? this.panelEl.toggleClass(e) : this.panelContainer.toggleClass(e) }, l.prototype._compile = function() { var i = this; return i._$mdCompiler.compile(i.config).then(function(e) { var t = i.config; if (t.contentElement) { var n = e.element;
                        i._restoreCache.styles = n[0].style.cssText, i._restoreCache.classes = n[0].className, i.panelContainer = i._$mdPanel._wrapContentElement(n), i.panelEl = n } else i.panelContainer = e.link(t.scope), i.panelEl = se.element(i.panelContainer[0].querySelector(".md-panel")); return i._compilerCleanup = e.cleanup, d(i.config.attachTo).append(i.panelContainer), i }) }, l.prototype._createPanel = function() { var n = this; return this._$q(function(e, t) { n.config.locals || (n.config.locals = {}), (n.config.locals.mdPanelRef = n)._compile().then(function() { n.config.disableParentScroll && (n._restoreScroll = n._$mdUtil.disableScrollAround(null, n.panelContainer, { disableScrollMask: !0 })), n.config.panelClass && n.panelEl.addClass(n.config.panelClass), n.config.propagateContainerEvents && (n.panelContainer.css("pointer-events", "none"), n.panelEl.css("pointer-events", "all")), n._$animate.pin && n._$animate.pin(n.panelContainer, d(n.config.attachTo)), n._configureTrapFocus(), n._addStyles().then(function() { e(n) }, t) }, t) }) }, l.prototype._addStyles = function() { var n = this; return this._$q(function(e) { n.panelContainer.css("z-index", n.config.zIndex), n.panelEl.css("z-index", n.config.zIndex + 1);

                    function t() { n._setTheming(), n.panelEl.removeClass("_md-panel-offscreen"), n.panelContainer.addClass(a), e(n) } if (n.config.fullscreen) return n.panelEl.addClass("_md-panel-fullscreen"), void t();
                    n.config.position ? n._$rootScope.$$postDigest(function() { n._updatePosition(!0), n._setTheming(), e(n) }) : t() }) }, l.prototype._setTheming = function() { this._$mdTheming(this.panelEl), this._$mdTheming(this.panelContainer) }, l.prototype.updatePosition = function(e) { if (!this.panelContainer) throw new Error("mdPanel: Panel does not exist yet. Call open() or attach().");
                this.config.position = e, this._updatePosition() }, l.prototype._updatePosition = function(e) { var t = this.config.position;
                t && (t._setPanelPosition(this.panelEl), e && (this.panelEl.removeClass("_md-panel-offscreen"), this.panelContainer.addClass(a)), this.panelEl.css(h.absPosition.TOP, t.getTop()), this.panelEl.css(h.absPosition.BOTTOM, t.getBottom()), this.panelEl.css(h.absPosition.LEFT, t.getLeft()), this.panelEl.css(h.absPosition.RIGHT, t.getRight())) }, l.prototype._focusOnOpen = function() { if (this.config.focusOnOpen) { var e = this;
                    this._$rootScope.$$postDigest(function() {
                        (e._$mdUtil.findFocusTarget(e.panelEl) || e.panelEl).focus() }) } }, l.prototype._createBackdrop = function() { if (this.config.hasBackdrop) { if (!this._backdropRef) { var e = this._$mdPanel.newPanelAnimation().openFrom(this.config.attachTo).withAnimation({ open: "_md-opaque-enter", close: "_md-opaque-leave" });
                        this.config.animation && e.duration(this.config.animation._rawDuration); var t = { animation: e, attachTo: this.config.attachTo, focusOnOpen: !1, panelClass: "_md-panel-backdrop", zIndex: this.config.zIndex - 1 };
                        this._backdropRef = this._$mdPanel.create(t) } if (!this._backdropRef.isAttached) return this._backdropRef.attach() } }, l.prototype._addEventListeners = function() { this._configureEscapeToClose(), this._configureClickOutsideToClose(), this._configureScrollListener() }, l.prototype._removeEventListeners = function() { this._removeListeners && this._removeListeners.forEach(function(e) { e() }), this._removeListeners = [] }, l.prototype._configureEscapeToClose = function() { if (this.config.escapeToClose) { var e = d(this.config.attachTo),
                        t = this,
                        n = function(e) { e.keyCode === t._$mdConstant.KEY_CODE.ESCAPE && (e.stopPropagation(), e.preventDefault(), t.close(l.closeReasons.ESCAPE)) };
                    this.panelContainer.on("keydown", n), e.on("keydown", n), this._removeListeners.push(function() { t.panelContainer.off("keydown", n), e.off("keydown", n) }) } }, l.prototype._configureClickOutsideToClose = function() { if (this.config.clickOutsideToClose) { var t, n = this.config.propagateContainerEvents ? se.element(document.body) : this.panelContainer,
                        e = function(e) { t = e.target },
                        i = this,
                        o = function(e) { i.config.propagateContainerEvents ? t === i.panelEl[0] || i.panelEl[0].contains(t) || i.close() : t === n[0] && e.target === n[0] && (e.stopPropagation(), e.preventDefault(), i.close(l.closeReasons.CLICK_OUTSIDE)) };
                    n.on("mousedown", e), n.on("mouseup", o), this._removeListeners.push(function() { n.off("mousedown", e), n.off("mouseup", o) }) } }, l.prototype._configureScrollListener = function() { if (!this.config.disableParentScroll) { var e = se.bind(this, this._updatePosition),
                        t = this._$$rAF.throttle(e),
                        n = this,
                        i = function() { t() };
                    this._$window.addEventListener("scroll", i, !0), this._removeListeners.push(function() { n._$window.removeEventListener("scroll", i, !0) }) } }, l.prototype._configureTrapFocus = function() { if (this.panelEl.attr("tabIndex", "-1"), this.config.trapFocus) { var e = this.panelEl;
                    this._topFocusTrap = n.clone()[0], this._bottomFocusTrap = n.clone()[0]; var t = function() { e.focus() };
                    this._topFocusTrap.addEventListener("focus", t), this._bottomFocusTrap.addEventListener("focus", t), this._removeListeners.push(this._simpleBind(function() { this._topFocusTrap.removeEventListener("focus", t), this._bottomFocusTrap.removeEventListener("focus", t) }, this)), e[0].parentNode.insertBefore(this._topFocusTrap, e[0]), e.after(this._bottomFocusTrap) } }, l.prototype.updateAnimation = function(e) { this.config.animation = e, this._backdropRef && this._backdropRef.config.animation.duration(e._rawDuration) }, l.prototype._animateOpen = function() { this.panelContainer.addClass("md-panel-is-showing"); var n = this.config.animation; if (!n) return this.panelContainer.addClass("_md-panel-shown"), this._$q.when(this); var i = this; return this._$q(function(e) { var t = i._done(e, i);
                    n.animateOpen(i.panelEl).then(t, function() { i._$log.warn("mdPanel: MdPanel Animations failed. Showing panel without animating."), t() }) }) }, l.prototype._animateClose = function() { var n = this.config.animation; if (!n) return this.panelContainer.removeClass("md-panel-is-showing"), this.panelContainer.removeClass("_md-panel-shown"), this._$q.when(this); var i = this; return this._$q(function(e) {
                    function t() { i.panelContainer.removeClass("md-panel-is-showing"), e(i) }
                    n.animateClose(i.panelEl).then(t, function() { i._$log.warn("mdPanel: MdPanel Animations failed. Hiding panel without animating."), t() }) }) }, l.prototype.registerInterceptor = function(e, t) { var n = null; if (se.isString(e) ? se.isFunction(t) || (n = "Interceptor callback must be a function, instead got " + typeof t) : n = "Interceptor type must be a string, instead got " + typeof e, n) throw new Error("MdPanel: " + n); var i = this._interceptors[e] = this._interceptors[e] || []; return -1 === i.indexOf(t) && i.push(t), this }, l.prototype.removeInterceptor = function(e, t) { var n = this._interceptors[e] ? this._interceptors[e].indexOf(t) : -1; return -1 < n && this._interceptors[e].splice(n, 1), this }, l.prototype.removeAllInterceptors = function(e) { return e ? this._interceptors[e] = [] : this._interceptors = Object.create(null), this }, l.prototype._callInterceptors = function(e) { var i = this,
                    o = i._$q; return (i._interceptors && i._interceptors[e] || []).reduceRight(function(e, t) { var n = t && se.isFunction(t.then) ? t : null; return e.then(function() { if (!n) try { n = t(i) } catch (e) { n = o.reject(e) }
                        return n }) }, o.resolve(i)) }, l.prototype._simpleBind = function(t, n) { return function(e) { return t.Apply(n, e) } }, l.prototype._done = function(e, t) { return function() { e(t) } }, l.prototype.addToGroup = function(e) { this._$mdPanel._groups[e] || this._$mdPanel.newPanelGroup(e); var t = this._$mdPanel._groups[e];
                t.panels.indexOf(this) < 0 && t.panels.push(this) }, l.prototype.removeFromGroup = function(e) { if (!this._$mdPanel._groups[e]) throw new Error("mdPanel: The group " + e + " does not exist."); var t = this._$mdPanel._groups[e],
                    n = t.panels.indexOf(this); - 1 < n && t.panels.splice(n, 1) }, l.closeReasons = { CLICK_OUTSIDE: "clickOutsideToClose", ESCAPE: "escapeToClose" }, h.xPosition = { CENTER: "center", ALIGN_START: "align-start", ALIGN_END: "align-end", OFFSET_START: "offset-start", OFFSET_END: "offset-end" }, h.yPosition = { CENTER: "center", ALIGN_TOPS: "align-tops", ALIGN_BOTTOMS: "align-bottoms", ABOVE: "above", BELOW: "below" }, h.absPosition = { TOP: "top", RIGHT: "right", BOTTOM: "bottom", LEFT: "left" }, h.viewportMargin = 8, h.prototype.absolute = function() { return this._absolute = !0, this }, h.prototype._setPosition = function(e, t) { if (e === h.absPosition.RIGHT || e === h.absPosition.LEFT) this._left = this._right = "";
                else { if (e !== h.absPosition.BOTTOM && e !== h.absPosition.TOP) { var n = Object.keys(h.absPosition).join().toLowerCase(); throw new Error("mdPanel: Position must be one of " + n + ".") }
                    this._top = this._bottom = "" } return this["_" + e] = se.isString(t) ? t : "0", this }, h.prototype.top = function(e) { return this._setPosition(h.absPosition.TOP, e) }, h.prototype.bottom = function(e) { return this._setPosition(h.absPosition.BOTTOM, e) }, h.prototype.start = function(e) { var t = this._isRTL ? h.absPosition.RIGHT : h.absPosition.LEFT; return this._setPosition(t, e) }, h.prototype.end = function(e) { var t = this._isRTL ? h.absPosition.LEFT : h.absPosition.RIGHT; return this._setPosition(t, e) }, h.prototype.left = function(e) { return this._setPosition(h.absPosition.LEFT, e) }, h.prototype.right = function(e) { return this._setPosition(h.absPosition.RIGHT, e) }, h.prototype.centerHorizontally = function() { return this._left = "50%", this._right = "", this._translateX = ["-50%"], this }, h.prototype.centerVertically = function() { return this._top = "50%", this._bottom = "", this._translateY = ["-50%"], this }, h.prototype.center = function() { return this.centerHorizontally().centerVertically() }, h.prototype.relativeTo = function(e) { return this._absolute = !1, this._relativeToEl = d(e), this }, h.prototype.addPanelPosition = function(e, t) { if (!this._relativeToEl) throw new Error("mdPanel: addPanelPosition can only be used with relative positioning. Set relativeTo first."); return this._validateXPosition(e), this._validateYPosition(t), this._positions.push({ x: e, y: t }), this }, h.prototype._validateYPosition = function(e) { if (null != e) { for (var t, n = Object.keys(h.yPosition), i = [], o = 0; t = n[o]; o++) { var r = h.yPosition[t]; if (i.push(r), r === e) return } throw new Error("mdPanel: Panel y position only accepts the following values:\n" + i.join(" | ")) } }, h.prototype._validateXPosition = function(e) { if (null != e) { for (var t, n = Object.keys(h.xPosition), i = [], o = 0; t = n[o]; o++) { var r = h.xPosition[t]; if (i.push(r), r === e) return } throw new Error("mdPanel: Panel x Position only accepts the following values:\n" + i.join(" | ")) } }, h.prototype.withOffsetX = function(e) { return this._translateX.push(e), this }, h.prototype.withOffsetY = function(e) { return this._translateY.push(e), this }, h.prototype.getTop = function() { return this._top }, h.prototype.getBottom = function() { return this._bottom }, h.prototype.getLeft = function() { return this._left }, h.prototype.getRight = function() { return this._right }, h.prototype.getTransform = function() { return (this._reduceTranslateValues("translateX", this._translateX) + " " + this._reduceTranslateValues("translateY", this._translateY)).trim() }, h.prototype._setTransform = function(e) { return e.css(this._$mdConstant.CSS.TRANSFORM, this.getTransform()) }, h.prototype._isOnscreen = function(e) { var t = parseInt(this.getLeft()),
                    n = parseInt(this.getTop()); if (this._translateX.length || this._translateY.length) { var i = function(e, t) { var n = getComputedStyle(e[0] || e)[t],
                            i = n.indexOf("("),
                            o = n.lastIndexOf(")"),
                            r = { x: 0, y: 0 }; if (-1 < i && -1 < o) { var a = n.substring(i + 1, o).split(", ").slice(-2);
                            r.x = parseInt(a[0]), r.y = parseInt(a[1]) } return r }(e, this._$mdConstant.CSS.TRANSFORM);
                    t += i.x, n += i.y } var o = t + e[0].offsetWidth,
                    r = n + e[0].offsetHeight; return 0 <= t && 0 <= n && r <= this._$window.innerHeight && o <= this._$window.innerWidth }, h.prototype.getActualPosition = function() { return this._actualPosition }, h.prototype._reduceTranslateValues = function(n, e) { return e.map(function(e) { var t = se.isFunction(e) ? e(this) : e; return n + "(" + t + ")" }, this).join(" ") }, h.prototype._setPanelPosition = function(e) { if (e.removeClass("_md-panel-position-adjusted"), this._absolute) this._setTransform(e);
                else { if (this._actualPosition) return this._calculatePanelPosition(e, this._actualPosition), this._setTransform(e), void this._constrainToViewport(e); for (var t = 0; t < this._positions.length; t++)
                        if (this._actualPosition = this._positions[t], this._calculatePanelPosition(e, this._actualPosition), this._setTransform(e), this._isOnscreen(e)) return;
                    this._constrainToViewport(e) } }, h.prototype._constrainToViewport = function(e) { var t = h.viewportMargin,
                    n = this._top,
                    i = this._left; if (this.getTop()) { var o = parseInt(this.getTop()),
                        r = e[0].offsetHeight + o,
                        a = this._$window.innerHeight;
                    o < t ? this._top = t + "px" : a < r && (this._top = o - (r - a + t) + "px") } if (this.getLeft()) { var s = parseInt(this.getLeft()),
                        l = e[0].offsetWidth + s,
                        c = this._$window.innerWidth;
                    s < t ? this._left = t + "px" : c < l && (this._left = s - (l - c + t) + "px") }
                e.toggleClass("_md-panel-position-adjusted", this._top !== n || this._left !== i) }, h.prototype._reverseXPosition = function(e) { if (e === h.xPosition.CENTER) return e; var t = "start"; return -1 < e.indexOf(t) ? e.replace(t, "end") : e.replace("end", t) }, h.prototype._bidi = function(e) { return this._isRTL ? this._reverseXPosition(e) : e }, h.prototype._calculatePanelPosition = function(e, t) { var n = e[0].getBoundingClientRect(),
                    i = n.width,
                    o = n.height,
                    r = this._relativeToEl[0].getBoundingClientRect(),
                    a = r.left,
                    s = r.right,
                    l = r.width; switch (this._bidi(t.x)) {
                    case h.xPosition.OFFSET_START:
                        this._left = a - i + "px"; break;
                    case h.xPosition.ALIGN_END:
                        this._left = s - i + "px"; break;
                    case h.xPosition.CENTER:
                        var c = a + .5 * l - .5 * i;
                        this._left = c + "px"; break;
                    case h.xPosition.ALIGN_START:
                        this._left = a + "px"; break;
                    case h.xPosition.OFFSET_END:
                        this._left = s + "px" } var d = r.top,
                    u = r.bottom,
                    m = r.height; switch (t.y) {
                    case h.yPosition.ABOVE:
                        this._top = d - o + "px"; break;
                    case h.yPosition.ALIGN_BOTTOMS:
                        this._top = u - o + "px"; break;
                    case h.yPosition.CENTER:
                        var p = d + .5 * m - .5 * o;
                        this._top = p + "px"; break;
                    case h.yPosition.ALIGN_TOPS:
                        this._top = d + "px"; break;
                    case h.yPosition.BELOW:
                        this._top = u + "px" } }, c.animation = { SLIDE: "md-panel-animate-slide", SCALE: "md-panel-animate-scale", FADE: "md-panel-animate-fade" }, c.prototype.openFrom = function(e) { return e = e.target ? e.target : e, this._openFrom = this._getPanelAnimationTarget(e), this._closeTo || (this._closeTo = this._openFrom), this }, c.prototype.closeTo = function(e) { return this._closeTo = this._getPanelAnimationTarget(e), this }, c.prototype.duration = function(e) { return e && (se.isNumber(e) ? this._openDuration = this._closeDuration = t(e) : se.isObject(e) && (this._openDuration = t(e.open), this._closeDuration = t(e.close))), this._rawDuration = e, this;

                function t(e) { if (se.isNumber(e)) return e / 1e3 } }, c.prototype._getPanelAnimationTarget = function(e) { return se.isDefined(e.top) || se.isDefined(e.left) ? { element: le, bounds: { top: e.top || 0, left: e.left || 0 } } : this._getBoundingClientRect(d(e)) }, c.prototype.withAnimation = function(e) { return this._animationClass = e, this }, c.prototype.animateOpen = function(e) { var t = this._$mdUtil.dom.animator;
                this._fixBounds(e); var n = {},
                    i = e[0].style.transform || "",
                    o = t.toTransformCss(i),
                    r = t.toTransformCss(i); switch (this._animationClass) {
                    case c.animation.SLIDE:
                        e.css("opacity", "1"), n = { transitionInClass: "_md-panel-animate-enter" }; var a = t.calculateSlideToOrigin(e, this._openFrom) || "";
                        o = t.toTransformCss(a + " " + i); break;
                    case c.animation.SCALE:
                        n = { transitionInClass: "_md-panel-animate-enter" }; var s = t.calculateZoomToOrigin(e, this._openFrom) || "";
                        o = t.toTransformCss(s + " " + i); break;
                    case c.animation.FADE:
                        n = { transitionInClass: "_md-panel-animate-enter" }; break;
                    default:
                        n = se.isString(this._animationClass) ? { transitionInClass: this._animationClass } : { transitionInClass: this._animationClass.open, transitionOutClass: this._animationClass.close } } return n.duration = this._openDuration, t.translate3d(e, o, r, n) }, c.prototype.animateClose = function(e) { var t = this._$mdUtil.dom.animator,
                    n = {},
                    i = e[0].style.transform || "",
                    o = t.toTransformCss(i),
                    r = t.toTransformCss(i); switch (this._animationClass) {
                    case c.animation.SLIDE:
                        e.css("opacity", "1"), n = { transitionInClass: "_md-panel-animate-leave" }; var a = t.calculateSlideToOrigin(e, this._closeTo) || "";
                        r = t.toTransformCss(a + " " + i); break;
                    case c.animation.SCALE:
                        n = { transitionInClass: "_md-panel-animate-scale-out _md-panel-animate-leave" }; var s = t.calculateZoomToOrigin(e, this._closeTo) || "";
                        r = t.toTransformCss(s + " " + i); break;
                    case c.animation.FADE:
                        n = { transitionInClass: "_md-panel-animate-fade-out _md-panel-animate-leave" }; break;
                    default:
                        n = se.isString(this._animationClass) ? { transitionOutClass: this._animationClass } : { transitionInClass: this._animationClass.close, transitionOutClass: this._animationClass.open } } return n.duration = this._closeDuration, t.translate3d(e, o, r, n) }, c.prototype._fixBounds = function(e) { var t = e[0].offsetWidth,
                    n = e[0].offsetHeight;
                this._openFrom && null == this._openFrom.bounds.height && (this._openFrom.bounds.height = n), this._openFrom && null == this._openFrom.bounds.width && (this._openFrom.bounds.width = t), this._closeTo && null == this._closeTo.bounds.height && (this._closeTo.bounds.height = n), this._closeTo && null == this._closeTo.bounds.width && (this._closeTo.bounds.width = t) }, c.prototype._getBoundingClientRect = function(e) { if (e instanceof se.element) return { element: e, bounds: e[0].getBoundingClientRect() } } }(), se.module("material.components.progressCircular", ["material.core"]), Te.$inject = ["$mdTheming", "$mdUtil", "$log"], se.module("material.components.progressLinear", ["material.core"]).directive("mdProgressLinear", Te), Ee.$inject = ["$mdUtil", "$mdConstant", "$mdTheming", "$timeout"], Ae.$inject = ["$mdAria", "$mdUtil", "$mdTheming"], se.module("material.components.radioButton", ["material.core"]).directive("mdRadioGroup", Ee).directive("mdRadioButton", Ae),
        function() { e.$inject = ["$mdSelect", "$mdUtil", "$mdConstant", "$mdTheming", "$mdAria", "$parse", "$sce", "$injector"], t.$inject = ["$parse", "$mdUtil", "$mdConstant", "$mdTheming"], n.$inject = ["$mdButtonInkRipple", "$mdUtil", "$mdTheming"], i.$inject = ["$$interimElementProvider"]; var F = 8,
                g = 0,
                d = se.element('<div class="md-container"><div class="md-icon"></div></div>');

            function e(k, M, D, I, _, O, P, e) { var t = D.KEY_CODE;
                t.SPACE, t.ENTER, t.UP_ARROW, t.DOWN_ARROW; return { restrict: "E", require: ["^?mdInputContainer", "mdSelect", "ngModel", "?^form"], compile: function(e, t) { var n = se.element("<md-select-value><span></span></md-select-value>");
                        n.append('<span class="md-select-icon" aria-hidden="true"></span>'), n.addClass("md-select-value"), n[0].hasAttribute("id") || n.attr("id", "select_value_label_" + M.nextUid()); var i = e.find("md-content");
                        i.length || e.append(se.element("<md-content>").append(e.contents()));
                        i.attr("role", "presentation"), t.mdOnOpen && (e.find("md-content").prepend(se.element('<div> <md-progress-circular md-mode="indeterminate" data-ng-if="$$loadingAsyncDone === false" md-diameter="25px"></md-progress-circular></div>')), e.find("md-option").attr("data-ng-show", "$$loadingAsyncDone")); if (t.name) { var o = se.element('<select class="md-visually-hidden">');
                            o.attr({ name: t.name, "aria-hidden": "true", tabindex: "-1" }); var r = e.find("md-option");
                            se.forEach(r, function(e) { var t = se.element("<option>" + e.innerHTML + "</option>");
                                e.hasAttribute("data-ng-value") ? t.attr("data-ng-value", e.getAttribute("data-ng-value")) : e.hasAttribute("value") && t.attr("value", e.getAttribute("value")), o.append(t) }), o.append('<option data-ng-value="' + t.ngModel + '" selected></option>'), e.parent().append(o) } var S = M.parseAttributeBoolean(t.multiple),
                            a = S ? "multiple" : "",
                            s = '<div class="md-select-menu-container" aria-hidden="true" role="presentation"><md-select-menu role="presentation" {0}>{1}</md-select-menu></div>';
                        s = M.supplant(s, [a, e.html()]), e.empty().append(n), e.append(s), t.tabindex || t.$set("tabindex", 0); return function(i, n, o, e) { var t, r, a, s, l, c = !0,
                                d = e[0],
                                u = e[1],
                                m = e[2],
                                p = e[3],
                                h = n.find("md-select-value"),
                                f = se.isDefined(o.readonly),
                                g = M.parseAttributeBoolean(o.mdNoAsterisk); if (g && n.addClass("md-no-asterisk"), d) { var v = d.isErrorGetter || function() { return m.$invalid && (m.$touched || p && p.$submitted) }; if (d.input && n.find("md-select-header").find("input")[0] !== d.input[0]) throw new Error("<md-input-container> can only have *one* child <input>, <textarea> or <select> element!");
                                d.input = n, d.label || _.expect(n, "aria-label", n.attr("placeholder")), i.$watch(v, d.setInvalid) }! function() { if (a = se.element(n[0].querySelector(".md-select-menu-container")), s = i, o.mdContainerClass) { var e = a[0].getAttribute("class") + " " + o.mdContainerClass;
                                    a[0].setAttribute("class", e) }(l = a.find("md-select-menu").controller("mdSelectMenu")).init(m, o.ngModel), n.on("$destroy", function() { a.remove() }) }(), I(n), p && se.isDefined(o.multiple) && M.nextTick(function() {
                                (m.$modelValue || m.$viewValue) && p.$setPristine() }); var b, $ = m.$render;

                            function C() { a && (l = l || a.find("md-select-menu").controller("mdSelectMenu"), u.setLabelText(l.selectedLabels())) }

                            function y() { if (r) { var e = l.selectedLabels({ mode: "aria" });
                                    n.attr("aria-label", e.length ? r + ": " + e : r) } }
                            m.$render = function() { $(), C(), y(), T() }, o.$observe("placeholder", m.$render), d && d.label && o.$observe("required", function(e) { d.label.toggleClass("md-required", e && !g) }), u.setLabelText = function(e) { u.setIsPlaceholder(!e); var t = !1; if (o.mdSelectedText && o.mdSelectedHtml) throw Error("md-select cannot have both `md-selected-text` and `md-selected-html`"); if (o.mdSelectedText || o.mdSelectedHtml) e = O(o.mdSelectedText || o.mdSelectedHtml)(i), t = !0;
                                else if (!e) { e = o.placeholder || (d && d.label ? d.label.text() : "") || "", t = !0 } var n = h.children().eq(0);
                                o.mdSelectedHtml ? n.html(P.getTrustedHtml(e)) : t ? n.text(e) : n.html(e) }, u.setIsPlaceholder = function(e) { e ? (h.addClass("md-select-placeholder"), d && d.label && d.label.addClass("md-placeholder")) : (h.removeClass("md-select-placeholder"), d && d.label && d.label.removeClass("md-placeholder")) }, f || (n.on("focus", function(e) { d && d.setFocused(!0) }), n.on("blur", function(e) { c && (c = !1, s._mdSelectIsOpen && e.stopImmediatePropagation()), s._mdSelectIsOpen || (d && d.setFocused(!1), T()) })), u.triggerClose = function() { O(o.mdOnClose)(i) }, i.$$postDigest(function() {! function() { var e = n.attr("aria-label") || n.attr("placeholder");!e && d && d.label && (e = d.label.text());
                                    r = e, _.expect(n, "aria-label", e) }(), C(), y() }), i.$watch(function() { return l.selectedLabels() }, C), o.$observe("ngMultiple", function(e) { b && b(); var t = O(e);
                                b = i.$watch(function() { return t(i) }, function(e, t) { e === le && t === le || (e ? n.attr("multiple", "multiple") : n.removeAttr("multiple"), n.attr("aria-multiselectable", e ? "true" : "false"), a && (l.setMultiple(e), $ = m.$render, m.$render = function() { $(), C(), y(), T() }, m.$render())) }) }), o.$observe("disabled", function(e) { se.isString(e) && (e = !0), t !== le && t === e || ((t = e) ? n.attr({ "aria-disabled": "true" }).removeAttr("tabindex").off("click", A).off("keydown", E) : n.attr({ tabindex: o.tabindex, "aria-disabled": "false" }).on("click", A).on("keydown", E)) }), o.hasOwnProperty("disabled") || o.hasOwnProperty("ngDisabled") || (n.attr({ "aria-disabled": "false" }), n.on("click", A), n.on("keydown", E)); var x = { role: "listbox", "aria-expanded": "false", "aria-multiselectable": S && !o.ngMultiple ? "true" : "false" };
                            n[0].hasAttribute("id") || (x.id = "select_" + M.nextUid()); var w = "select_container_" + M.nextUid();

                            function T() { d && d.setHasValue(0 < l.selectedLabels().length || (n[0].validity || {}).badInput) }

                            function E(e) { if (D.isNavigationKey(e)) e.preventDefault(), A();
                                else if (B(e, D)) { e.preventDefault(); var t = l.optNodeForKeyboardSearch(e); if (!t || t.hasAttribute("disabled")) return; var n = se.element(t).controller("mdOption");
                                    l.isMultiple || l.deselect(Object.keys(l.selected)[0]), l.select(n.hashKey, n.value), l.refreshViewValue() } }

                            function A() { s._mdSelectIsOpen = !0, n.attr("aria-expanded", "true"), k.show({ scope: s, preserveScope: !0, skipCompile: !0, element: a, target: n[0], selectCtrl: u, preserveElement: !0, hasBackdrop: !0, loadingAsync: !!o.mdOnOpen && (i.$eval(o.mdOnOpen) || !0) }).finally(function() { s._mdSelectIsOpen = !1, n.focus(), n.attr("aria-expanded", "false"), m.$setTouched() }) }
                            a.attr("id", w), n.find("md-select-menu").length || (x["aria-owns"] = w), n.attr(x), i.$on("$destroy", function() { k.destroy().finally(function() { d && (d.setFocused(!1), d.setHasValue(!1), d.input = null), m.$setTouched() }) }) } }, controller: function() {} } }

            function t(p, h, f, o) { return { restrict: "E", require: ["mdSelectMenu"], scope: !(e.$inject = ["$scope", "$attrs", "$element"]), controller: e, link: { pre: function(r, e, t, n) { var a = n[0];

                            function i(e) { var t = h.getClosest(e.target, "md-option"),
                                    n = t && se.element(t).data("$mdOptionController"); if (t && n) { if (t.hasAttribute("disabled")) return e.stopImmediatePropagation(), !1; var i = a.hashGetter(n.value),
                                        o = se.isDefined(a.selected[i]);
                                    r.$Apply(function() { a.isMultiple ? o ? a.deselect(i) : a.select(i, n.value) : o || (a.deselect(Object.keys(a.selected)[0]), a.select(i, n.value)), a.refreshViewValue() }) } }
                            e.addClass("_md"), o(e), e.on("click", i), e.on("keypress", function(e) { 13 != e.keyCode && 32 != e.keyCode || i(e) }) } } };

                function e(r, e, o) { var i, a = this;
                    a.isMultiple = se.isDefined(e.multiple), a.selected = {}, a.options = {}, r.$watchCollection(function() { return a.options }, function() { a.ngModel.$render() }), a.setMultiple = function(e) { var t = a.ngModel;

                        function n(e, t) { return se.isArray(e || t || []) }
                        i = i || t.$isEmpty, a.isMultiple = e, a.isMultiple ? (t.$validators["md-multiple"] = n, t.$render = u, r.$watchCollection(a.modelBinding, function(e) { n(e) && u(), a.ngModel.$setPristine() }), t.$isEmpty = function(e) { return !e || 0 === e.length }) : (delete t.$validators["md-multiple"], t.$render = m) }; var s, l, c, d = "";

                    function u() { var n = a.ngModel.$modelValue || a.ngModel.$viewValue || []; if (se.isArray(n)) { var e = Object.keys(a.selected),
                                t = n.map(a.hashGetter);
                            e.filter(function(e) { return -1 === t.indexOf(e) }).forEach(a.deselect), t.forEach(function(e, t) { a.select(e, n[t]) }) } }

                    function m() { var e = a.ngModel.$viewValue || a.ngModel.$modelValue;
                        Object.keys(a.selected).forEach(a.deselect), a.select(a.hashGetter(e), e) }
                    a.optNodeForKeyboardSearch = function(e) { s && clearTimeout(s), s = setTimeout(function() { d = "", l = c = s = le }, 300); var t = e.keyCode - (f.isNumPadKey(e) ? 48 : 0);
                        d += String.fromCharCode(t); var n = new RegExp("^" + d, "i");
                        l || (l = o.find("md-option"), c = new Array(l.length), se.forEach(l, function(e, t) { c[t] = e.textContent.trim() })); for (var i = 0; i < c.length; ++i)
                            if (n.test(c[i])) return l[i] }, a.init = function(e, t) { a.ngModel = e, a.modelBinding = t, a.ngModel.$isEmpty = function(e) { return !a.options[a.hashGetter(e)] }; var n = h.getModelOption(e, "trackBy"); if (n) { var i = {},
                                o = p(n);
                            a.hashGetter = function(e, t) { return i.$value = e, o(t || r, i) } } else a.hashGetter = function(e) { return se.isObject(e) ? "object_" + (e.$$mdSelectId || (e.$$mdSelectId = ++g)) : e };
                        a.setMultiple(a.isMultiple) }, a.selectedLabels = function(e) { var t, n = (e = e || {}).mode || "html",
                            i = h.nodesToArray(o[0].querySelectorAll("md-option[selected]")); return i.length ? ("html" == n ? t = function(e) { if (e.hasAttribute("md-option-empty")) return ""; var t = e.innerHTML,
                                n = e.querySelector(".md-ripple-container");
                            n && (t = t.replace(n.outerHTML, "")); var i = e.querySelector(".md-container"); return i && (t = t.replace(i.outerHTML, "")), t } : "aria" == n && (t = function(e) { return e.hasAttribute("aria-label") ? e.getAttribute("aria-label") : e.textContent }), h.uniq(i.map(t)).join(", ")) : "" }, a.select = function(e, t) { var n = a.options[e];
                        n && n.setSelected(!0), a.selected[e] = t }, a.deselect = function(e) { var t = a.options[e];
                        t && t.setSelected(!1), delete a.selected[e] }, a.addOption = function(e, t) { if (se.isDefined(a.options[e])) throw new Error('Duplicate md-option values are not allowed in a select. Duplicate value "' + t.value + '" found.');
                        a.options[e] = t, se.isDefined(a.selected[e]) && (a.select(e, t.value), se.isDefined(a.ngModel.$modelValue) && a.hashGetter(a.ngModel.$modelValue) === e && a.ngModel.$validate(), a.refreshViewValue()) }, a.removeOption = function(e) { delete a.options[e] }, a.refreshViewValue = function() { var e, t = []; for (var n in a.selected)(e = a.options[n]) ? t.push(e.value) : t.push(a.selected[n]); var i = h.getModelOption(a.ngModel, "trackBy"),
                            o = a.isMultiple ? t : t[0],
                            r = a.ngModel.$modelValue;
                        (i ? se.equals(r, o) : r + "" === o) || (a.ngModel.$setViewValue(o), a.ngModel.$render()) } } }

            function n(i, o, c) { return e.$inject = ["$element"], { restrict: "E", require: ["mdOption", "^^mdSelectMenu"], controller: e, compile: function(e, t) { e.append(se.element('<div class="md-text">').append(e.contents())), e.attr("tabindex", t.tabindex || "0"),
                            function(e) { var t = e.value,
                                    n = e.ngValue; return t || n }(t) || e.attr("md-option-empty", ""); return n } };

                function n(r, t, e, n) { var a = n[0],
                        s = n[1];

                    function l(e, t, n) { if (s.hashGetter) { var i = s.hashGetter(t, r),
                                o = s.hashGetter(e, r);
                            a.hashKey = o, a.value = e, s.removeOption(i, a), s.addOption(o, a) } else n || r.$$postDigest(function() { l(e, t, !0) }) }
                    c(t), s.isMultiple && (t.addClass("md-checkbox-enabled"), t.prepend(d.clone())), se.isDefined(e.ngValue) ? r.$watch(e.ngValue, l) : se.isDefined(e.value) ? l(e.value) : r.$watch(function() { return t.text().trim() }, l), e.$observe("disabled", function(e) { e ? t.attr("tabindex", "-1") : t.attr("tabindex", "0") }), r.$$postDigest(function() { e.$observe("selected", function(e) { se.isDefined(e) && ("string" == typeof e && (e = !0), e ? (s.isMultiple || s.deselect(Object.keys(s.selected)[0]), s.select(a.hashKey, a.value)) : s.deselect(a.hashKey), s.refreshViewValue()) }) }), i.attach(r, t),
                        function() { var e = { role: "option", "aria-selected": "false" };
                            t[0].hasAttribute("id") || (e.id = "select_option_" + o.nextUid());
                            t.attr(e) }(), r.$on("$destroy", function() { s.removeOption(a.hashKey, a) }) }

                function e(t) { this.selected = !1, this.setSelected = function(e) { e && !this.selected ? t.attr({ selected: "selected", "aria-selected": "true" }) : !e && this.selected && (t.removeAttr("selected"), t.attr("aria-selected", "false")), this.selected = e } } }

            function i(e) { return t.$inject = ["$mdSelect", "$mdConstant", "$mdUtil", "$window", "$q", "$$rAF", "$animateCss", "$animate", "$document"], e("$mdSelect").setDefaults({ methods: ["target"], options: t });

                function t(l, c, P, L, r, n, d, u, R) { var m = P.dom.animator,
                        p = c.KEY_CODE; return { parent: "body", themable: !0, onShow: function(o, a, s) { return function() { s.loadingAsync && !s.isRemoved && (o.$$loadingAsyncDone = !1, r.when(s.loadingAsync).then(function() { o.$$loadingAsyncDone = !0, delete s.loadingAsync }).then(function() { n(i) })) }(),
                                function(e) { var t = a.find("md-select-menu"); if (!e.target) throw new Error(P.supplant("$mdSelect.show() expected a target element in options.target but got '{0}'!", [e.target]));
                                    se.extend(e, { isRemoved: !1, target: se.element(e.target), parent: se.element(e.parent), selectEl: t, contentEl: a.find("md-content"), optionNodes: t[0].getElementsByTagName("md-option") }) }(s), s.hideBackdrop = function(e, t) { t.disableParentScroll && !P.getClosest(t.target, "MD-DIALOG") ? t.restoreScroll = P.disableScrollAround(t.element, t.parent) : t.disableParentScroll = !1;
                                    t.hasBackdrop && (t.backdrop = P.createBackdrop(e, "md-select-backdrop md-click-catcher"), u.enter(t.backdrop, R[0].body, null, { duration: 0 })); return function() { t.backdrop && t.backdrop.remove(), t.disableParentScroll && t.restoreScroll(), delete t.restoreScroll } }(o, s),
                                function(n, e) { e.parent !== n.parent() && n.parent().attr("aria-owns", n.attr("id")); return n.parent().find("md-select-value").attr("aria-hidden", "true"), e.parent.append(n), r(function(e, t) { try { d(n, { removeClass: "md-leave", duration: 0 }).start().then(i).then(e) } catch (e) { t(e) } }) }(a, s).then(function(e) { var t, n, i; return a.attr("aria-hidden", "false"), s.alreadyOpen = !0, s.cleanupInteraction = function() { if (s.isRemoved) return; var i = s.selectEl,
                                            t = i.controller("mdSelectMenu") || {}; return a.addClass("md-clickable"), s.backdrop && s.backdrop.on("click", e), i.on("keydown", n), i.on("click", r),
                                            function() { s.backdrop && s.backdrop.off("click", e), i.off("keydown", n), i.off("click", r), a.removeClass("md-clickable"), s.isRemoved = !0 };

                                        function e(e) { e.preventDefault(), e.stopPropagation(), s.restoreFocus = !1, P.nextTick(l.hide, !0) }

                                        function n(e) { switch (e.preventDefault(), e.stopPropagation(), e.keyCode) {
                                                case p.UP_ARROW:
                                                    return void o("prev");
                                                case p.DOWN_ARROW:
                                                    return void o("next");
                                                case p.SPACE:
                                                case p.ENTER:
                                                    var t = P.getClosest(e.target, "md-option");
                                                    t && (i.triggerHandler({ type: "click", target: t }), e.preventDefault()), r(e); break;
                                                case p.TAB:
                                                case p.ESCAPE:
                                                    e.stopPropagation(), e.preventDefault(), s.restoreFocus = !0, P.nextTick(l.hide, !0); break;
                                                default:
                                                    if (B(e, c)) { var n = i.controller("mdSelectMenu").optNodeForKeyboardSearch(e);
                                                        s.focusedNode = n || s.focusedNode, n && n.focus() } } }

                                        function o(e) { for (var t, n = P.nodesToArray(s.optionNodes), i = n.indexOf(s.focusedNode); - 1 === i ? i = 0 : "next" === e && i < n.length - 1 ? i++ : "prev" === e && 0 < i && i--, (t = n[i]).hasAttribute("disabled") && (t = le), !t && i < n.length - 1 && 0 < i;);
                                            t && t.focus(), s.focusedNode = t }

                                        function r(n) { if (!(n && "click" == n.type && n.currentTarget != i[0] || function() { var e = !1; if (n && 0 < n.currentTarget.children.length) { var t = n.currentTarget.children[0]; if (t.scrollHeight > t.clientHeight && 0 < t.children.length) n.pageX - n.currentTarget.getBoundingClientRect().left > t.querySelector("md-option").offsetWidth && (e = !0) } return e }())) { var e = P.getClosest(n.target, "md-option");
                                                e && e.hasAttribute && !e.hasAttribute("disabled") && (n.preventDefault(), n.stopPropagation(), t.isMultiple || (s.restoreFocus = !0, P.nextTick(function() { l.hide(t.ngModel.$viewValue) }, !0))) } } }(), s.cleanupResizing = (t = function(i, o, r) { return function() { if (!r.isRemoved) { var e = h(i, o, r),
                                                    t = e.container,
                                                    n = e.dropDown;
                                                t.element.css(m.toCss(t.styles)), n.element.css(m.toCss(n.styles)) } } }(o, a, s), (n = se.element(L)).on("resize", t), n.on("orientationchange", t), function() { n.off("resize", t), n.off("orientationchange", t) }), (i = s.focusedNode) && !i.hasAttribute("disabled") && i.focus(), e }, s.hideBackdrop);

                            function i() { return r(function(e) { if (s.isRemoved) return r.reject(!1); var t = h(o, a, s);
                                    t.container.element.css(m.toCss(t.container.styles)), t.dropDown.element.css(m.toCss(t.dropDown.styles)), n(function() { a.addClass("md-active"), t.dropDown.element.css(m.toCss({ transform: "" })), e() }) }) } }, onRemove: function(e, t, n) { var i = null,
                                o = e.$on("$destroy", function() { i.end() }); return (n = n || {}).cleanupInteraction(), n.cleanupResizing(), n.hideBackdrop(), !0 === n.$destroy ? r() : function() { return (i = d(t, { addClass: "md-leave" })).start() }().then(r);

                            function r() { o(), t.removeClass("md-active").attr("aria-hidden", "true").css("display", "none"), t.parent().find("md-select-value").removeAttr("aria-hidden"),
                                    function(e) { var t = e.selectCtrl; if (t) { var n = e.selectEl.controller("mdSelectMenu");
                                            t.setLabelText(n ? n.selectedLabels() : ""), t.triggerClose() } }(n), !n.$destroy && n.restoreFocus && n.target.focus() } }, hasBackdrop: !0, disableParentScroll: !0 };

                    function h(e, t, n) { var i, o, r = t[0],
                            a = n.target[0].children[0],
                            s = R[0].body,
                            l = n.selectEl[0],
                            c = n.contentEl[0],
                            d = s.getBoundingClientRect(),
                            u = a.getBoundingClientRect(),
                            m = { left: d.left + F, top: F, bottom: d.height - F, right: d.width - F - (P.floatingScrollbars() ? 16 : 0) },
                            p = u.top - m.top,
                            h = (u.left, u.left, u.width, m.bottom - (u.top + u.height)),
                            f = d.width - 2 * F,
                            g = l.querySelector("md-option[selected]"),
                            v = l.getElementsByTagName("md-option"),
                            b = l.getElementsByTagName("md-optgroup"),
                            $ = function(e, t) { var n = !1; try { var i = e[0].style.display;
                                    e[0].style.display = "block", n = t.scrollHeight > t.offsetHeight, e[0].style.display = i } finally {} return n }(t, c);
                        i = (o = n.loadingAsync) && se.isFunction(o.then) ? c.firstElementChild || c : g || (b.length ? b[0] : v.length ? v[0] : c.firstElementChild || c), c.offsetWidth > f ? c.style["max-width"] = f + "px" : c.style.maxWidth = null, $ && l.classList.add("md-overflow"); var C = i; "MD-OPTGROUP" === (C.tagName || "").toUpperCase() && (i = C = v[0] || c.firstElementChild || c), n.focusedNode = C, r.style.display = "block"; var y, x, w, T, E, A, S = l.getBoundingClientRect(),
                            k = (y = i) ? { left: y.offsetLeft, top: y.offsetTop, width: y.offsetWidth, height: y.offsetHeight } : { left: 0, top: 0, width: 0, height: 0 }; if (i) { var M = L.getComputedStyle(i);
                            k.paddingLeft = parseInt(M.paddingLeft, 10) || 0, k.paddingRight = parseInt(M.paddingRight, 10) || 0 } if ($) { var D = c.offsetHeight / 2;
                            c.scrollTop = k.top + k.height / 2 - D, p < D ? c.scrollTop = Math.min(k.top, c.scrollTop + D - p) : h < D && (c.scrollTop = Math.max(k.top + k.height - S.height, c.scrollTop - D + h)) }
                        x = u.left + k.left - k.paddingLeft + 2, w = Math.floor(u.top + u.height / 2 - k.height / 2 - k.top + c.scrollTop) + 2, T = k.left + u.width / 2 + "px " + (k.top + k.height / 2 - c.scrollTop) + "px 0px", E = Math.min(u.width + k.paddingLeft + k.paddingRight, f), A = j.getComputedStyle(a)["font-size"]; var I = r.getBoundingClientRect(),
                            _ = Math.round(100 * Math.min(u.width / S.width, 1)) / 100,
                            O = Math.round(100 * Math.min(u.height / S.height, 1)) / 100; return { container: { element: se.element(r), styles: { left: Math.floor(N(m.left, x, m.right - I.width)), top: Math.floor(N(m.top, w, m.bottom - I.height)), "min-width": E, "font-size": A } }, dropDown: { element: se.element(l), styles: { transformOrigin: T, transform: n.alreadyOpen ? "" : P.supplant("scale({0},{1})", [_, O]) } } } } }

                function N(e, t, n) { return Math.max(e, Math.min(t, n)) } }

            function B(e, t) { var n = String.fromCharCode(e.keyCode),
                    i = e.keyCode <= 31; return n && n.length && !i && !t.isMetaKey(e) && !t.isFnLockKey(e) && !t.hasModifierKey(e) }
            se.module("material.components.select", ["material.core", "material.components.backdrop"]).directive("mdSelect", e).directive("mdSelectMenu", t).directive("mdOption", n).directive("mdOptgroup", function() { return { restrict: "E", compile: function(t, n) { t.parent().find("md-select-header").length || function() { var e = t.find("label");
                            e.length || (e = se.element("<label>"), t.prepend(e));
                            e.addClass("md-container-ignore"), e.attr("aria-hidden", "true"), n.label && e.text(n.label) }() } } }).directive("mdSelectHeader", function() { return { restrict: "E" } }).provider("$mdSelect", i) }(), se.module("material.components.showHide", ["material.core"]).directive("ngShow", Se("ngShow", !0)).directive("ngHide", Se("ngHide", !1)), ke.$inject = ["$mdComponentRegistry", "$mdUtil", "$q", "$log"], Me.$inject = ["$mdMedia", "$mdUtil", "$mdConstant", "$mdTheming", "$mdInteraction", "$animate", "$compile", "$parse", "$log", "$q", "$document", "$window", "$$rAF"], De.$inject = ["$scope", "$attrs", "$mdComponentRegistry", "$q", "$interpolate"], se.module("material.components.sidenav", ["material.core", "material.components.backdrop"]).factory("$mdSidenav", ke).directive("mdSidenav", Me).directive("mdSidenavFocus", function() { return { restrict: "A", require: "^mdSidenav", link: function(e, t, n, i) {} } }).controller("$mdSidenavController", De), Ie.$inject = ["$$rAF", "$window", "$mdAria", "$mdUtil", "$mdConstant", "$mdTheming", "$mdGesture", "$parse", "$log", "$timeout"], se.module("material.components.slider", ["material.core"]).directive("mdSlider", Ie).directive("mdSliderContainer", function() { return { controller: function() {}, compile: function(e) { var t = e.find("md-slider"); if (t) return t.attr("md-vertical") !== le && e.attr("md-vertical", ""), t.attr("flex") || t.attr("flex", ""),
                        function(e, a, t, n) {
                            function i(e) { a.children().attr("disabled", e), a.find("input").attr("disabled", e) }
                            a.addClass("_md"); var s, o = se.noop;
                            t.disabled ? i(!0) : t.ngDisabled && (o = e.$watch(t.ngDisabled, function(e) { i(e) })), e.$on("$destroy", function() { o() }), n.fitInputWidthToTextLength = function(e) { var t = a[0].querySelector("md-input-container"); if (t) { var n = getComputedStyle(t),
                                        i = parseInt(n.minWidth),
                                        o = 2 * parseInt(n.padding);
                                    s = s || parseInt(n.maxWidth); var r = Math.max(s, i + o + i / 2 * e);
                                    t.style.maxWidth = r + "px" } } } } } }), _e.$inject = ["$mdConstant", "$$rAF", "$mdUtil", "$compile"], se.module("material.components.sticky", ["material.core", "material.components.content"]).factory("$mdSticky", _e), Oe.$inject = ["$mdSticky", "$compile", "$mdTheming", "$mdUtil", "$mdAria"], se.module("material.components.subheader", ["material.core", "material.components.sticky"]).directive("mdSubheader", Oe), se.module("material.components.swipe", ["material.core"]).directive("mdSwipeLeft", Pe("SwipeLeft")).directive("mdSwipeRight", Pe("SwipeRight")).directive("mdSwipeUp", Pe("SwipeUp")).directive("mdSwipeDown", Pe("SwipeDown")), Le.$inject = ["mdCheckboxDirective", "$mdUtil", "$mdConstant", "$parse", "$$rAF", "$mdGesture", "$timeout"], se.module("material.components.switch", ["material.core", "material.components.checkbox"]).directive("mdSwitch", Le), se.module("material.components.tabs", ["material.core", "material.components.icon"]), se.module("material.components.tabs").service("MdTabsPaginationService", function() { return { decreasePageOffset: function(e, t) { var n, i, o = e.canvas,
                        r = s(e); for (n = 0; n < r.length; n++)
                        if (r[n] >= t) { i = r[n]; break }
                    return Math.max(0, i - o.clientWidth) }, increasePageOffset: function(e, t) { var n, i, o = e.canvas,
                        r = l(e) - o.clientWidth,
                        a = s(e); for (n = 0; a.length, a[n] <= t + o.clientWidth; n++) i = a[n]; return Math.min(r, i) }, getTabOffsets: s, getTotalTabsWidth: l };

            function s(e) { var t, n, i = 0,
                    o = []; for (t = 0; t < e.tabs.length; t++) n = e.tabs[t], o.push(i), i += n.offsetWidth; return o }

            function l(e) { var t, n = 0; for (t = 0; t < e.tabs.length; t++) n += e.tabs[t].offsetWidth; return n } }), Re.$inject = ["$mdToast"], Ne.$inject = ["$$interimElementProvider"], se.module("material.components.toast", ["material.core", "material.components.button"]).directive("mdToast", Re).provider("$mdToast", Ne), Fe.$inject = ["$$rAF", "$mdConstant", "$mdUtil", "$mdTheming", "$animate"], se.module("material.components.toolbar", ["material.core", "material.components.content"]).directive("mdToolbar", Fe), Be.$inject = ["$timeout", "$window", "$$rAF", "$document", "$interpolate", "$mdUtil", "$mdPanel", "$$mdTooltipRegistry"], se.module("material.components.tooltip", ["material.core", "material.components.panel"]).directive("mdTooltip", Be).service("$$mdTooltipRegistry", function() { var r = {},
                a = se.element(j); return { register: function(e, t, n) { var i = r[e] = r[e] || [];
                    i.length || (n ? j.addEventListener(e, s, !0) : a.on(e, s)); - 1 === i.indexOf(t) && i.push(t) }, deregister: function(e, t, n) { var i = r[e],
                        o = i ? i.indexOf(t) : -1; - 1 < o && (i.splice(o, 1), 0 === i.length && (n ? j.removeEventListener(e, s, !0) : a.off(e, s))) } };

            function s(t) { r[t.type] && r[t.type].forEach(function(e) { e.call(this, t) }, this) } }), je.$inject = ["$element"], se.module("material.components.truncate", ["material.core"]).directive("mdTruncate", function() { return { restrict: "AE", controller: je, controllerAs: "$ctrl", bindToController: !0 } }),
        function() {
            function e(e) { return '<div class="md-virtual-repeat-scroller" role="presentation"><div class="md-virtual-repeat-sizer" role="presentation"></div><div class="md-virtual-repeat-offsetter" role="presentation">' + e[0].innerHTML + "</div></div>" }
            t.$inject = ["$$rAF", "$mdUtil", "$mdConstant", "$parse", "$rootScope", "$window", "$scope", "$element", "$attrs"], o.$inject = ["$scope", "$element", "$attrs", "$browser", "$document", "$rootScope", "$$rAF", "$mdUtil"], n.$inject = ["$parse"], se.module("material.components.virtualRepeat", ["material.core", "material.components.showHide"]).directive("mdVirtualRepeatContainer", function() { return { controller: t, template: e, compile: function(e, t) { e.addClass("md-virtual-repeat-container").addClass(t.hasOwnProperty("mdOrientHorizontal") ? "md-orient-horizontal" : "md-orient-vertical") } } }).directive("mdVirtualRepeat", n).directive("mdForceHeight", r);

            function t(e, n, t, i, o, r, a, s, l) { this.$rootScope = o, this.$scope = a, this.$element = s, this.$attrs = l, this.size = 0, this.scrollSize = 0, this.scrollOffset = 0, this.horizontal = this.$attrs.hasOwnProperty("mdOrientHorizontal"), this.repeater = null, this.autoShrink = this.$attrs.hasOwnProperty("mdAutoShrink"), this.autoShrinkMin = parseInt(this.$attrs.mdAutoShrinkMin, 10) || 0, this.originalSize = null, this.offsetSize = parseInt(this.$attrs.mdOffsetSize, 10) || 0, this.oldElementSize = null, this.maxElementPixels = t.ELEMENT_MAX_PIXELS, this.$attrs.mdTopIndex ? (this.bindTopIndex = i(this.$attrs.mdTopIndex), this.topIndex = this.bindTopIndex(this.$scope), se.isDefined(this.topIndex) || (this.topIndex = 0, this.bindTopIndex.assign(this.$scope, 0)), this.$scope.$watch(this.bindTopIndex, se.bind(this, function(e) { e !== this.topIndex && this.scrollToIndex(e) }))) : this.topIndex = 0, this.scroller = s[0].querySelector(".md-virtual-repeat-scroller"), this.sizer = this.scroller.querySelector(".md-virtual-repeat-sizer"), this.offsetter = this.scroller.querySelector(".md-virtual-repeat-offsetter"); var c = se.bind(this, this.updateSize);
                e(se.bind(this, function() { c(); var e = n.debounce(c, 10, null, !1),
                        t = se.element(r);
                    this.size || e(), t.on("resize", e), a.$on("$destroy", function() { t.off("resize", e) }), a.$emit("$md-resize-enable"), a.$on("$md-resize", c) })) }

            function n(i) { return { controller: o, priority: 1e3, require: ["mdVirtualRepeat", "^^mdVirtualRepeatContainer"], restrict: "A", terminal: !0, transclude: "element", compile: function(e, t) { var n = t.mdVirtualRepeat.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)\s*$/),
                            r = n[1],
                            a = i(n[2]),
                            s = t.mdExtraName && i(t.mdExtraName); return function(e, t, n, i, o) { i[0].link_(i[1], o, r, a, s) } } } }

            function o(e, t, n, i, o, r, a, s) { this.$scope = e, this.$element = t, this.$attrs = n, this.$browser = i, this.$document = o, this.$mdUtil = s, this.$rootScope = r, this.$$rAF = a, this.onDemand = s.parseAttributeBoolean(n.mdOnDemand), this.browserCheckUrlChange = i.$$checkUrlChange, this.newStartIndex = 0, this.newEndIndex = 0, this.newVisibleEnd = 0, this.startIndex = 0, this.endIndex = 0, this.itemSize = e.$eval(n.mdItemSize) || null, this.isFirstRender = !0, this.isVirtualRepeatUpdating_ = !1, this.itemsLength = 0, this.unwatchItemSize_ = se.noop, this.blocks = {}, this.pooledBlocks = [], e.$on("$destroy", se.bind(this, this.cleanupBlocks_)) }

            function i(e) { if (!se.isFunction(e.getItemAtIndex) || !se.isFunction(e.getLength)) throw Error("When md-on-demand is enabled, the Object passed to md-virtual-repeat must implement functions getItemAtIndex() and getLength() ");
                this.model = e }

            function r(e) { return { restrict: "A", link: function(e, t, n) { var i = e.$eval(n.mdForceHeight) || null;
                        i && t && (t[0].style.height = i) } } }
            t.prototype.register = function(e) { this.repeater = e, se.element(this.scroller).on("scroll wheel touchmove touchend", se.bind(this, this.handleScroll_)) }, t.prototype.isHorizontal = function() { return this.horizontal }, t.prototype.getSize = function() { return this.size }, t.prototype.setSize_ = function(e) { var t = this.getDimensionName_();
                this.size = e, this.$element[0].style[t] = e + "px" }, t.prototype.unsetSize_ = function() { this.$element[0].style[this.getDimensionName_()] = this.oldElementSize, this.oldElementSize = null }, t.prototype.updateSize = function() { this.originalSize || (this.size = this.isHorizontal() ? this.$element[0].clientWidth : this.$element[0].clientHeight, this.handleScroll_(), this.repeater && this.repeater.containerUpdated()) }, t.prototype.getScrollSize = function() { return this.scrollSize }, t.prototype.getDimensionName_ = function() { return this.isHorizontal() ? "width" : "height" }, t.prototype.sizeScroller_ = function(e) { var t = this.getDimensionName_(),
                    n = this.isHorizontal() ? "height" : "width"; if (this.sizer.innerHTML = "", e < this.maxElementPixels) this.sizer.style[t] = e + "px";
                else { this.sizer.style[t] = "auto", this.sizer.style[n] = "auto"; var i = Math.floor(e / this.maxElementPixels),
                        o = document.createElement("div");
                    o.style[t] = this.maxElementPixels + "px", o.style[n] = "1px"; for (var r = 0; r < i; r++) this.sizer.appendChild(o.cloneNode(!1));
                    o.style[t] = e - i * this.maxElementPixels + "px", this.sizer.appendChild(o) } }, t.prototype.autoShrink_ = function(e) { var t = Math.max(e, this.autoShrinkMin * this.repeater.getItemSize()); if (this.autoShrink && t !== this.size) { null === this.oldElementSize && (this.oldElementSize = this.$element[0].style[this.getDimensionName_()]); var n = this.originalSize || this.size; if (!n || t < n) this.originalSize || (this.originalSize = this.size), this.setSize_(t);
                    else if (null !== this.originalSize) { this.unsetSize_(); var i = this.originalSize;
                        this.originalSize = null, i || this.updateSize(), this.setSize_(i || this.size) }
                    this.repeater.containerUpdated() } }, t.prototype.setScrollSize = function(e) { var t = e + this.offsetSize;
                this.scrollSize !== t && (this.sizeScroller_(t), this.autoShrink_(t), this.scrollSize = t) }, t.prototype.getScrollOffset = function() { return this.scrollOffset }, t.prototype.scrollTo = function(e) { this.scroller[this.isHorizontal() ? "scrollLeft" : "scrollTop"] = e, this.handleScroll_() }, t.prototype.scrollToIndex = function(e) { var t = this.repeater.getItemSize(),
                    n = this.repeater.itemsLength;
                n < e && (e = n - 1), this.scrollTo(t * e) }, t.prototype.resetScroll = function() { this.scrollTo(0) }, t.prototype.handleScroll_ = function() { var e = "rtl" != document.dir && "rtl" != document.body.dir;
                e || this.maxSize || (this.scroller.scrollLeft = this.scrollSize, this.maxSize = this.scroller.scrollLeft); var t = this.isHorizontal() ? e ? this.scroller.scrollLeft : this.maxSize - this.scroller.scrollLeft : this.scroller.scrollTop; if (!(t === this.scrollOffset || t > this.scrollSize - this.size)) { var n = this.repeater.getItemSize(); if (n) { var i = Math.max(0, Math.floor(t / n) - 3),
                            o = (this.isHorizontal() ? "translateX(" : "translateY(") + (!this.isHorizontal() || e ? i * n : -i * n) + "px)"; if (this.scrollOffset = t, this.offsetter.style.webkitTransform = o, this.offsetter.style.transform = o, this.bindTopIndex) { var r = Math.floor(t / n);
                            r !== this.topIndex && r < this.repeater.getItemCount() && (this.topIndex = r, this.bindTopIndex.assign(this.$scope, r), this.$rootScope.$$phase || this.$scope.$digest()) }
                        this.repeater.containerUpdated() } } }, o.prototype.link_ = function(e, t, n, i, o) { this.container = e, this.transclude = t, this.repeatName = n, this.rawRepeatListExpression = i, this.extraName = o, this.sized = !1, this.repeatListExpression = se.bind(this, this.repeatListExpression_), this.container.register(this) }, o.prototype.cleanupBlocks_ = function() { se.forEach(this.pooledBlocks, function(e) { e.element.remove() }) }, o.prototype.readItemSize_ = function() { if (!this.itemSize) { this.items = this.repeatListExpression(this.$scope), this.parentNode = this.$element[0].parentNode; var e = this.getBlock_(0);
                    e.element[0].parentNode || this.parentNode.appendChild(e.element[0]), this.itemSize = e.element[0][this.container.isHorizontal() ? "offsetWidth" : "offsetHeight"] || null, this.blocks[0] = e, this.poolBlock_(0), this.itemSize && this.containerUpdated() } }, o.prototype.repeatListExpression_ = function(e) { var t = this.rawRepeatListExpression(e); if (this.onDemand && t) { var n = new i(t); return n.$$includeIndexes(this.newStartIndex, this.newVisibleEnd), n } return t }, o.prototype.containerUpdated = function() { if (!this.itemSize) return this.unwatchItemSize_ && this.unwatchItemSize_ !== se.noop && this.unwatchItemSize_(), this.unwatchItemSize_ = this.$scope.$watchCollection(this.repeatListExpression, se.bind(this, function(e) { e && e.length && this.readItemSize_() })), void(this.$rootScope.$$phase || this.$scope.$digest());
                this.sized || (this.items = this.repeatListExpression(this.$scope)), this.sized || (this.unwatchItemSize_(), this.sized = !0, this.$scope.$watchCollection(this.repeatListExpression, se.bind(this, function(e, t) { this.isVirtualRepeatUpdating_ || this.virtualRepeatUpdate_(e, t) }))), this.updateIndexes_(), (this.newStartIndex !== this.startIndex || this.newEndIndex !== this.endIndex || this.container.getScrollOffset() > this.container.getScrollSize()) && (this.items instanceof i && this.items.$$includeIndexes(this.newStartIndex, this.newEndIndex), this.virtualRepeatUpdate_(this.items, this.items)) }, o.prototype.getItemSize = function() { return this.itemSize }, o.prototype.getItemCount = function() { return this.itemsLength }, o.prototype.virtualRepeatUpdate_ = function(e, t) { this.isVirtualRepeatUpdating_ = !0; var n = e && e.length || 0,
                    i = !1; if (this.items && n < this.items.length && 0 !== this.container.getScrollOffset()) { this.items = e; var o = this.container.getScrollOffset();
                    this.container.resetScroll(), this.container.scrollTo(o) }
                n !== this.itemsLength && (i = !0, this.itemsLength = n), (this.items = e) === t && !i || this.updateIndexes_(), this.parentNode = this.$element[0].parentNode, i && this.container.setScrollSize(n * this.itemSize), Object.keys(this.blocks).forEach(function(e) { var t = parseInt(e, 10);
                    (t < this.newStartIndex || t >= this.newEndIndex) && this.poolBlock_(t) }, this), this.$browser.$$checkUrlChange = se.noop; var r, a, s = [],
                    l = []; for (r = this.newStartIndex; r < this.newEndIndex && null == this.blocks[r]; r++) a = this.getBlock_(r), this.updateBlock_(a, r), s.push(a); for (; null != this.blocks[r]; r++) this.updateBlock_(this.blocks[r], r); for (var c = r - 1; r < this.newEndIndex; r++) a = this.getBlock_(r), this.updateBlock_(a, r), l.push(a); if (s.length && this.parentNode.insertBefore(this.domFragmentFromBlocks_(s), this.$element[0].nextSibling), l.length && this.parentNode.insertBefore(this.domFragmentFromBlocks_(l), this.blocks[c] && this.blocks[c].element[0].nextSibling), this.$browser.$$checkUrlChange = this.browserCheckUrlChange, this.startIndex = this.newStartIndex, this.endIndex = this.newEndIndex, this.isFirstRender) { this.isFirstRender = !1; var d = this.$attrs.mdStartIndex ? this.$scope.$eval(this.$attrs.mdStartIndex) : this.container.topIndex;
                    this.$mdUtil.nextTick(function() { this.container.scrollToIndex(d) }.bind(this)) }
                this.isVirtualRepeatUpdating_ = !1 }, o.prototype.getBlock_ = function(n) { return this.pooledBlocks.length ? this.pooledBlocks.pop() : (this.transclude(se.bind(this, function(e, t) { i = { element: e, new: !0, scope: t }, this.updateScope_(t, n), this.parentNode.appendChild(e[0]) })), i); var i }, o.prototype.updateBlock_ = function(e, t) {!(this.blocks[t] = e).new && e.scope.$index === t && e.scope[this.repeatName] === this.items[t] || (e.new = !1, this.updateScope_(e.scope, t), this.$rootScope.$$phase || e.scope.$digest()) }, o.prototype.updateScope_ = function(e, t) { e.$index = t, e[this.repeatName] = this.items && this.items[t], this.extraName && (e[this.extraName(this.$scope)] = this.items[t]) }, o.prototype.poolBlock_ = function(e) { this.pooledBlocks.push(this.blocks[e]), this.parentNode.removeChild(this.blocks[e].element[0]), delete this.blocks[e] }, o.prototype.domFragmentFromBlocks_ = function(e) { var t = this.$document[0].createDocumentFragment(); return e.forEach(function(e) { t.appendChild(e.element[0]) }), t }, o.prototype.updateIndexes_ = function() { var e = this.items ? this.items.length : 0,
                    t = Math.ceil(this.container.getSize() / this.itemSize);
                this.newStartIndex = Math.max(0, Math.min(e - t, Math.floor(this.container.getScrollOffset() / this.itemSize))), this.newVisibleEnd = this.newStartIndex + t + 3, this.newEndIndex = Math.min(e, this.newVisibleEnd), this.newStartIndex = Math.max(0, this.newStartIndex - 3) }, i.prototype.$$includeIndexes = function(e, t) { for (var n = e; n < t; n++) this.hasOwnProperty(n) || (this[n] = this.model.getItemAtIndex(n));
                this.length = this.model.getLength() }, r.$inject = ["$mdUtil"] }(), Ue.$inject = ["$log"], se.module("material.components.whiteframe", ["material.core"]).directive("mdWhiteframe", Ue),
        function() { e.$inject = ["$scope", "$element", "$mdUtil", "$mdConstant", "$mdTheming", "$window", "$animate", "$rootElement", "$attrs", "$q", "$log", "$mdLiveAnnouncer"], se.module("material.components.autocomplete").controller("MdAutocompleteCtrl", e); var ie = 48,
                oe = 5,
                re = 8,
                ae = 2;

            function e(m, p, h, t, n, i, o, r, f, a, s, l) { var e, c, d, u = this,
                    g = m.itemsExpr.split(/ in /i),
                    v = g[1],
                    b = null,
                    $ = {},
                    C = !1,
                    y = [],
                    x = !1,
                    w = 0,
                    T = null,
                    E = null,
                    A = h.debounce(function() { u.hidden || M() });
                e = "hidden", c = function(e, t) {!e && t ? (M(), X(!0, S.Count | S.Selected), b && (h.disableScrollAround(b.ul), T = function(e) {
                        function t(e) { e.preventDefault() } return e.on("wheel", t), e.on("touchmove", t),
                            function() { e.off("wheel", t), e.off("touchmove", t) } }(se.element(b.wrap)))) : e && !t && (h.enableScrolling(), T && (T(), T = null)) }, d = !0, Object.defineProperty(u, e, { get: function() { return d }, set: function(e) { var t = d;
                        c(d = e, t) } }), u.scope = m, u.parent = m.$parent, u.itemName = g[0], u.matches = [], u.loading = !1, u.hidden = !0, u.index = null, u.id = h.nextUid(), u.isDisabled = null, u.isRequired = null, u.isReadonly = null, u.hasNotFound = !1, u.keydown = function(e) { switch (e.keyCode) {
                        case t.KEY_CODE.DOWN_ARROW:
                            if (u.loading) return;
                            e.stopPropagation(), e.preventDefault(), u.index = Math.min(u.index + 1, u.matches.length - 1), Q(), X(!1, S.Selected); break;
                        case t.KEY_CODE.UP_ARROW:
                            if (u.loading) return;
                            e.stopPropagation(), e.preventDefault(), u.index = u.index < 0 ? u.matches.length - 1 : Math.max(0, u.index - 1), Q(), X(!1, S.Selected); break;
                        case t.KEY_CODE.TAB:
                            if (_(), u.hidden || u.loading || u.index < 0 || u.matches.length < 1) return;
                            V(u.index); break;
                        case t.KEY_CODE.ENTER:
                            if (u.hidden || u.loading || u.index < 0 || u.matches.length < 1) return; if (H()) return;
                            e.stopPropagation(), e.preventDefault(), V(u.index); break;
                        case t.KEY_CODE.ESCAPE:
                            if (e.preventDefault(), !(U("blur") || !u.hidden || u.loading || U("clear") && m.searchText)) return;
                            e.stopPropagation(), Y(), m.searchText && U("clear") && K(), u.hidden = !0, U("blur") && function(e) { e && (x = C = !1);
                                b.input.blur() }(!0) } }, u.blur = function(e) { x = !1, C || (u.hidden = B(), ne("ngBlur", { $event: e })) }, u.focus = function(e) { x = !0, j() && W() && ee();
                    u.hidden = B(), ne("ngFocus", { $event: e }) }, u.clear = function() { Y(), K() }, u.select = V, u.listEnter = function() { C = !0 }, u.listLeave = _, u.mouseUp = function() { b.input.focus() }, u.getCurrentDisplayValue = z, u.registerSelectedItemWatcher = function(e) {-1 == y.indexOf(e) && y.push(e) }, u.unregisterSelectedItemWatcher = function(e) { var t = y.indexOf(e); - 1 != t && y.splice(t, 1) }, u.notFoundVisible = J, u.loadingIsVisible = function() { return u.loading && !H() }, u.positionDropdown = M; var S = { Count: 1, Selected: 2 }; return h.initOptionalProperties(m, f, { searchText: "", selectedItem: null, clearButton: !1 }), n(p),
                    function() { var e = parseInt(m.delay, 10) || 0;
                        f.$observe("disabled", function(e) { u.isDisabled = h.parseAttributeBoolean(e, !1) }), f.$observe("required", function(e) { u.isRequired = h.parseAttributeBoolean(e, !1) }), f.$observe("readonly", function(e) { u.isReadonly = h.parseAttributeBoolean(e, !1) }), m.$watch("searchText", e ? h.debounce(P, e) : P), m.$watch("selectedItem", O), se.element(i).on("resize", A), m.$on("$destroy", I) }(), void h.nextTick(function() { var e;
                        e = function() { var e, t; for (e = p; e.length && (t = e.attr("md-autocomplete-snap"), !se.isDefined(t)); e = e.parent()); if (e.length) return { snap: e[0], wrap: "width" === t.toLowerCase() ? e[0] : p.find("md-autocomplete-wrap")[0] }; var n = p.find("md-autocomplete-wrap")[0]; return { snap: n, wrap: n } }(), (b = { main: p[0], scrollContainer: p[0].querySelector(".md-virtual-repeat-container"), scroller: p[0].querySelector(".md-virtual-repeat-scroller"), ul: p.find("ul")[0], input: p.find("input")[0], wrap: e.wrap, snap: e.snap, root: document.body }).li = b.ul.getElementsByTagName("li"), b.$ = function(e) { var t = {}; for (var n in e) e.hasOwnProperty(n) && (t[n] = se.element(e[n])); return t }(b), E = b.$.input.controller("ngModel"),
                            function() { if (!b.$.root.length) return;
                                n(b.$.scrollContainer), b.$.scrollContainer.detach(), b.$.root.append(b.$.scrollContainer), o.pin && o.pin(b.$.scrollContainer, r) }(), m.autofocus && p.on("focus", D) });

                function k() { m.requireMatch && E && E.$setValidity("md-require-match", !!m.selectedItem || !m.searchText) }

                function M() { if (!b) return h.nextTick(M, !1, m); var e, t = (m.dropdownItems || oe) * ie,
                        n = b.wrap.getBoundingClientRect(),
                        i = b.snap.getBoundingClientRect(),
                        o = b.root.getBoundingClientRect(),
                        r = i.bottom - o.top,
                        a = o.bottom - i.top,
                        s = n.left - o.left,
                        l = n.width,
                        c = function() { var e = 0,
                                t = p.find("md-input-container"); if (t.length) { var n = t.find("input");
                                e = t.prop("offsetHeight"), e -= n.prop("offsetTop"), e -= n.prop("offsetHeight"), e += t.prop("offsetTop") } return e }(),
                        d = m.dropdownPosition; if (d = d || (a < r && o.height - r - re < t ? "top" : "bottom"), f.mdFloatingLabel && (s += ae, l -= 2 * ae), e = { left: s + "px", minWidth: l + "px", maxWidth: Math.max(n.right - o.left, o.right - n.left) - re + "px" }, "top" === d) e.top = "auto", e.bottom = a + "px", e.maxHeight = Math.min(t, n.top - o.top - re) + "px";
                    else { var u = o.bottom - n.bottom - re + h.getViewportTop();
                        e.top = r - c + "px", e.bottom = "auto", e.maxHeight = Math.min(t, u) + "px" }
                    b.$.scrollContainer.css(e), h.nextTick(function() { var e = b.scrollContainer.getBoundingClientRect(),
                            t = {};
                        e.right > o.right - re && (t.left = n.right - e.width + "px");
                        b.$.scrollContainer.css(t) }, !1) }

                function D() { b.input.focus() }

                function I() { if (u.hidden || h.enableScrolling(), se.element(i).off("resize", A), b) { se.forEach(["ul", "scroller", "scrollContainer", "input"], function(e) { b.$[e].remove() }) } }

                function _() { x || u.hidden || b.input.focus(), C = !1, u.hidden = B() }

                function O(i, o) { k(), i ? R(i).then(function(e) { var t, n;
                        m.searchText = e, t = i, n = o, y.forEach(function(e) { e(t, n) }) }) : o && m.searchText && R(o).then(function(e) { se.isString(m.searchText) && e.toString().toLowerCase() === m.searchText.toLowerCase() && (m.searchText = "") }), i !== o && se.isFunction(m.itemChange) && m.itemChange(N(m.selectedItem)) }

                function P(t, n) { u.index = m.autoselect ? 0 : -1, t !== n && (k(), R(m.selectedItem).then(function(e) { t !== e && (m.selectedItem = null, t !== n && se.isFunction(m.textChange) && m.textChange(), W() ? ee() : (F(!(u.matches = [])), X(!1, S.Count))) })) }

                function L() { return se.isNumber(m.minLength) ? m.minLength : 1 }

                function R(e) { return a.when(((t = e) && m.itemText ? m.itemText(N(t)) : null) || e).then(function(e) { return e && !se.isString(e) && s.warn("md-autocomplete: Could not resolve display value to a string. Please check the `md-item-text` attribute."), e }); var t }

                function N(e) { if (!e) return le; var t = {}; return u.itemName && (t[u.itemName] = e), t }

                function F(e) { u.loading != e && (u.loading = e), u.hidden = B() }

                function B() { return !j() || !(W() && q() || J()) }

                function j() { return !(u.loading && !q()) && (!H() && !!x) }

                function U(e) { return !m.escapeOptions || -1 !== m.escapeOptions.toLowerCase().indexOf(e) }

                function q() { return !!u.matches.length }

                function H() { return !!u.scope.selectedItem }

                function z() { return R(u.matches[u.index]) }

                function W() { return (m.searchText || "").length >= L() }

                function V(e) { h.nextTick(function() { R(u.matches[e]).then(function(e) { var t = b.$.input.controller("ngModel");
                            t.$setViewValue(e), t.$render() }).finally(function() { m.selectedItem = u.matches[e], F(!1) }) }, !1) }

                function Y() { u.index = 0, u.matches = [] }

                function K() { F(!0), m.searchText = ""; var e = document.createEvent("CustomEvent");
                    e.initCustomEvent("change", !0, !0, { value: "" }), b.input.dispatchEvent(e), b.input.blur(), m.searchText = "", b.input.focus() }

                function G(t) { var e = m.$parent.$eval(v),
                        n = t.toLowerCase(),
                        i = se.isArray(e),
                        o = !!e.then;

                    function r(e) { $[n] = e, (t || "") === (m.searchText || "") && te(e) }
                    i ? r(e) : o && function(e) { if (!e) return;
                        e = a.when(e), w++, F(!0), h.nextTick(function() { e.then(r).finally(function() { 0 == --w && F(!1) }) }, !0, m) }(e) }

                function X(e, t) { var n = e ? "polite" : "assertive",
                        i = [];
                    t & S.Selected && -1 !== u.index && i.push(z()), t & S.Count && i.push(a.resolve(function() { switch (u.matches.length) {
                            case 0:
                                return "There are no matches available.";
                            case 1:
                                return "There is 1 match available.";
                            default:
                                return "There are " + u.matches.length + " matches available." } }())), a.all(i).then(function(e) { l.announce(e.join(" "), n) }) }

                function Q() { if (b.li[0]) { var e = b.li[0].offsetHeight,
                            t = e * u.index,
                            n = t + e,
                            i = b.scroller.clientHeight,
                            o = b.scroller.scrollTop;
                        t < o ? Z(t) : o + i < n && Z(n - i) } }

                function Z(e) { b.$.scrollContainer.controller("mdVirtualRepeatContainer").scrollTo(e) }

                function J() { var e = (u.scope.searchText || "").length; return u.hasNotFound && !q() && (!u.loading || 0 !== w) && e >= L() && (x || C) && !H() }

                function ee() { var e = m.searchText || "",
                        t = e.toLowerCase();!m.noCache && $[t] ? te($[t]) : G(e), u.hidden = B() }

                function te(e) { var n, t, i;
                    u.matches = e, u.hidden = B(), u.loading && F(!1), m.selectOnMatch && (n = m.searchText, t = u.matches, i = t[0], 1 === t.length && R(i).then(function(e) { var t = n == e;
                        m.matchInsensitive && !t && (t = n.toLowerCase() == e.toLowerCase()), t && V(0) })), M(), X(!0, S.Count) }

                function ne(e, t) { f[e] && m.$parent.$eval(f[e], t || {}) } } }(), qe.$inject = ["$$mdSvgRegistry"], se.module("material.components.autocomplete").directive("mdAutocomplete", qe), He.$inject = ["$compile", "$mdUtil"], se.module("material.components.autocomplete").directive("mdAutocompleteParentScope", He), ze.$inject = ["$scope", "$element", "$attrs"], se.module("material.components.autocomplete").controller("MdHighlightCtrl", ze), ze.prototype.init = function(t, n) { this.flags = this.$attrs.mdHighlightFlags || "", this.unregisterFn = this.$scope.$watch(function(e) { return { term: t(e), contentText: n(e) } }.bind(this), this.onRender.bind(this), !0), this.$element.on("$destroy", this.unregisterFn) }, ze.prototype.onRender = function(e, t) { var n = e.contentText;
            null !== this.regex && e.term === t.term || (this.regex = this.createRegex(e.term, this.flags)), e.term ? this.ApplyRegex(n) : this.$element.text(n) }, ze.prototype.ApplyRegex = function(e) { var t = this.resolveTokens(e);
            this.$element.empty(), t.forEach(function(e) { if (e.isMatch) { var t = se.element('<span class="highlight">').text(e.text);
                    this.$element.append(t) } else this.$element.append(document.createTextNode(e)) }.bind(this)) }, ze.prototype.resolveTokens = function(i) { var o = [],
                n = 0; return i.replace(this.regex, function(e, t) { r(n, t), o.push({ text: e, isMatch: !0 }), n = t + e.length }), r(n), o;

            function r(e, t) { var n = i.slice(e, t);
                n && o.push(n) } }, ze.prototype.createRegex = function(e, t) { var n = "",
                i = "",
                o = this.sanitizeRegex(e); return 0 <= t.indexOf("^") && (n = "^"), 0 <= t.indexOf("$") && (i = "$"), new RegExp(n + o + i, t.replace(/[$\^]/g, "")) }, ze.prototype.sanitizeRegex = function(e) { return e && e.toString().replace(/[\\\^\$\*\+\?\.\(\)\|\{}\[\]]/g, "\\$&") }, We.$inject = ["$interpolate", "$parse"], se.module("material.components.autocomplete").directive("mdHighlightText", We), Ve.$inject = ["$scope", "$element", "$mdConstant", "$timeout", "$mdUtil"], se.module("material.components.chips").controller("MdChipCtrl", Ve), Ve.prototype.init = function(e) { this.parentController = e, this.enableChipEdit = this.parentController.enableChipEdit, this.enableChipEdit && (this.$element.on("keydown", this.chipKeyDown.bind(this)), this.$element.on("mousedown", this.chipMouseDown.bind(this)), this.getChipContent().addClass("_md-chip-content-edit-is-enabled")) }, Ve.prototype.getChipContent = function() { var e = this.$element[0].getElementsByClassName("md-chip-content"); return se.element(e[0]) }, Ve.prototype.getContentElement = function() { return se.element(this.getChipContent().children()[0]) }, Ve.prototype.getChipIndex = function() { return parseInt(this.$element.attr("index")) }, Ve.prototype.goOutOfEditMode = function() { if (this.isEditting) { this.isEditting = !1, this.$element.removeClass("_md-chip-editing"), this.getChipContent()[0].contentEditable = "false"; var e = this.getChipIndex();
                this.getContentElement().text() ? (this.parentController.updateChipContents(e, this.getContentElement().text()), this.$mdUtil.nextTick(function() { this.parentController.selectedChip === e && this.parentController.focusChip(e) }.bind(this))) : this.parentController.removeChipAndFocusInput(e) } }, Ve.prototype.selectNodeContents = function(e) { var t, n;
            document.body.createTextRange ? ((t = document.body.createTextRange()).moveToElementText(e), t.select()) : j.getSelection && (n = j.getSelection(), (t = document.createRange()).selectNodeContents(e), n.removeAllRanges(), n.addRange(t)) }, Ve.prototype.goInEditMode = function() { this.isEditting = !0, this.$element.addClass("_md-chip-editing"), this.getChipContent()[0].contentEditable = "true", this.getChipContent().on("blur", function() { this.goOutOfEditMode() }.bind(this)), this.selectNodeContents(this.getChipContent()[0]) }, Ve.prototype.chipKeyDown = function(e) { this.isEditting || e.keyCode !== this.$mdConstant.KEY_CODE.ENTER && e.keyCode !== this.$mdConstant.KEY_CODE.SPACE ? this.isEditting && e.keyCode === this.$mdConstant.KEY_CODE.ENTER && (e.preventDefault(), this.goOutOfEditMode()) : (e.preventDefault(), this.goInEditMode()) }, Ve.prototype.chipMouseDown = function() { this.getChipIndex() == this.parentController.selectedChip && this.enableChipEdit && !this.isEditting && this.goInEditMode() },
        function() { e.$inject = ["$mdTheming", "$mdUtil", "$compile", "$timeout"], se.module("material.components.chips").directive("mdChip", e); var t = '    <span data-ng-if="!$mdChipsCtrl.readonly" class="md-visually-hidden">      {{$mdChipsCtrl.deleteHint}}    </span>';

            function e(s, e, l, c) { var d = e.processTemplate(t); return { restrict: "E", require: ["^?mdChips", "mdChip"], link: function(e, t, n, i) { var o = i.shift(),
                            r = i.shift(),
                            a = se.element(t[0].querySelector(".md-chip-content"));
                        s(t), o && (r.init(o), a.append(l(d)(e)), a.on("blur", function() { o.resetSelectedChip(), o.$scope.$ApplyAsync() }));
                        c(function() { o && o.shouldFocusLastChip && o.focusLastChipThenInput() }) }, controller: "MdChipCtrl" } } }(), Ye.$inject = ["$timeout"], se.module("material.components.chips").directive("mdChipRemove", Ye), Ke.$inject = ["$compile"], se.module("material.components.chips").directive("mdChipTransclude", Ke),
        function() { e.$inject = ["$scope", "$attrs", "$mdConstant", "$log", "$element", "$timeout", "$mdUtil"]; var s = 300;

            function e(e, t, n, i, o, r, a) { this.$timeout = r, this.$mdConstant = n, this.$scope = e, this.parent = e.$parent, this.$mdUtil = a, this.$log = i, this.$element = o, this.$attrs = t, this.ngModelCtrl = null, this.userInputNgModelCtrl = null, this.autocompleteCtrl = null, this.userInputElement = null, this.items = [], this.selectedChip = -1, this.enableChipEdit = a.parseAttributeBoolean(t.mdEnableChipEdit), this.addOnBlur = a.parseAttributeBoolean(t.mdAddOnBlur), this.inputAriaLabel = "Chips input.", this.containerHint = "Chips container. Use arrow keys to select chips.", this.deleteHint = "Press delete to remove this chip.", this.deleteButtonLabel = "Remove", this.chipBuffer = "", this.useTransformChip = !1, this.useOnAdd = !1, this.useOnRemove = !1, this.wrapperId = "", this.contentIds = [], this.ariaTabIndex = null, this.chipAppendDelay = s, this.init() }
            se.module("material.components.chips").controller("MdChipsCtrl", e), e.prototype.init = function() { var t = this;
                t.wrapperId = "_md-chips-wrapper-" + t.$mdUtil.nextUid(), t.$scope.$watchCollection("$mdChipsCtrl.items", function() { t.setupInputAria(), t.setupWrapperAria() }), t.$attrs.$observe("mdChipAppendDelay", function(e) { t.chipAppendDelay = parseInt(e) || s }) }, e.prototype.setupInputAria = function() { var e = this.$element.find("input");
                e && (e.attr("role", "textbox"), e.attr("aria-multiline", !0)) }, e.prototype.setupWrapperAria = function() { var e = this,
                    t = this.$element.find("md-chips-wrap");
                this.items && this.items.length ? (t.attr("role", "listbox"), this.contentIds = this.items.map(function() { return e.wrapperId + "-chip-" + e.$mdUtil.nextUid() }), t.attr("aria-owns", this.contentIds.join(" "))) : (t.removeAttr("role"), t.removeAttr("aria-owns")) }, e.prototype.inputKeydown = function(e) { var t = this.getChipBuffer(); if (!(this.autocompleteCtrl && e.isDefaultPrevented && e.isDefaultPrevented())) { if (e.keyCode === this.$mdConstant.KEY_CODE.BACKSPACE) { if (0 !== this.getCursorPosition(e.target)) return; return e.preventDefault(), e.stopPropagation(), void(this.items.length && this.selectAndFocusChipSafe(this.items.length - 1)) } if ((!this.separatorKeys || this.separatorKeys.length < 1) && (this.separatorKeys = [this.$mdConstant.KEY_CODE.ENTER]), -1 !== this.separatorKeys.indexOf(e.keyCode)) { if (this.autocompleteCtrl && this.requireMatch || !t) return; if (e.preventDefault(), this.hasMaxChipsReached()) return; return this.appendChip(t.trim()), this.resetChipBuffer(), !1 } } }, e.prototype.getCursorPosition = function(t) { try { if (t.selectionStart === t.selectionEnd) return t.selectionStart } catch (e) { if (!t.value) return 0 } }, e.prototype.updateChipContents = function(e, t) { 0 <= e && e < this.items.length && (this.items[e] = t, this.ngModelCtrl.$setDirty()) }, e.prototype.isEditingChip = function() { return !!this.$element[0].querySelector("._md-chip-editing") }, e.prototype.isRemovable = function() { return !!this.ngModelCtrl && (this.readonly ? this.removable : !se.isDefined(this.removable) || this.removable) }, e.prototype.chipKeydown = function(e) { if (!this.getChipBuffer() && !this.isEditingChip()) switch (e.keyCode) {
                    case this.$mdConstant.KEY_CODE.BACKSPACE:
                    case this.$mdConstant.KEY_CODE.DELETE:
                        if (this.selectedChip < 0) return; if (e.preventDefault(), !this.isRemovable()) return;
                        this.removeAndSelectAdjacentChip(this.selectedChip); break;
                    case this.$mdConstant.KEY_CODE.LEFT_ARROW:
                        e.preventDefault(), (this.selectedChip < 0 || this.readonly && 0 == this.selectedChip) && (this.selectedChip = this.items.length), this.items.length && this.selectAndFocusChipSafe(this.selectedChip - 1); break;
                    case this.$mdConstant.KEY_CODE.RIGHT_ARROW:
                        e.preventDefault(), this.selectAndFocusChipSafe(this.selectedChip + 1); break;
                    case this.$mdConstant.KEY_CODE.ESCAPE:
                    case this.$mdConstant.KEY_CODE.TAB:
                        if (this.selectedChip < 0) return;
                        e.preventDefault(), this.onFocus() } }, e.prototype.getPlaceholder = function() { return this.items && this.items.length && ("" == this.secondaryPlaceholder || this.secondaryPlaceholder) ? this.secondaryPlaceholder : this.placeholder }, e.prototype.removeAndSelectAdjacentChip = function(e) { var t = this,
                    n = t.getAdjacentChipIndex(e);
                this.$element[0].querySelector("md-chips-wrap"), this.$element[0].querySelector('md-chip[index="' + e + '"]');
                t.removeChip(e), t.$timeout(function() { t.$timeout(function() { t.selectAndFocusChipSafe(n) }) }) }, e.prototype.resetSelectedChip = function() { this.selectedChip = -1, this.ariaTabIndex = null }, e.prototype.getAdjacentChipIndex = function(e) { var t = this.items.length - 1; return 0 == t ? -1 : e == t ? e - 1 : e }, e.prototype.appendChip = function(t) { if (this.shouldFocusLastChip = !0, this.useTransformChip && this.transformChip) { var e = this.transformChip({ $chip: t });
                    se.isDefined(e) && (t = e) } if (se.isObject(t) && this.items.some(function(e) { return se.equals(t, e) })) return; if (!(null == t || this.items.indexOf(t) + 1)) { var n = this.items.push(t) - 1;
                    this.ngModelCtrl.$setDirty(), this.validateModel(), this.useOnAdd && this.onAdd && this.onAdd({ $chip: t, $index: n }) } }, e.prototype.useTransformChipExpression = function() { this.useTransformChip = !0 }, e.prototype.useOnAddExpression = function() { this.useOnAdd = !0 }, e.prototype.useOnRemoveExpression = function() { this.useOnRemove = !0 }, e.prototype.useOnSelectExpression = function() { this.useOnSelect = !0 }, e.prototype.getChipBuffer = function() { var e = this.userInputElement ? this.userInputNgModelCtrl ? this.userInputNgModelCtrl.$viewValue : this.userInputElement[0].value : this.chipBuffer; return se.isString(e) ? e : "" }, e.prototype.resetChipBuffer = function() { this.userInputElement ? this.userInputNgModelCtrl ? (this.userInputNgModelCtrl.$setViewValue(""), this.userInputNgModelCtrl.$render()) : this.userInputElement[0].value = "" : this.chipBuffer = "" }, e.prototype.hasMaxChipsReached = function() { return se.isString(this.maxChips) && (this.maxChips = parseInt(this.maxChips, 10) || 0), 0 < this.maxChips && this.items.length >= this.maxChips }, e.prototype.validateModel = function() { this.ngModelCtrl.$setValidity("md-max-chips", !this.hasMaxChipsReached()) }, e.prototype.removeChip = function(e) { var t = this.items.splice(e, 1);
                this.ngModelCtrl.$setDirty(), this.validateModel(), t && t.length && this.useOnRemove && this.onRemove && this.onRemove({ $chip: t[0], $index: e }) }, e.prototype.removeChipAndFocusInput = function(e) { this.removeChip(e), this.autocompleteCtrl ? (this.autocompleteCtrl.hidden = !0, this.$mdUtil.nextTick(this.onFocus.bind(this))) : this.onFocus() }, e.prototype.selectAndFocusChipSafe = function(e) { if (!this.items.length || -1 === e) return this.focusInput(); if (e >= this.items.length) { if (!this.readonly) return this.onFocus();
                    e = 0 }
                e = Math.max(e, 0), e = Math.min(e, this.items.length - 1), this.selectChip(e), this.focusChip(e) }, e.prototype.focusLastChipThenInput = function() { var e = this;
                e.shouldFocusLastChip = !1, e.focusChip(this.items.length - 1), e.$timeout(function() { e.focusInput() }, e.chipAppendDelay) }, e.prototype.focusInput = function() { this.selectChip(-1), this.onFocus() }, e.prototype.selectChip = function(e) {-1 <= e && e <= this.items.length ? (this.selectedChip = e, this.useOnSelect && this.onSelect && this.onSelect({ $chip: this.items[e] })) : this.$log.warn("Selected Chip index out of bounds; ignoring.") }, e.prototype.selectAndFocusChip = function(e) { this.selectChip(e), -1 != e && this.focusChip(e) }, e.prototype.focusChip = function(e) { var t = this.$element[0].querySelector('md-chip[index="' + e + '"] .md-chip-content');
                this.ariaTabIndex = e, t.focus() }, e.prototype.configureNgModel = function(e) { this.ngModelCtrl = e; var t = this;
                e.$render = function() { t.items = t.ngModelCtrl.$viewValue } }, e.prototype.onFocus = function() { var e = this.$element[0].querySelector("input");
                e && e.focus(), this.resetSelectedChip() }, e.prototype.onInputFocus = function() { this.inputHasFocus = !0, this.setupInputAria(), this.resetSelectedChip() }, e.prototype.onInputBlur = function() { this.inputHasFocus = !1, this.shouldAddOnBlur() && (this.appendChip(this.getChipBuffer().trim()), this.resetChipBuffer()) }, e.prototype.configureUserInput = function(e) { var t = (this.userInputElement = e).controller("ngModel");
                t != this.ngModelCtrl && (this.userInputNgModelCtrl = t);

                function n(e, t) { i.$evalAsync(se.bind(o, t, e)) } var i = this.$scope,
                    o = this;
                e.attr({ tabindex: 0 }).on("keydown", function(e) { n(e, o.inputKeydown) }).on("focus", function(e) { n(e, o.onInputFocus) }).on("blur", function(e) { n(e, o.onInputBlur) }) }, e.prototype.configureAutocomplete = function(e) { e && ((this.autocompleteCtrl = e).registerSelectedItemWatcher(se.bind(this, function(e) { if (e) { if (this.hasMaxChipsReached()) return;
                        this.appendChip(e), this.resetChipBuffer() } })), this.$element.find("input").on("focus", se.bind(this, this.onInputFocus)).on("blur", se.bind(this, this.onInputBlur))) }, e.prototype.shouldAddOnBlur = function() { this.validateModel(); var e = this.getChipBuffer().trim(),
                    t = this.ngModelCtrl.$valid,
                    n = this.autocompleteCtrl && !this.autocompleteCtrl.hidden; return this.userInputNgModelCtrl && (t = t && this.userInputNgModelCtrl.$valid), this.addOnBlur && !this.requireMatch && e && t && !n }, e.prototype.hasFocus = function() { return this.inputHasFocus || 0 <= this.selectedChip }, e.prototype.contentIdFor = function(e) { return this.contentIds[e] } }(),
        function() { i.$inject = ["$mdTheming", "$mdUtil", "$compile", "$log", "$timeout", "$$mdSvgRegistry"], se.module("material.components.chips").directive("mdChips", i); var e = '      <md-chips-wrap          id="{{$mdChipsCtrl.wrapperId}}"          tabindex="{{$mdChipsCtrl.readonly ? 0 : -1}}"          data-ng-keydown="$mdChipsCtrl.chipKeydown($event)"          data-ng-class="{ \'md-focused\': $mdChipsCtrl.hasFocus(),                       \'md-readonly\': !$mdChipsCtrl.ngModelCtrl || $mdChipsCtrl.readonly,                      \'md-removable\': $mdChipsCtrl.isRemovable() }"          aria-setsize="{{$mdChipsCtrl.items.length}}"          class="md-chips">        <span data-ng-if="$mdChipsCtrl.readonly" class="md-visually-hidden">          {{$mdChipsCtrl.containerHint}}        </span>        <md-chip data-ng-repeat="$chip in $mdChipsCtrl.items"            index="{{$index}}"            data-ng-class="{\'md-focused\': $mdChipsCtrl.selectedChip == $index, \'md-readonly\': !$mdChipsCtrl.ngModelCtrl || $mdChipsCtrl.readonly}">          <div class="md-chip-content"              tabindex="{{$mdChipsCtrl.ariaTabIndex == $index ? 0 : -1}}"              id="{{$mdChipsCtrl.contentIdFor($index)}}"              role="option"              aria-selected="{{$mdChipsCtrl.selectedChip == $index}}"               aria-posinset="{{$index}}"              data-ng-click="!$mdChipsCtrl.readonly && $mdChipsCtrl.focusChip($index)"              data-ng-focus="!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)"              md-chip-transclude="$mdChipsCtrl.chipContentsTemplate"></div>          <div data-ng-if="$mdChipsCtrl.isRemovable()"               class="md-chip-remove-container"               tabindex="-1"               md-chip-transclude="$mdChipsCtrl.chipRemoveTemplate"></div>        </md-chip>        <div class="md-chip-input-container" data-ng-if="!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl">          <div md-chip-transclude="$mdChipsCtrl.chipInputTemplate"></div>        </div>      </md-chips-wrap>',
                t = '        <input            class="md-input"            tabindex="0"            aria-label="{{$mdChipsCtrl.inputAriaLabel}}"             placeholder="{{$mdChipsCtrl.getPlaceholder()}}"            data-ng-model="$mdChipsCtrl.chipBuffer"            data-ng-focus="$mdChipsCtrl.onInputFocus()"            data-ng-blur="$mdChipsCtrl.onInputBlur()"            data-ng-keydown="$mdChipsCtrl.inputKeydown($event)">',
                n = "      <span>{{$chip}}</span>",
                o = '      <button          class="md-chip-remove"          data-ng-if="$mdChipsCtrl.isRemovable()"          data-ng-click="$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index)"          type="button"          tabindex="-1">        <md-icon md-svg-src="{{ $mdChipsCtrl.mdCloseIcon }}"></md-icon>        <span class="md-visually-hidden">          {{$mdChipsCtrl.deleteButtonLabel}}        </span>      </button>';

            function i(m, p, h, i, f, g) { var v = { chips: p.processTemplate(e), input: p.processTemplate(t), default: p.processTemplate(n), remove: p.processTemplate(o) }; return { template: function(e, t) { return t.$mdUserTemplate = e.clone(), v.chips }, require: ["mdChips"], restrict: "E", controller: "MdChipsCtrl", controllerAs: "$mdChipsCtrl", bindToController: !0, compile: function(e, a) { var n = a.$mdUserTemplate;
                        a.$mdUserTemplate = null; var s = t("md-chips>md-chip-template"),
                            l = t(p.prefixer().buildList("md-chip-remove").map(function(e) { return "md-chips>*[" + e + "]" }).join(",")) || v.remove,
                            c = s || v.default,
                            d = t("md-chips>md-autocomplete") || t("md-chips>input") || v.input,
                            u = n.find("md-chip");
                        n[0].querySelector("md-chip-template>*[md-chip-remove]") && i.warn("invalid placement of md-chip-remove within md-chip-template.");

                        function t(e) { if (a.ngModel) { var t = n[0].querySelector(e); return t && t.outerHTML } } return function(e, t, n, i) { p.initOptionalProperties(e, a), m(t); var o = i[0]; if (s && (o.enableChipEdit = !1), o.chipContentsTemplate = c, o.chipRemoveTemplate = l, o.chipInputTemplate = d, o.mdCloseIcon = g.mdClose, t.attr({ tabindex: -1 }).on("focus", function() { o.onFocus() }), a.ngModel && (o.configureNgModel(t.controller("ngModel")), n.mdTransformChip && o.useTransformChipExpression(), n.mdOnAppend && o.useOnAppendExpression(), n.mdOnAdd && o.useOnAddExpression(), n.mdOnRemove && o.useOnRemoveExpression(), n.mdOnSelect && o.useOnSelectExpression(), d != v.input && e.$watch("$mdChipsCtrl.readonly", function(e) { e || p.nextTick(function() { if (0 === d.indexOf("<md-autocomplete")) { var e = t.find("md-autocomplete");
                                            o.configureAutocomplete(e.controller("mdAutocomplete")) }
                                        o.configureUserInput(t.find("input")) }) }), p.nextTick(function() { var e = t.find("input");
                                    e && e.toggleClass("md-input", !0) })), 0 < u.length) { var r = h(u.clone())(e.$parent);
                                f(function() { t.find("md-chips-wrap").prepend(r) }) } } }, scope: { readonly: "=readonly", removable: "=mdRemovable", placeholder: "@", secondaryPlaceholder: "@", maxChips: "@mdMaxChips", transformChip: "&mdTransformChip", onAppend: "&mdOnAppend", onAdd: "&mdOnAdd", onRemove: "&mdOnRemove", onSelect: "&mdOnSelect", inputAriaLabel: "@", containerHint: "@", deleteHint: "@", deleteButtonLabel: "@", separatorKeys: "=?mdSeparatorKeys", requireMatch: "=?mdRequireMatch", chipAppendDelayString: "@?mdChipAppendDelay" } } } }(), se.module("material.components.chips").controller("MdContactChipsCtrl", Ge), Ge.prototype.queryContact = function(e) { return this.contactQuery({ $query: e }) }, Ge.prototype.itemName = function(e) { return e[this.contactName] },
        function() { e.$inject = ["$mdTheming", "$mdUtil"], se.module("material.components.chips").directive("mdContactChips", e); var n = '      <md-chips class="md-contact-chips"          data-ng-model="$mdContactChipsCtrl.contacts"          md-require-match="$mdContactChipsCtrl.requireMatch"          md-chip-append-delay="{{$mdContactChipsCtrl.chipAppendDelay}}"           md-autocomplete-snap>          <md-autocomplete              md-menu-class="md-contact-chips-suggestions"              md-selected-item="$mdContactChipsCtrl.selectedItem"              md-search-text="$mdContactChipsCtrl.searchText"              md-items="item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)"              md-item-text="$mdContactChipsCtrl.itemName(item)"              md-no-cache="true"              md-min-length="$mdContactChipsCtrl.minLength"              md-autoselect              placeholder="{{$mdContactChipsCtrl.contacts.length == 0 ?                  $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}">            <div class="md-contact-suggestion">              <img                   data-ng-src="{{item[$mdContactChipsCtrl.contactImage]}}"                  alt="{{item[$mdContactChipsCtrl.contactName]}}"                  data-ng-if="item[$mdContactChipsCtrl.contactImage]" />              <span class="md-contact-name" md-highlight-text="$mdContactChipsCtrl.searchText"                    md-highlight-flags="{{$mdContactChipsCtrl.highlightFlags}}">                {{item[$mdContactChipsCtrl.contactName]}}              </span>              <span class="md-contact-email" >{{item[$mdContactChipsCtrl.contactEmail]}}</span>            </div>          </md-autocomplete>          <md-chip-template>            <div class="md-contact-avatar">              <img                   data-ng-src="{{$chip[$mdContactChipsCtrl.contactImage]}}"                  alt="{{$chip[$mdContactChipsCtrl.contactName]}}"                  data-ng-if="$chip[$mdContactChipsCtrl.contactImage]" />            </div>            <div class="md-contact-name">              {{$chip[$mdContactChipsCtrl.contactName]}}            </div>          </md-chip-template>      </md-chips>';

            function e(a, s) { return { template: function(e, t) { return n }, restrict: "E", controller: "MdContactChipsCtrl", controllerAs: "$mdContactChipsCtrl", bindToController: !0, compile: function(e, r) { return function(e, t, n, i) { var o = i;
                            s.initOptionalProperties(e, r), a(t), t.attr("tabindex", "-1"), n.$observe("mdChipAppendDelay", function(e) { o.chipAppendDelay = e }) } }, scope: { contactQuery: "&mdContacts", placeholder: "@", secondaryPlaceholder: "@", contactName: "@mdContactName", contactImage: "@mdContactImage", contactEmail: "@mdContactEmail", contacts: "=ngModel", requireMatch: "=?mdRequireMatch", minLength: "=?mdMinLength", highlightFlags: "@?mdHighlightFlags", chipAppendDelay: "@?mdChipAppendDelay" } } } }(),
        function() { e.$inject = ["$element", "$scope", "$$mdDateUtil", "$mdUtil", "$mdConstant", "$mdTheming", "$$rAF", "$attrs", "$mdDateLocale"], se.module("material.components.datepicker").directive("mdCalendar", function() { return { template: function(e, t) { return '<div data-ng-switch="calendarCtrl.currentView" ' + (t.hasOwnProperty("ngIf") ? "" : 'data-ng-if="calendarCtrl.isInitialized"') + '><md-calendar-year data-ng-switch-when="year"></md-calendar-year><md-calendar-month data-ng-switch-default></md-calendar-month></div>' }, scope: { minDate: "=mdMinDate", maxDate: "=mdMaxDate", dateFilter: "=mdDateFilter", _currentView: "@mdCurrentView" }, require: ["ngModel", "mdCalendar"], controller: e, controllerAs: "calendarCtrl", bindToController: !0, link: function(e, t, n, i) { var o = i[0];
                        i[1].configureNgModel(o) } } }); var u = 0;

            function e(e, t, n, i, o, r, a, s, l) { r(e), this.$element = e, this.$scope = t, this.dateUtil = n, this.$mdUtil = i, this.keyCode = o.KEY_CODE, this.$$rAF = a, this.$mdDateLocale = l, this.today = this.dateUtil.createDateAtMidnight(), this.ngModelCtrl = null, this.SELECTED_DATE_CLASS = "md-calendar-selected-date", this.TODAY_CLASS = "md-calendar-date-today", this.FOCUSED_DATE_CLASS = "md-focus", this.id = u++, this.displayDate = null, this.selectedDate = null, this.firstRenderableDate = null, this.lastRenderableDate = null, this.isInitialized = !1, this.width = 0, this.scrollbarWidth = 0, s.tabindex || e.attr("tabindex", "-1"); var c, d = se.bind(this, this.handleKeyEvent);
                (c = e.parent().hasClass("md-datepicker-calendar") ? se.element(document.body) : e).on("keydown", d), t.$on("$destroy", function() { c.off("keydown", d) }), 1 === se.version.major && se.version.minor <= 4 && this.$onInit() }
            e.prototype.$onInit = function() { this.currentView = this._currentView || "month"; var e = this.$mdDateLocale;
                this.minDate && this.minDate > e.firstRenderableDate ? this.firstRenderableDate = this.minDate : this.firstRenderableDate = e.firstRenderableDate, this.maxDate && this.maxDate < e.lastRenderableDate ? this.lastRenderableDate = this.maxDate : this.lastRenderableDate = e.lastRenderableDate }, e.prototype.configureNgModel = function(e) { var t = this;
                t.ngModelCtrl = e, t.$mdUtil.nextTick(function() { t.isInitialized = !0 }), e.$render = function() { var e = this.$viewValue;
                    t.$scope.$broadcast("md-calendar-parent-changed", e), t.selectedDate || (t.selectedDate = e), t.displayDate || (t.displayDate = t.selectedDate || t.today) } }, e.prototype.setNgModelValue = function(e) { var t = this.dateUtil.createDateAtMidnight(e); return this.focus(t), this.$scope.$emit("md-calendar-change", t), this.ngModelCtrl.$setViewValue(t), this.ngModelCtrl.$render(), t }, e.prototype.setCurrentView = function(e, t) { var n = this;
                n.$mdUtil.nextTick(function() { n.currentView = e, t && (n.displayDate = se.isDate(t) ? t : new Date(t)) }) }, e.prototype.focus = function(e) { if (this.dateUtil.isValidDate(e)) { var t = this.$element[0].querySelector(".md-focus");
                    t && t.classList.remove(this.FOCUSED_DATE_CLASS); var n = this.getDateId(e, this.currentView),
                        i = document.getElementById(n);
                    i && (i.classList.add(this.FOCUSED_DATE_CLASS), i.focus(), this.displayDate = e) } else { var o = this.$element[0].querySelector("[data-ng-switch]");
                    o && o.focus() } }, e.prototype.getActionFromKeyEvent = function(e) { var t = this.keyCode; switch (e.which) {
                    case t.ENTER:
                        return "select";
                    case t.RIGHT_ARROW:
                        return "move-right";
                    case t.LEFT_ARROW:
                        return "move-left";
                    case t.DOWN_ARROW:
                        return e.metaKey ? "move-page-down" : "move-row-down";
                    case t.UP_ARROW:
                        return e.metaKey ? "move-page-up" : "move-row-up";
                    case t.PAGE_DOWN:
                        return "move-page-down";
                    case t.PAGE_UP:
                        return "move-page-up";
                    case t.HOME:
                        return "start";
                    case t.END:
                        return "end";
                    default:
                        return null } }, e.prototype.handleKeyEvent = function(t) { var n = this;
                this.$scope.$Apply(function() { if (t.which == n.keyCode.ESCAPE || t.which == n.keyCode.TAB) return n.$scope.$emit("md-calendar-close"), void(t.which == n.keyCode.TAB && t.preventDefault()); var e = n.getActionFromKeyEvent(t);
                    e && (t.preventDefault(), t.stopPropagation(), n.$scope.$broadcast("md-calendar-parent-action", e)) }) }, e.prototype.hideVerticalScrollbar = function(i) { var o = this,
                    t = i.$element[0],
                    r = t.querySelector(".md-calendar-scroll-mask");

                function n() { var e = o.width || 340,
                        t = o.scrollbarWidth,
                        n = i.calendarScroller;
                    r.style.width = e + "px", n.style.width = e + t + "px", n.style.paddingRight = t + "px" }
                0 < o.width ? n() : o.$$rAF(function() { var e = i.calendarScroller;
                    o.scrollbarWidth = e.offsetWidth - e.clientWidth, o.width = t.querySelector("table").offsetWidth, n() }) }, e.prototype.getDateId = function(e, t) { if (!t) throw new Error("A namespace for the date id has to be specified."); return ["md", this.id, t, e.getFullYear(), e.getMonth(), e.getDate()].join("-") }, e.prototype.updateVirtualRepeat = function() { var e = this.$scope,
                    t = e.$on("$md-resize-enable", function() { e.$$phase || e.$Apply(), t() }) } }(),
        function() { t.$inject = ["$element", "$scope", "$animate", "$q", "$$mdDateUtil", "$mdDateLocale"], se.module("material.components.datepicker").directive("mdCalendarMonth", function() { return { template: '<table aria-hidden="true" class="md-calendar-day-header"><thead></thead></table><div class="md-calendar-scroll-mask"><md-virtual-repeat-container class="md-calendar-scroll-container" md-offset-size="' + (e - n) + '"><table role="grid" tabindex="0" class="md-calendar" aria-readonly="true"><tbody md-calendar-month-body role="rowgroup" md-virtual-repeat="i in monthCtrl.items" md-month-offset="$index" class="md-calendar-month" md-start-index="monthCtrl.getSelectedMonthIndex()" md-item-size="' + n + '"><tr aria-hidden="true" md-force-height="\'' + n + "px'\"></tr></tbody></table></md-virtual-repeat-container></div>", require: ["^^mdCalendar", "mdCalendarMonth"], controller: t, controllerAs: "monthCtrl", bindToController: !0, link: function(e, t, n, i) { var o = i[0];
                        i[1].initialize(o) } } }); var n = 265,
                e = 45;

            function t(e, t, n, i, o, r) { this.$element = e, this.$scope = t, this.$animate = n, this.$q = i, this.dateUtil = o, this.dateLocale = r, this.calendarScroller = e[0].querySelector(".md-virtual-repeat-scroller"), this.isInitialized = !1, this.isMonthTransitionInProgress = !1; var a = this;
                this.cellClickHandler = function() { var e = o.getTimestampFromNode(this);
                    a.$scope.$Apply(function() { a.calendarCtrl.setNgModelValue(e) }) }, this.headerClickHandler = function() { a.calendarCtrl.setCurrentView("year", o.getTimestampFromNode(this)) } }
            t.prototype.initialize = function(e) { this.items = { length: this.dateUtil.getMonthDistance(e.firstRenderableDate, e.lastRenderableDate) + 2 }, this.calendarCtrl = e, this.attachScopeListeners(), e.updateVirtualRepeat(), e.ngModelCtrl && e.ngModelCtrl.$render() }, t.prototype.getSelectedMonthIndex = function() { var e = this.calendarCtrl; return this.dateUtil.getMonthDistance(e.firstRenderableDate, e.displayDate || e.selectedDate || e.today) }, t.prototype.changeSelectedDate = function(i) { var o = this.calendarCtrl,
                    r = o.selectedDate;
                o.selectedDate = i, this.changeDisplayDate(i).then(function() { var e = o.SELECTED_DATE_CLASS; if (r) { var t = document.getElementById(o.getDateId(r, "month"));
                        t && (t.classList.remove(e), t.setAttribute("aria-selected", "false")) } if (i) { var n = document.getElementById(o.getDateId(i, "month"));
                        n && (n.classList.add(e), n.setAttribute("aria-selected", "true")) } }) }, t.prototype.changeDisplayDate = function(e) { if (!this.isInitialized) return this.buildWeekHeader(), this.calendarCtrl.hideVerticalScrollbar(this), this.isInitialized = !0, this.$q.when(); if (!this.dateUtil.isValidDate(e) || this.isMonthTransitionInProgress) return this.$q.when();
                this.isMonthTransitionInProgress = !0; var t = this.animateDateChange(e);
                this.calendarCtrl.displayDate = e; var n = this; return t.then(function() { n.isMonthTransitionInProgress = !1 }), t }, t.prototype.animateDateChange = function(e) { if (this.dateUtil.isValidDate(e)) { var t = this.dateUtil.getMonthDistance(this.calendarCtrl.firstRenderableDate, e);
                    this.calendarScroller.scrollTop = t * n } return this.$q.when() }, t.prototype.buildWeekHeader = function() { for (var e = this.dateLocale.firstDayOfWeek, t = this.dateLocale.shortDays, n = document.createElement("tr"), i = 0; i < 7; i++) { var o = document.createElement("th");
                    o.textContent = t[(i + e) % 7], n.appendChild(o) }
                this.$element.find("thead").append(n) }, t.prototype.attachScopeListeners = function() { var n = this;
                n.$scope.$on("md-calendar-parent-changed", function(e, t) { n.changeSelectedDate(t) }), n.$scope.$on("md-calendar-parent-action", se.bind(this, this.handleKeyEvent)) }, t.prototype.handleKeyEvent = function(e, t) { var n = this.calendarCtrl,
                    i = n.displayDate; if ("select" === t) n.setNgModelValue(i);
                else { var o = null,
                        r = this.dateUtil; switch (t) {
                        case "move-right":
                            o = r.incrementDays(i, 1); break;
                        case "move-left":
                            o = r.incrementDays(i, -1); break;
                        case "move-page-down":
                            o = r.incrementMonths(i, 1); break;
                        case "move-page-up":
                            o = r.incrementMonths(i, -1); break;
                        case "move-row-down":
                            o = r.incrementDays(i, 7); break;
                        case "move-row-up":
                            o = r.incrementDays(i, -7); break;
                        case "start":
                            o = r.getFirstDateOfMonth(i); break;
                        case "end":
                            o = r.getLastDateOfMonth(i) }
                    o && (o = this.dateUtil.clampDate(o, n.minDate, n.maxDate), this.changeDisplayDate(o).then(function() { n.focus(o) })) } } }(), Xe.$inject = ["$compile", "$$mdSvgRegistry"], Qe.$inject = ["$element", "$$mdDateUtil", "$mdDateLocale"], se.module("material.components.datepicker").directive("mdCalendarMonthBody", Xe), Qe.prototype.generateContent = function() { var e = this.dateUtil.incrementMonths(this.calendarCtrl.firstRenderableDate, this.offset);
            this.$element.empty().append(this.buildCalendarForMonth(e)), this.focusAfterAppend && (this.focusAfterAppend.classList.add(this.calendarCtrl.FOCUSED_DATE_CLASS), this.focusAfterAppend.focus(), this.focusAfterAppend = null) }, Qe.prototype.buildDateCell = function(e) { var t = this.monthCtrl,
                n = this.calendarCtrl,
                i = document.createElement("td"); if (i.tabIndex = -1, i.classList.add("md-calendar-date"), i.setAttribute("role", "gridcell"), e) { i.setAttribute("tabindex", "-1"), i.setAttribute("aria-label", this.dateLocale.longDateFormatter(e)), i.id = n.getDateId(e, "month"), i.setAttribute("data-timestamp", e.getTime()), this.dateUtil.isSameDay(e, n.today) && i.classList.add(n.TODAY_CLASS), this.dateUtil.isValidDate(n.selectedDate) && this.dateUtil.isSameDay(e, n.selectedDate) && (i.classList.add(n.SELECTED_DATE_CLASS), i.setAttribute("aria-selected", "true")); var o = this.dateLocale.dates[e.getDate()]; if (this.isDateEnabled(e)) { var r = document.createElement("span");
                    r.classList.add("md-calendar-date-selection-indicator"), r.textContent = o, i.appendChild(r), i.addEventListener("click", t.cellClickHandler), n.displayDate && this.dateUtil.isSameDay(e, n.displayDate) && (this.focusAfterAppend = i) } else i.classList.add("md-calendar-date-disabled"), i.textContent = o } return i }, Qe.prototype.isDateEnabled = function(e) { return this.dateUtil.isDateWithinRange(e, this.calendarCtrl.minDate, this.calendarCtrl.maxDate) && (!se.isFunction(this.calendarCtrl.dateFilter) || this.calendarCtrl.dateFilter(e)) }, Qe.prototype.buildDateRow = function(e) { var t = document.createElement("tr"); return t.setAttribute("role", "row"), t.setAttribute("aria-label", this.dateLocale.weekNumberFormatter(e)), t }, Qe.prototype.buildCalendarForMonth = function(e) { var t = this.dateUtil.isValidDate(e) ? e : new Date,
                n = this.dateUtil.getFirstDateOfMonth(t),
                i = this.getLocaleDay_(n),
                o = this.dateUtil.getNumberOfDaysInMonth(t),
                r = document.createDocumentFragment(),
                a = 1,
                s = this.buildDateRow(a);
            r.appendChild(s); var l = this.offset === this.monthCtrl.items.length - 1,
                c = 0,
                d = document.createElement("td"),
                u = document.createElement("span"); if (u.textContent = this.dateLocale.monthHeaderFormatter(t), d.appendChild(u), d.classList.add("md-calendar-month-label"), this.calendarCtrl.maxDate && n > this.calendarCtrl.maxDate ? d.classList.add("md-calendar-month-label-disabled") : (d.addEventListener("click", this.monthCtrl.headerClickHandler), d.setAttribute("data-timestamp", n.getTime()), d.setAttribute("aria-label", this.dateLocale.monthFormatter(t)), d.appendChild(this.arrowIcon.cloneNode(!0))), i <= 2) { d.setAttribute("colspan", "7"); var m = this.buildDateRow(); if (m.appendChild(d), r.insertBefore(m, s), l) return r } else c = 3, d.setAttribute("colspan", "3"), s.appendChild(d); for (var p = c; p < i; p++) s.appendChild(this.buildDateCell()); for (var h = i, f = n, g = 1; g <= o; g++) { if (7 === h) { if (l) return r;
                    h = 0, a++, s = this.buildDateRow(a), r.appendChild(s) }
                f.setDate(g); var v = this.buildDateCell(f);
                s.appendChild(v), h++ } for (; s.childNodes.length < 7;) s.appendChild(this.buildDateCell()); for (; r.childNodes.length < 6;) { for (var b = this.buildDateRow(), $ = 0; $ < 7; $++) b.appendChild(this.buildDateCell());
                r.appendChild(b) } return r }, Qe.prototype.getLocaleDay_ = function(e) { return (e.getDay() + (7 - this.dateLocale.firstDayOfWeek)) % 7 },
        function() { e.$inject = ["$element", "$scope", "$animate", "$q", "$$mdDateUtil"], se.module("material.components.datepicker").directive("mdCalendarYear", function() { return { template: '<div class="md-calendar-scroll-mask"><md-virtual-repeat-container class="md-calendar-scroll-container"><table role="grid" tabindex="0" class="md-calendar" aria-readonly="true"><tbody md-calendar-year-body role="rowgroup" md-virtual-repeat="i in yearCtrl.items" md-year-offset="$index" class="md-calendar-year" md-start-index="yearCtrl.getFocusedYearIndex()" md-item-size="' + n + '"><tr aria-hidden="true" md-force-height="\'' + n + "px'\"></tr></tbody></table></md-virtual-repeat-container></div>", require: ["^^mdCalendar", "mdCalendarYear"], controller: e, controllerAs: "yearCtrl", bindToController: !0, link: function(e, t, n, i) { var o = i[0];
                        i[1].initialize(o) } } }); var n = 88;

            function e(e, t, n, i, o) { this.$element = e, this.$scope = t, this.$animate = n, this.$q = i, this.dateUtil = o, this.calendarScroller = e[0].querySelector(".md-virtual-repeat-scroller"), this.isInitialized = !1, this.isMonthTransitionInProgress = !1; var r = this;
                this.cellClickHandler = function() { r.calendarCtrl.setCurrentView("month", o.getTimestampFromNode(this)) } }
            e.prototype.initialize = function(e) { this.items = { length: this.dateUtil.getYearDistance(e.firstRenderableDate, e.lastRenderableDate) + 1 }, this.calendarCtrl = e, this.attachScopeListeners(), e.updateVirtualRepeat(), e.ngModelCtrl && e.ngModelCtrl.$render() }, e.prototype.getFocusedYearIndex = function() { var e = this.calendarCtrl; return this.dateUtil.getYearDistance(e.firstRenderableDate, e.displayDate || e.selectedDate || e.today) }, e.prototype.changeDate = function(e) { if (!this.isInitialized) return this.calendarCtrl.hideVerticalScrollbar(this), this.isInitialized = !0, this.$q.when(); if (this.dateUtil.isValidDate(e) && !this.isMonthTransitionInProgress) { var t = this,
                        n = this.animateDateChange(e); return t.isMonthTransitionInProgress = !0, t.calendarCtrl.displayDate = e, n.then(function() { t.isMonthTransitionInProgress = !1 }) } }, e.prototype.animateDateChange = function(e) { if (this.dateUtil.isValidDate(e)) { var t = this.dateUtil.getYearDistance(this.calendarCtrl.firstRenderableDate, e);
                    this.calendarScroller.scrollTop = t * n } return this.$q.when() }, e.prototype.handleKeyEvent = function(e, t) { var n = this.calendarCtrl,
                    i = n.displayDate; if ("select" === t) this.changeDate(i).then(function() { n.setCurrentView("month", i), n.focus(i) });
                else { var o = null,
                        r = this.dateUtil; switch (t) {
                        case "move-right":
                            o = r.incrementMonths(i, 1); break;
                        case "move-left":
                            o = r.incrementMonths(i, -1); break;
                        case "move-row-down":
                            o = r.incrementMonths(i, 6); break;
                        case "move-row-up":
                            o = r.incrementMonths(i, -6) } if (o) { var a = n.minDate ? r.getFirstDateOfMonth(n.minDate) : null,
                            s = n.maxDate ? r.getFirstDateOfMonth(n.maxDate) : null;
                        o = r.getFirstDateOfMonth(this.dateUtil.clampDate(o, a, s)), this.changeDate(o).then(function() { n.focus(o) }) } } }, e.prototype.attachScopeListeners = function() { var n = this;
                n.$scope.$on("md-calendar-parent-changed", function(e, t) { n.changeDate(t) }), n.$scope.$on("md-calendar-parent-action", se.bind(n, n.handleKeyEvent)) } }(), Ze.$inject = ["$element", "$$mdDateUtil", "$mdDateLocale"], se.module("material.components.datepicker").directive("mdCalendarYearBody", function() { return { require: ["^^mdCalendar", "^^mdCalendarYear", "mdCalendarYearBody"], scope: { offset: "=mdYearOffset" }, controller: Ze, controllerAs: "mdYearBodyCtrl", bindToController: !0, link: function(e, t, n, i) { var o = i[0],
                        r = i[1],
                        a = i[2];
                    a.calendarCtrl = o, a.yearCtrl = r, e.$watch(function() { return a.offset }, function(e) { se.isNumber(e) && a.generateContent() }) } } }), Ze.prototype.generateContent = function() { var e = this.dateUtil.incrementYears(this.calendarCtrl.firstRenderableDate, this.offset);
            this.$element.empty().append(this.buildCalendarForYear(e)), this.focusAfterAppend && (this.focusAfterAppend.classList.add(this.calendarCtrl.FOCUSED_DATE_CLASS), this.focusAfterAppend.focus(), this.focusAfterAppend = null) }, Ze.prototype.buildMonthCell = function(e, t) { var n = this.calendarCtrl,
                i = this.yearCtrl,
                o = this.buildBlankCell(),
                r = new Date(e, t, 1);
            o.setAttribute("aria-label", this.dateLocale.monthFormatter(r)), o.id = n.getDateId(r, "year"), o.setAttribute("data-timestamp", r.getTime()), this.dateUtil.isSameMonthAndYear(r, n.today) && o.classList.add(n.TODAY_CLASS), this.dateUtil.isValidDate(n.selectedDate) && this.dateUtil.isSameMonthAndYear(r, n.selectedDate) && (o.classList.add(n.SELECTED_DATE_CLASS), o.setAttribute("aria-selected", "true")); var a = this.dateLocale.shortMonths[t]; if (this.dateUtil.isMonthWithinRange(r, n.minDate, n.maxDate)) { var s = document.createElement("span");
                s.classList.add("md-calendar-date-selection-indicator"), s.textContent = a, o.appendChild(s), o.addEventListener("click", i.cellClickHandler), n.displayDate && this.dateUtil.isSameMonthAndYear(r, n.displayDate) && (this.focusAfterAppend = o) } else o.classList.add("md-calendar-date-disabled"), o.textContent = a; return o }, Ze.prototype.buildBlankCell = function() { var e = document.createElement("td"); return e.tabIndex = -1, e.classList.add("md-calendar-date"), e.setAttribute("role", "gridcell"), e.setAttribute("tabindex", "-1"), e }, Ze.prototype.buildCalendarForYear = function(e) { var t, n = e.getFullYear(),
                i = document.createDocumentFragment(),
                o = document.createElement("tr"),
                r = document.createElement("td"); for (r.className = "md-calendar-month-label", r.textContent = n, o.appendChild(r), t = 0; t < 6; t++) o.appendChild(this.buildMonthCell(n, t));
            i.appendChild(o); var a = document.createElement("tr"); for (a.appendChild(this.buildBlankCell()), t = 6; t < 12; t++) a.appendChild(this.buildMonthCell(n, t)); return i.appendChild(a), i }, se.module("material.components.datepicker").config(["$provide", function(e) {
            function t() { this.months = null, this.shortMonths = null, this.days = null, this.shortDays = null, this.dates = null, this.firstDayOfWeek = 0, this.formatDate = null, this.parseDate = null, this.monthHeaderFormatter = null, this.weekNumberFormatter = null, this.longDateFormatter = null, this.msgCalendar = "", this.msgOpenCalendar = "" }(t.prototype.$get = function(e, o) { for (var t = e.DATETIME_FORMATS.SHORTDAY.map(function(e) { return e.substring(0, 1) }), n = Array(32), i = 1; i <= 31; i++) n[i] = i; var r = new Date(1880, 0, 1),
                    a = new Date(r.getFullYear() + 250, 0, 1),
                    s = { months: this.months || e.DATETIME_FORMATS.MONTH, shortMonths: this.shortMonths || e.DATETIME_FORMATS.SHORTMONTH, days: this.days || e.DATETIME_FORMATS.DAY, shortDays: this.shortDays || t, dates: this.dates || n, firstDayOfWeek: this.firstDayOfWeek || 0, formatDate: this.formatDate || function(e, t) { if (!e) return ""; var n = e.toLocaleTimeString(),
                                i = e; return 0 !== e.getHours() || -1 === n.indexOf("11:") && -1 === n.indexOf("23:") || (i = new Date(e.getFullYear(), e.getMonth(), e.getDate(), 1, 0, 0)), o("date")(i, "dd/MM/yyyy", t) }, parseDate: this.parseDate || function(e) { return new Date(e) }, isDateComplete: this.isDateComplete || function(e) { return e = e.trim(), /^(([a-zA-Z]{3,}|[0-9]{1,4})([ \.,]+|[\/\-])){2}([a-zA-Z]{3,}|[0-9]{1,4})$/.test(e) }, monthHeaderFormatter: this.monthHeaderFormatter || function(e) { return s.shortMonths[e.getMonth()] + " " + e.getFullYear() }, monthFormatter: this.monthFormatter || function(e) { return s.months[e.getMonth()] + " " + e.getFullYear() }, weekNumberFormatter: this.weekNumberFormatter || function(e) { return "Week " + e }, longDateFormatter: this.longDateFormatter || function(e) { return [s.days[e.getDay()], s.months[e.getMonth()], s.dates[e.getDate()], e.getFullYear()].join(" ") }, msgCalendar: this.msgCalendar || "Calendar", msgOpenCalendar: this.msgOpenCalendar || "Open calendar", firstRenderableDate: this.firstRenderableDate || r, lastRenderableDate: this.lastRenderableDate || a }; return s }).$inject = ["$locale", "$filter"], e.provider("$mdDateLocale", new t) }]), se.module("material.components.datepicker").factory("$$mdDateUtil", function() { return { getFirstDateOfMonth: n, getNumberOfDaysInMonth: o, getDateInNextMonth: i, getDateInPreviousMonth: r, isInNextMonth: function(e, t) { return a(i(e), t) }, isInPreviousMonth: function(e, t) { var n = r(e); return a(t, n) }, getDateMidpoint: function(e, t) { return d((e.getTime() + t.getTime()) / 2) }, isSameMonthAndYear: a, getWeekOfMonth: function(e) { var t = n(e); return Math.floor((t.getDay() + e.getDate() - 1) / 7) }, incrementDays: function(e, t) { return new Date(e.getFullYear(), e.getMonth(), e.getDate() + t) }, incrementMonths: s, getLastDateOfMonth: function(e) { return new Date(e.getFullYear(), e.getMonth(), o(e)) }, isSameDay: function(e, t) { return e.getDate() == t.getDate() && a(e, t) }, getMonthDistance: function(e, t) { return 12 * (t.getFullYear() - e.getFullYear()) + (t.getMonth() - e.getMonth()) }, isValidDate: l, setDateTimeToMidnight: c, createDateAtMidnight: d, isDateWithinRange: function(e, t, n) { var i = d(e),
                        o = l(t) ? d(t) : null,
                        r = l(n) ? d(n) : null; return (!o || o <= i) && (!r || i <= r) }, incrementYears: function(e, t) { return s(e, 12 * t) }, getYearDistance: function(e, t) { return t.getFullYear() - e.getFullYear() }, clampDate: function(e, t, n) { var i = e;
                    t && e < t && (i = new Date(t.getTime()));
                    n && n < e && (i = new Date(n.getTime())); return i }, getTimestampFromNode: function(e) { if (e && e.hasAttribute("data-timestamp")) return Number(e.getAttribute("data-timestamp")) }, isMonthWithinRange: function(e, t, n) { var i = e.getMonth(),
                        o = e.getFullYear(); return (!t || t.getFullYear() < o || t.getMonth() <= i) && (!n || n.getFullYear() > o || n.getMonth() >= i) } };

            function n(e) { return new Date(e.getFullYear(), e.getMonth(), 1) }

            function o(e) { return new Date(e.getFullYear(), e.getMonth() + 1, 0).getDate() }

            function i(e) { return new Date(e.getFullYear(), e.getMonth() + 1, 1) }

            function r(e) { return new Date(e.getFullYear(), e.getMonth() - 1, 1) }

            function a(e, t) { return e.getFullYear() === t.getFullYear() && e.getMonth() === t.getMonth() }

            function s(e, t) { var n = new Date(e.getFullYear(), e.getMonth() + t, 1),
                    i = o(n); return i < e.getDate() ? n.setDate(i) : n.setDate(e.getDate()), n }

            function l(e) { return e && e.getTime && !isNaN(e.getTime()) }

            function c(e) { l(e) && e.setHours(0, 0, 0, 0) }

            function d(e) { var t; return c(t = se.isUndefined(e) ? new Date : new Date(e)), t } }),
        function() {
            function e(a, u, m, p) { return { template: function(e, t) { var n = t.mdHideIcons,
                            i = t.ariaLabel || t.mdPlaceholder,
                            o = "all" === n || "calendar" === n ? "" : '<md-button class="md-datepicker-button md-icon-button" type="button" tabindex="-1" aria-hidden="true" data-ng-click="ctrl.openCalendarPane($event)"><md-icon class="md-datepicker-calendar-icon" aria-label="md-calendar" md-svg-src="' + a.mdCalendar + '"></md-icon></md-button>',
                            r = ""; return "all" !== n && "triangle" !== n && (r = '<md-button type="button" md-no-ink class="md-datepicker-triangle-button md-icon-button" data-ng-click="ctrl.openCalendarPane($event)" aria-label="{{::ctrl.locale.msgOpenCalendar}}"><div class="md-datepicker-expand-triangle"></div></md-button>', e.addClass(s)), o + '<div class="md-datepicker-input-container" data-ng-class="{\'md-datepicker-focused\': ctrl.isFocused}"><input ' + (i ? 'aria-label="' + i + '" ' : "") + 'class="md-datepicker-input" aria-haspopup="true" aria-expanded="{{ctrl.isCalendarOpen}}" data-ng-focus="ctrl.setFocused(true)" data-ng-blur="ctrl.setFocused(false)"> ' + r + '</div><div class="md-datepicker-calendar-pane md-whiteframe-z1" id="{{::ctrl.calendarPaneId}}"><div class="md-datepicker-input-mask"><div class="md-datepicker-input-mask-opaque"></div></div><div class="md-datepicker-calendar"><md-calendar role="dialog" aria-label="{{::ctrl.locale.msgCalendar}}" md-current-view="{{::ctrl.currentView}}"md-min-date="ctrl.minDate"md-max-date="ctrl.maxDate"md-date-filter="ctrl.dateFilter"data-ng-model="ctrl.date" data-ng-if="ctrl.isCalendarOpen"></md-calendar></div></div>' }, require: ["ngModel", "mdDatepicker", "?^mdInputContainer", "?^form"], scope: { minDate: "=mdMinDate", maxDate: "=mdMaxDate", placeholder: "@mdPlaceholder", currentView: "@mdCurrentView", dateFilter: "=mdDateFilter", isOpen: "=?mdIsOpen", debounceInterval: "=mdDebounceInterval", dateLocale: "=mdDateLocale" }, controller: t, controllerAs: "ctrl", bindToController: !0, link: function(e, t, n, i) { var o = i[0],
                            r = i[1],
                            a = i[2],
                            s = i[3],
                            l = u.parseAttributeBoolean(n.mdNoAsterisk); if (r.configureNgModel(o, a, p), a) { var c = t[0].querySelector(".md-errors-spacer");
                            c && t.after(se.element("<div>").append(c)), a.setHasPlaceholder(n.mdPlaceholder), a.input = t, a.element.addClass(h).toggleClass(f, "calendar" !== n.mdHideIcons && "all" !== n.mdHideIcons), a.label ? l || n.$observe("required", function(e) { a.label.toggleClass("md-required", !!e) }) : m.expect(t, "aria-label", n.mdPlaceholder), e.$watch(a.isErrorGetter || function() { return o.$invalid && (o.$touched || s && s.$submitted) }, a.setInvalid) } else if (s) var d = e.$watch(function() { return s.$submitted }, function(e) { e && (r.updateErrorState(), d()) }) } } }
            t.$inject = ["$scope", "$element", "$attrs", "$window", "$mdConstant", "$mdTheming", "$mdUtil", "$mdDateLocale", "$$mdDateUtil", "$$rAF", "$filter"], e.$inject = ["$$mdSvgRegistry", "$mdUtil", "$mdAria", "inputDirective"], se.module("material.components.datepicker").directive("mdDatepicker", e); var o = "md-datepicker-invalid",
                u = "md-datepicker-open",
                h = "_md-datepicker-floating-label",
                f = "_md-datepicker-has-calendar-icon",
                s = "_md-datepicker-has-triangle-icon",
                m = /ipad|iphone|ipod|android/i;

            function t(e, t, n, i, o, r, a, s, l, c, d) { this.$window = i, this.dateUtil = l, this.$mdConstant = o, this.$mdUtil = a, this.$$rAF = c, this.$mdDateLocale = s, this.documentElement = se.element(document.documentElement), this.ngModelCtrl = null, this.inputElement = t[0].querySelector("input"), this.ngInputElement = se.element(this.inputElement), this.inputContainer = t[0].querySelector(".md-datepicker-input-container"), this.calendarPane = t[0].querySelector(".md-datepicker-calendar-pane"), this.calendarButton = t[0].querySelector(".md-datepicker-button"), this.inputMask = se.element(t[0].querySelector(".md-datepicker-input-mask-opaque")), this.$element = t, this.$attrs = n, this.$scope = e, this.date = null, this.isFocused = !1, this.isDisabled, this.setDisabled(t[0].disabled || se.isString(n.disabled)), this.isCalendarOpen = !1, this.openOnFocus = n.hasOwnProperty("mdOpenOnFocus"), this.mdInputContainer = null, this.calendarPaneOpenedFrom = null, this.calendarPaneId = "md-date-pane-" + a.nextUid(), this.bodyClickHandler = se.bind(this, this.handleBodyClick), this.windowEventName = m.test(navigator.userAgent || navigator.vendor || j.opera) ? "orientationchange" : "resize", this.windowEventHandler = a.debounce(se.bind(this, this.closeCalendarPane), 100), this.windowBlurHandler = se.bind(this, this.handleWindowBlur), this.ngDateFilter = d("date"), this.leftMargin = 20, this.topMargin = null, n.tabindex ? (this.ngInputElement.attr("tabindex", n.tabindex), n.$set("tabindex", null)) : n.$set("tabindex", "-1"), n.$set("aria-owns", this.calendarPaneId), r(t), r(se.element(this.calendarPane)); var u = this;
                e.$on("$destroy", function() { u.detachCalendarPane() }), n.mdIsOpen && e.$watch("ctrl.isOpen", function(e) { e ? u.openCalendarPane({ target: u.inputElement }) : u.closeCalendarPane() }), 1 === se.version.major && se.version.minor <= 4 && this.$onInit() }
            t.prototype.$onInit = function() { this.locale = this.dateLocale ? se.extend({}, this.$mdDateLocale, this.dateLocale) : this.$mdDateLocale, this.installPropertyInterceptors(), this.attachChangeListeners(), this.attachInteractionListeners() }, t.prototype.configureNgModel = function(e, t, n) { this.ngModelCtrl = e, this.mdInputContainer = t, this.$attrs.$set("type", "date"), n[0].link.pre(this.$scope, { on: se.noop, val: se.noop, 0: {} }, this.$attrs, [e]); var i = this;
                i.ngModelCtrl.$formatters.push(function(e) { var t = se.isDefined(e) ? Date.parse(e) : null; if (!isNaN(t) && se.isNumber(t) && (e = new Date(t)), e && !(e instanceof Date)) throw Error("The data-ng-model for md-datepicker must be a Date instance or a value that can be parsed into a date. Currently the model is of type: " + typeof e); return i.onExternalChange(e), e }), e.$viewChangeListeners.unshift(se.bind(this, this.updateErrorState)); var o = i.$mdUtil.getModelOption(e, "updateOn");
                o && this.ngInputElement.on(o, se.bind(this.$element, this.$element.triggerHandler, o)) }, t.prototype.attachChangeListeners = function() { var n = this;
                n.$scope.$on("md-calendar-change", function(e, t) { n.setModelValue(t), n.onExternalChange(t), n.closeCalendarPane() }), n.ngInputElement.on("input", se.bind(n, n.resizeInputElement)); var e = se.isDefined(this.debounceInterval) ? this.debounceInterval : 500;
                n.ngInputElement.on("input", n.$mdUtil.debounce(n.handleInputEvent, e, n)) }, t.prototype.attachInteractionListeners = function() { var t = this,
                    n = this.$scope,
                    i = this.$mdConstant.KEY_CODE;
                t.ngInputElement.on("keydown", function(e) { e.altKey && e.keyCode == i.DOWN_ARROW && (t.openCalendarPane(e), n.$digest()) }), t.openOnFocus && (t.ngInputElement.on("focus", se.bind(t, t.openCalendarPane)), se.element(t.$window).on("blur", t.windowBlurHandler), n.$on("$destroy", function() { se.element(t.$window).off("blur", t.windowBlurHandler) })), n.$on("md-calendar-close", function() { t.closeCalendarPane() }) }, t.prototype.installPropertyInterceptors = function() { var t = this; if (this.$attrs.ngDisabled) { var e = this.$scope.$parent;
                    e && e.$watch(this.$attrs.ngDisabled, function(e) { t.setDisabled(e) }) }
                Object.defineProperty(this, "placeholder", { get: function() { return t.inputElement.placeholder }, set: function(e) { t.inputElement.placeholder = e || "" } }) }, t.prototype.setDisabled = function(e) { this.isDisabled = e, this.inputElement.disabled = e, this.calendarButton && (this.calendarButton.disabled = e) }, t.prototype.updateErrorState = function(e) { var t = e || this.date; if (this.clearErrorState(), this.dateUtil.isValidDate(t)) { if (t = this.dateUtil.createDateAtMidnight(t), this.dateUtil.isValidDate(this.minDate)) { var n = this.dateUtil.createDateAtMidnight(this.minDate);
                        this.ngModelCtrl.$setValidity("mindate", n <= t) } if (this.dateUtil.isValidDate(this.maxDate)) { var i = this.dateUtil.createDateAtMidnight(this.maxDate);
                        this.ngModelCtrl.$setValidity("maxdate", t <= i) }
                    se.isFunction(this.dateFilter) && this.ngModelCtrl.$setValidity("filtered", this.dateFilter(t)) } else this.ngModelCtrl.$setValidity("valid", null == t);
                se.element(this.inputContainer).toggleClass(o, !this.ngModelCtrl.$valid) }, t.prototype.clearErrorState = function() { this.inputContainer.classList.remove(o), ["mindate", "maxdate", "filtered", "valid"].forEach(function(e) { this.ngModelCtrl.$setValidity(e, !0) }, this) }, t.prototype.resizeInputElement = function() { this.inputElement.size = this.inputElement.value.length + 3 }, t.prototype.handleInputEvent = function() { var e = this.inputElement.value,
                    t = e ? this.locale.parseDate(e) : null;
                this.dateUtil.setDateTimeToMidnight(t), ("" == e || this.dateUtil.isValidDate(t) && this.locale.isDateComplete(e) && this.isDateEnabled(t)) && (this.setModelValue(t), this.date = t), this.updateErrorState(t) }, t.prototype.isDateEnabled = function(e) { return this.dateUtil.isDateWithinRange(e, this.minDate, this.maxDate) && (!se.isFunction(this.dateFilter) || this.dateFilter(e)) }, t.prototype.attachCalendarPane = function() { var e = this.calendarPane,
                    t = document.body;
                e.style.transform = "", this.$element.addClass(u), this.mdInputContainer && this.mdInputContainer.element.addClass(u), se.element(t).addClass("md-datepicker-is-showing"); var n = this.inputContainer.getBoundingClientRect(),
                    i = t.getBoundingClientRect();
                (!this.topMargin || this.topMargin < 0) && (this.topMargin = (this.inputMask.parent().prop("clientHeight") - this.ngInputElement.prop("clientHeight")) / 2); var o = n.top - i.top - this.topMargin,
                    r = n.left - i.left - this.leftMargin,
                    a = i.top < 0 && 0 == document.body.scrollTop ? -i.top : document.body.scrollTop,
                    s = i.left < 0 && 0 == document.body.scrollLeft ? -i.left : document.body.scrollLeft,
                    l = a + this.$window.innerHeight,
                    c = s + this.$window.innerWidth; if (this.inputMask.css({ position: "absolute", left: this.leftMargin + "px", top: this.topMargin + "px", width: n.width - 1 + "px", height: n.height - 2 + "px" }), c < r + 360) { if (0 < c - 360) r = c - 360;
                    else { r = s; var d = this.$window.innerWidth / 360;
                        e.style.transform = "scale(" + d + ")" }
                    e.classList.add("md-datepicker-pos-adjusted") }
                l < o + 368 && a < l - 368 && (o = l - 368, e.classList.add("md-datepicker-pos-adjusted")), e.style.left = r + "px", e.style.top = o + "px", document.body.appendChild(e), this.$$rAF(function() { e.classList.add("md-pane-open") }) }, t.prototype.detachCalendarPane = function() { this.$element.removeClass(u), this.mdInputContainer && this.mdInputContainer.element.removeClass(u), se.element(document.body).removeClass("md-datepicker-is-showing"), this.calendarPane.classList.remove("md-pane-open"), this.calendarPane.classList.remove("md-datepicker-pos-adjusted"), this.isCalendarOpen && this.$mdUtil.enableScrolling(), this.calendarPane.parentNode && this.calendarPane.parentNode.removeChild(this.calendarPane) }, t.prototype.openCalendarPane = function(e) { if (!this.isCalendarOpen && !this.isDisabled && !this.inputFocusedOnWindowBlur) { this.isCalendarOpen = this.isOpen = !0, this.calendarPaneOpenedFrom = e.target, this.$mdUtil.disableScrollAround(this.calendarPane), this.attachCalendarPane(), this.focusCalendar(), this.evalAttr("ngFocus"); var t = this;
                    this.$mdUtil.nextTick(function() { t.documentElement.on("click touchstart", t.bodyClickHandler) }, !1), j.addEventListener(this.windowEventName, this.windowEventHandler) } }, t.prototype.closeCalendarPane = function() { if (this.isCalendarOpen) { var e = this;
                    e.detachCalendarPane(), e.ngModelCtrl.$setTouched(), e.evalAttr("ngBlur"), e.documentElement.off("click touchstart", e.bodyClickHandler), j.removeEventListener(e.windowEventName, e.windowEventHandler), e.calendarPaneOpenedFrom.focus(), e.calendarPaneOpenedFrom = null, e.openOnFocus ? e.$mdUtil.nextTick(t) : t() }

                function t() { e.isCalendarOpen = e.isOpen = !1 } }, t.prototype.getCalendarCtrl = function() { return se.element(this.calendarPane.querySelector("md-calendar")).controller("mdCalendar") }, t.prototype.focusCalendar = function() { var e = this;
                this.$mdUtil.nextTick(function() { e.getCalendarCtrl().focus() }, !1) }, t.prototype.setFocused = function(e) { e || this.ngModelCtrl.$setTouched(), this.openOnFocus || this.evalAttr(e ? "ngFocus" : "ngBlur"), this.isFocused = e }, t.prototype.handleBodyClick = function(e) { this.isCalendarOpen && (this.$mdUtil.getClosest(e.target, "md-calendar") || this.closeCalendarPane(), this.$scope.$digest()) }, t.prototype.handleWindowBlur = function() { this.inputFocusedOnWindowBlur = document.activeElement === this.inputElement }, t.prototype.evalAttr = function(e) { this.$attrs[e] && this.$scope.$parent.$eval(this.$attrs[e]) }, t.prototype.setModelValue = function(e) { var t = this.$mdUtil.getModelOption(this.ngModelCtrl, "timezone");
                this.ngModelCtrl.$setViewValue(this.ngDateFilter(e, "yyyy-MM-dd", t)) }, t.prototype.onExternalChange = function(e) { var t = this.$mdUtil.getModelOption(this.ngModelCtrl, "timezone");
                this.date = e, this.inputElement.value = this.locale.formatDate(e, t), this.mdInputContainer && this.mdInputContainer.setHasValue(!!e), this.resizeInputElement(), this.updateErrorState() } }(), se.module("material.components.icon").directive("mdIcon", ["$mdIcon", "$mdTheming", "$mdAria", "$sce", function(l, c, d, e) { return { restrict: "E", link: function(e, t, n) { c(t); var i = n.mdFontIcon,
                        o = l.fontSet(n.mdFontSet);
                    n.mdSvgIcon || n.mdSvgSrc || (n.mdFontIcon && t.addClass("md-font " + n.mdFontIcon), t.addClass(o)), n.$observe("mdFontIcon", s), n.$observe("mdFontSet", s);
                    t[0].getAttribute(n.$attr.mdSvgSrc); var r, a = n.$normalize(n.$attr.mdSvgIcon || n.$attr.mdSvgSrc || "");
                    n.role || (d.expect(t, "role", "img"), n.role = "img"); "img" !== n.role || n.ariaHidden || d.hasAriaLabel(t) || (n.alt ? d.expect(t, "aria-label", n.alt) : d.parentHasAriaLabel(t, 2) ? d.expect(t, "aria-hidden", "true") : (r = n.mdFontIcon || n.mdSvgIcon || t.text()) ? d.expect(t, "aria-label", r) : d.expect(t, "aria-hidden", "true"));
                    a && n.$observe(a, function(e) { t.empty(), e && l(e).then(function(e) { t.empty(), t.append(e) }) });

                    function s() { if (!n.mdSvgIcon && !n.mdSvgSrc) { n.mdFontIcon && (t.removeClass(i), t.addClass(n.mdFontIcon), i = n.mdFontIcon); var e = l.fontSet(n.mdFontSet);
                            o !== e && (t.removeClass(o), t.addClass(e), o = e) } } } } }]),
        function() { a.$inject = ["config", "$templateRequest", "$q", "$log", "$mdUtil", "$sce"], se.module("material.components.icon").constant("$$mdSvgRegistry", { mdTabsArrow: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwb2x5Z29uIHBvaW50cz0iMTUuNCw3LjQgMTQsNiA4LDEyIDE0LDE4IDE1LjQsMTYuNiAxMC44LDEyICIvPjwvZz48L3N2Zz4=", mdClose: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik0xOSA2LjQxbC0xLjQxLTEuNDEtNS41OSA1LjU5LTUuNTktNS41OS0xLjQxIDEuNDEgNS41OSA1LjU5LTUuNTkgNS41OSAxLjQxIDEuNDEgNS41OS01LjU5IDUuNTkgNS41OSAxLjQxLTEuNDEtNS41OS01LjU5eiIvPjwvZz48L3N2Zz4=", mdCancel: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik0xMiAyYy01LjUzIDAtMTAgNC40Ny0xMCAxMHM0LjQ3IDEwIDEwIDEwIDEwLTQuNDcgMTAtMTAtNC40Ny0xMC0xMC0xMHptNSAxMy41OWwtMS40MSAxLjQxLTMuNTktMy41OS0zLjU5IDMuNTktMS40MS0xLjQxIDMuNTktMy41OS0zLjU5LTMuNTkgMS40MS0xLjQxIDMuNTkgMy41OSAzLjU5LTMuNTkgMS40MSAxLjQxLTMuNTkgMy41OSAzLjU5IDMuNTl6Ii8+PC9nPjwvc3ZnPg==", mdMenu: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik0zLDZIMjFWOEgzVjZNMywxMUgyMVYxM0gzVjExTTMsMTZIMjFWMThIM1YxNloiIC8+PC9zdmc+", mdToggleArrow: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgNDggNDgiPjxwYXRoIGQ9Ik0yNCAxNmwtMTIgMTIgMi44MyAyLjgzIDkuMTctOS4xNyA5LjE3IDkuMTcgMi44My0yLjgzeiIvPjxwYXRoIGQ9Ik0wIDBoNDh2NDhoLTQ4eiIgZmlsbD0ibm9uZSIvPjwvc3ZnPg==", mdCalendar: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgM2gtMVYxaC0ydjJIOFYxSDZ2Mkg1Yy0xLjExIDAtMS45OS45LTEuOTkgMkwzIDE5YzAgMS4xLjg5IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bTAgMTZINVY4aDE0djExek03IDEwaDV2NUg3eiIvPjwvc3ZnPg==", mdChecked: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik05IDE2LjE3TDQuODMgMTJsLTEuNDIgMS40MUw5IDE5IDIxIDdsLTEuNDEtMS40MXoiLz48L2c+PC9zdmc+" }).provider("$mdIcon", e); var r = { defaultViewBoxSize: 24, defaultFontSet: "material-icons", fontSets: [] };

            function e() {}

            function i(e, t) { this.url = e, this.viewBoxSize = t || r.defaultViewBoxSize }

            function a(a, r, s, l, i, t) { var o = {},
                    c = {},
                    n = /[-\w@:%\+.~#?&//=]{2,}\.[a-z]{2,4}\b(\/[-\w@:%\+.~#?&//=]*)?/i,
                    d = /^data:image\/svg\+xml[\s*;\w\-\=]*?(base64)?,(.*)$/i; return f.prototype = { clone: function() { return this.element.cloneNode(!0) }, prepare: function() { var e = this.config ? this.config.viewBoxSize : a.defaultViewBoxSize;
                        se.forEach({ fit: "", height: "100%", width: "100%", preserveAspectRatio: "xMidYMid meet", viewBox: this.element.getAttribute("viewBox") || "0 0 " + e + " " + e, focusable: !1 }, function(e, t) { this.element.setAttribute(t, e) }, this) } }, e.fontSet = function(t) { if (se.isUndefined(t) || !t || !t.length) return a.defaultFontSet; var n = t; return se.forEach(a.fontSets, function(e) { e.alias == t && (n = e.fontSet || n) }), n }, e;

                function e(e) { return e = e || "", se.isString(e) || (e = t.getTrustedUrl(e)), o[e] ? s.when(function(e) { var t = e.clone(),
                            n = "_cache" + i.nextUid();
                        t.id && (t.id += n); return se.forEach(t.querySelectorAll("[id]"), function(e) { e.id += n }), t }(o[e])) : n.test(e) || d.test(e) ? h(e).then(u(e)) : (-1 == e.indexOf(":") && (e = "$default:" + e), (a[e] ? m : p)(e).then(u(e))) }

                function u(n) { return function(e) { var t; return o[n] = (t = e, se.isDefined(t.element) && se.isDefined(t.config) ? e : new f(e, a[n])), o[n].clone() } }

                function m(e) { var t = a[e]; return h(t.url).then(function(e) { return new f(e, t) }) }

                function p(i) { var e = i.substring(0, i.lastIndexOf(":")) || "$default",
                        o = a[e]; return o ? h(o.url).then(function(e) { var t = i.slice(i.lastIndexOf(":") + 1),
                            n = e.querySelector("#" + t); return n ? new f(n, o) : r(i) }) : r(i);

                    function r(e) { var t = "icon " + e + " not found"; return l.warn(t), s.reject(t || e) } }

                function h(e) { return d.test(e) ? (t = e, n = d.exec(t), o = /base64/i.test(t) ? j.atob(n[2]) : n[2], s.when(se.element(o)[0])) : (i = e, s(function(t, n) { r(i, !0).then(function(e) { c[i] || (c[i] = se.element("<div>").append(e)[0].querySelector("svg")), t(c[i]) }, function(e) { var t = se.isString(e) ? e : e.message || e.data || e.statusText;
                            l.warn(t), n(e) }) })); var i, t, n, o }

                function f(e, t) { e && "svg" != e.tagName && (e = se.element('<svg xmlns="http://www.w3.org/2000/svg">').append(e.cloneNode(!0))[0]), e.getAttribute("xmlns") || e.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.element = e, this.config = t, this.prepare() } }
            e.prototype = { icon: function(e, t, n) { return -1 == e.indexOf(":") && (e = "$default:" + e), r[e] = new i(t, n), this }, iconSet: function(e, t, n) { return r[e] = new i(t, n), this }, defaultIconSet: function(e, t) { var n = "$default"; return r[n] || (r[n] = new i(e, t)), r[n].viewBoxSize = t || r.defaultViewBoxSize, this }, defaultViewBoxSize: function(e) { return r.defaultViewBoxSize = e, this }, fontSet: function(e, t) { return r.fontSets.push({ alias: e, fontSet: t || e }), this }, defaultFontSet: function(e) { return r.defaultFontSet = e || "", this }, defaultIconSize: function(e) { return r.defaultIconSize = e, this }, $get: ["$templateRequest", "$q", "$log", "$mdUtil", "$sce", function(e, t, n, i, o) { return a(r, e, t, n, i, o) }] } }(), Je.$inject = ["$mdMenu", "$attrs", "$element", "$scope", "$mdUtil", "$timeout", "$rootScope", "$q", "$log"], se.module("material.components.menu").controller("mdMenuCtrl", Je), et.$inject = ["$mdUtil"], se.module("material.components.menu").directive("mdMenu", et), tt.$inject = ["$$interimElementProvider"], se.module("material.components.menu").provider("$mdMenu", tt),
        function() { e.$inject = ["$scope", "$rootScope", "$element", "$attrs", "$mdConstant", "$document", "$mdUtil", "$timeout"], se.module("material.components.menuBar").controller("MenuBarController", e); var c = ["handleKeyDown", "handleMenuHover", "scheduleOpenHoveredMenu", "cancelScheduledOpen"];

            function e(e, t, n, i, o, r, a, s) { this.$element = n, this.$attrs = i, this.$mdConstant = o, this.$mdUtil = a, this.$document = r, this.$scope = e, this.$rootScope = t, this.$timeout = s; var l = this;
                se.forEach(c, function(e) { l[e] = se.bind(l, l[e]) }) }
            e.prototype.init = function() { var r = this.$element,
                    a = this.$mdUtil,
                    e = this.$scope,
                    s = this,
                    t = [];
                r.on("keydown", this.handleKeyDown), this.parentToolbar = a.getClosest(r, "MD-TOOLBAR"), t.push(this.$rootScope.$on("$mdMenuOpen", function(e, t) {-1 != s.getMenus().indexOf(t[0]) && (r[0].classList.add("md-open"), t[0].classList.add("md-open"), s.currentlyOpenMenu = t.controller("mdMenu"), s.currentlyOpenMenu.registerContainerProxy(s.handleKeyDown), s.enableOpenOnHover()) })), t.push(this.$rootScope.$on("$mdMenuClose", function(e, t, n) { var i = s.getMenus(); if (-1 != i.indexOf(t[0]) && (r[0].classList.remove("md-open"), t[0].classList.remove("md-open")), r[0].contains(t[0])) { for (var o = t[0]; o && -1 == i.indexOf(o);) o = a.getClosest(o, "MD-MENU", !0);
                        o && (n.skipFocus || o.querySelector("button:not([disabled])").focus(), s.currentlyOpenMenu = le, s.disableOpenOnHover(), s.setKeyboardMode(!0)) } })), e.$on("$destroy", function() { for (s.disableOpenOnHover(); t.length;) t.shift()() }), this.setKeyboardMode(!0) }, e.prototype.setKeyboardMode = function(e) { e ? this.$element[0].classList.add("md-keyboard-mode") : this.$element[0].classList.remove("md-keyboard-mode") }, e.prototype.enableOpenOnHover = function() { if (!this.openOnHoverEnabled) { var e = this;
                    e.openOnHoverEnabled = !0, e.parentToolbar && (e.parentToolbar.classList.add("md-has-open-menu"), e.$mdUtil.nextTick(function() { se.element(e.parentToolbar).on("click", e.handleParentClick) }, !1)), se.element(e.getMenus()).on("mouseenter", e.handleMenuHover) } }, e.prototype.handleMenuHover = function(e) { this.setKeyboardMode(!1), this.openOnHoverEnabled && this.scheduleOpenHoveredMenu(e) }, e.prototype.disableOpenOnHover = function() { this.openOnHoverEnabled && (this.openOnHoverEnabled = !1, this.parentToolbar && (this.parentToolbar.classList.remove("md-has-open-menu"), se.element(this.parentToolbar).off("click", this.handleParentClick)), se.element(this.getMenus()).off("mouseenter", this.handleMenuHover)) }, e.prototype.scheduleOpenHoveredMenu = function(e) { var t = se.element(e.currentTarget).controller("mdMenu");
                this.setKeyboardMode(!1), this.scheduleOpenMenu(t) }, e.prototype.scheduleOpenMenu = function(e) { var t = this,
                    n = this.$timeout;
                e != t.currentlyOpenMenu && (n.cancel(t.pendingMenuOpen), t.pendingMenuOpen = n(function() { t.pendingMenuOpen = le, t.currentlyOpenMenu && t.currentlyOpenMenu.close(!0, { closeAll: !0 }), e.open() }, 200, !1)) }, e.prototype.handleKeyDown = function(e) { var t, n, i, o = this.$mdConstant.KEY_CODE,
                    r = this.currentlyOpenMenu,
                    a = r && r.isOpen; switch (this.setKeyboardMode(!0), e.keyCode) {
                    case o.DOWN_ARROW:
                        r ? r.focusMenuContainer() : this.openFocusedMenu(), t = !0; break;
                    case o.UP_ARROW:
                        r && r.close(), t = !0; break;
                    case o.LEFT_ARROW:
                        n = this.focusMenu(-1), a && (i = se.element(n).controller("mdMenu"), this.scheduleOpenMenu(i)), t = !0; break;
                    case o.RIGHT_ARROW:
                        n = this.focusMenu(1), a && (i = se.element(n).controller("mdMenu"), this.scheduleOpenMenu(i)), t = !0 }
                t && (e && e.preventDefault && e.preventDefault(), e && e.stopImmediatePropagation && e.stopImmediatePropagation()) }, e.prototype.focusMenu = function(e) { var t = this.getMenus(),
                    n = this.getFocusedMenuIndex(); - 1 == n && (n = this.getOpenMenuIndex()); var i = !1; if (-1 == n ? i = !(n = 0) : (e < 0 && 0 < n || 0 < e && n < t.length - e) && (n += e, i = !0), i) return t[n].querySelector("button").focus(), t[n] }, e.prototype.openFocusedMenu = function() { var e = this.getFocusedMenu();
                e && se.element(e).controller("mdMenu").open() }, e.prototype.getMenus = function() { var e = this.$element; return this.$mdUtil.nodesToArray(e[0].children).filter(function(e) { return "MD-MENU" == e.nodeName }) }, e.prototype.getFocusedMenu = function() { return this.getMenus()[this.getFocusedMenuIndex()] }, e.prototype.getFocusedMenuIndex = function() { var e = this.$mdUtil.getClosest(this.$document[0].activeElement, "MD-MENU"); return e ? this.getMenus().indexOf(e) : -1 }, e.prototype.getOpenMenuIndex = function() { for (var e = this.getMenus(), t = 0; t < e.length; ++t)
                    if (e[t].classList.contains("md-open")) return t;
                return -1 }, e.prototype.handleParentClick = function(e) { var t = this.querySelector("md-menu.md-open");
                t && !t.contains(e.target) && se.element(t).controller("mdMenu").close(!0, { closeAll: !0 }) } }(), nt.$inject = ["$mdUtil", "$mdTheming"], se.module("material.components.menuBar").directive("mdMenuBar", nt), se.module("material.components.menuBar").directive("mdMenuDivider", function() { return { restrict: "E", compile: function(e, t) { t.role || e[0].setAttribute("role", "separator") } } }), it.$inject = ["$scope", "$element", "$attrs"], se.module("material.components.menuBar").controller("MenuItemController", it), it.prototype.init = function(e) { var t = this.$element,
                n = this.$attrs;
            this.ngModel = e, "checkbox" != n.type && "radio" != n.type || (this.mode = n.type, this.iconEl = t[0].children[0], this.buttonEl = t[0].children[1], e && this.initClickListeners()) }, it.prototype.clearNgAria = function() { var t = this.$element[0];
            se.forEach(["role", "tabindex", "aria-invalid", "aria-checked"], function(e) { t.removeAttribute(e) }) }, it.prototype.initClickListeners = function() { var e = this,
                t = this.ngModel,
                n = this.$scope,
                i = this.$attrs,
                o = (this.$element, this.mode);
            this.handleClick = se.bind(this, this.handleClick); var r = this.iconEl,
                a = se.element(this.buttonEl),
                s = this.handleClick;

            function l(e) { e ? a.off("click", s) : a.on("click", s) }
            i.$observe("disabled", l), l(i.disabled), t.$render = function() { e.clearNgAria(), ! function() {
                    { if ("radio" != o) return t.$modelValue; var e = i.ngValue ? n.$eval(i.ngValue) : i.value; return t.$modelValue == e } }() ? (r.style.display = "none", a.attr("aria-checked", "false")) : (r.style.display = "", a.attr("aria-checked", "true")) }, n.$$postDigest(t.$render) }, it.prototype.handleClick = function(e) { var t, n = this.mode,
                i = this.ngModel,
                o = this.$attrs; "checkbox" == n ? t = !i.$modelValue : "radio" == n && (t = o.ngValue ? this.$scope.$eval(o.ngValue) : o.value), i.$setViewValue(t), i.$render() }, ot.$inject = ["$mdUtil", "$mdConstant", "$$mdSvgRegistry"], se.module("material.components.menuBar").directive("mdMenuItem", ot), rt.$inject = ["$window", "$mdProgressCircular", "$mdTheming", "$mdUtil", "$interval", "$log"], se.module("material.components.progressCircular").directive("mdProgressCircular", rt), se.module("material.components.progressCircular").provider("$mdProgressCircular", function() { var t = { progressSize: 50, strokeWidth: 10, duration: 100, easeFn: e, durationIndeterminate: 1333, startIndeterminate: 1, endIndeterminate: 149, easeFnIndeterminate: n, easingPresets: { linearEase: e, materialEase: n } }; return { configure: function(e) { return t = se.extend(t, e || {}) }, $get: function() { return t } };

            function e(e, t, n, i) { return n * e / i + t }

            function n(e, t, n, i) { var o = (e /= i) * e,
                    r = o * e; return t + n * (6 * r * o + -15 * o * o + 10 * r) } }), se.module("material.components.tabs").directive("mdTab", function() { return { require: "^?mdTabs", terminal: !0, compile: function(e, t) { var n = l(e, "md-tab-label"),
                        i = l(e, "md-tab-body"); if (0 === n.length && (n = se.element("<md-tab-label></md-tab-label>"), t.label ? n.text(t.label) : n.append(e.contents()), 0 === i.length)) { var o = e.contents().detach();
                        (i = se.element("<md-tab-body></md-tab-body>")).append(o) } return e.append(n), i.html() && e.append(i), r }, scope: { active: "=?mdActive", disabled: "=?ngDisabled", select: "&?mdOnSelect", deselect: "&?mdOnDeselect" } };

            function r(e, t, n, i) { if (i) { var o = i.getTabElementIndex(t),
                        r = l(t, "md-tab-body").remove(),
                        a = l(t, "md-tab-label").remove(),
                        s = i.insertTab({ scope: e, parent: e.$parent, index: o, element: t, template: r.html(), label: a.html() }, o);
                    e.select = e.select || se.noop, e.deselect = e.deselect || se.noop, e.$watch("active", function(e) { e && i.select(s.getIndex(), !0) }), e.$watch("disabled", function() { i.refreshIndex() }), e.$watch(function() { return i.getTabElementIndex(t) }, function(e) { s.index = e, i.updateTabOrder() }), e.$on("$destroy", function() { i.removeTab(s) }) } }

            function l(e, t) { for (var n = e[0].children, i = 0, o = n.length; i < o; i++) { var r = n[i]; if (r.tagName === t.toUpperCase()) return se.element(r) } return se.element() } }), se.module("material.components.tabs").directive("mdTabItem", function() { return { require: "^?mdTabs", link: function(e, t, n, i) { i && i.attachRipple(e, t) } } }), se.module("material.components.tabs").directive("mdTabLabel", function() { return { terminal: !0 } }), at.$inject = ["$parse"], se.module("material.components.tabs").directive("mdTabScroll", at), st.$inject = ["$scope", "$element", "$window", "$mdConstant", "$mdTabInkRipple", "$mdUtil", "$animateCss", "$attrs", "$compile", "$mdTheming", "$mdInteraction", "MdTabsPaginationService"], se.module("material.components.tabs").controller("MdTabsController", st), lt.$inject = ["$$mdSvgRegistry"], se.module("material.components.tabs").directive("mdTabs", lt), ct.$inject = ["$mdUtil", "$window"], se.module("material.components.tabs").directive("mdTabsDummyWrapper", ct), dt.$inject = ["$compile", "$mdUtil"], se.module("material.components.tabs").directive("mdTabsTemplate", dt) }(window, window.angular), window.ngMaterial = { version: { full: "1.1.4-master-baa869a" } };